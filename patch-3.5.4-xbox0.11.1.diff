diff -NurpP --minimal linux-3.5.4/arch/powerpc/boot/Makefile linux-3.5.4-xenon/arch/powerpc/boot/Makefile
--- linux-3.5.4/arch/powerpc/boot/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/boot/Makefile	2012-10-08 18:39:07.925017610 +0200
@@ -177,6 +177,7 @@ image-$(CONFIG_PPC_POWERNV)		+= zImage.p
 image-$(CONFIG_PPC_MAPLE)		+= zImage.maple
 image-$(CONFIG_PPC_IBM_CELL_BLADE)	+= zImage.pseries
 image-$(CONFIG_PPC_PS3)			+= dtbImage.ps3
+image-$(CONFIG_PPC_XENON)		+= zImage.xenon
 image-$(CONFIG_PPC_CELLEB)		+= zImage.pseries
 image-$(CONFIG_PPC_CELL_QPACE)		+= zImage.pseries
 image-$(CONFIG_PPC_CHRP)		+= zImage.chrp
@@ -310,6 +311,11 @@ $(obj)/dtbImage.%: vmlinux $(wrapperbits
 $(obj)/vmlinux.strip: vmlinux
 	$(STRIP) -s -R .comment $< -o $@
 
+$(obj)/zImage.xenon: $(obj)/vmlinux.strip
+	$(OBJCOPY) -O elf32-powerpc $< $@
+	@ test -e /mnt/nfsroot/tftpboot && \
+		cp -f $@ /mnt/nfsroot/tftpboot/zImage_2.6.33.xenon || true
+
 $(obj)/uImage: vmlinux $(wrapperbits)
 	$(call if_changed,wrap,uboot)
 
diff -NurpP --minimal linux-3.5.4/arch/powerpc/include/asm/cputable.h linux-3.5.4-xenon/arch/powerpc/include/asm/cputable.h
--- linux-3.5.4/arch/powerpc/include/asm/cputable.h	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/include/asm/cputable.h	2012-10-08 18:39:07.925017610 +0200
@@ -438,6 +438,10 @@ extern const char *powerpc_base_platform
 	    CPU_FTR_ALTIVEC_COMP | CPU_FTR_MMCRA | CPU_FTR_SMT | \
 	    CPU_FTR_PAUSE_ZERO  | CPU_FTR_CELL_TB_BUG | CPU_FTR_CP_USE_DCBTZ | \
 	    CPU_FTR_UNALIGNED_LD_STD)
+#define CPU_FTRS_XENON (CPU_FTR_USE_TB | CPU_FTR_LWSYNC | \
+	    CPU_FTR_PPCAS_ARCH_V2 | CPU_FTR_CTRL | \
+	    CPU_FTR_MMCRA | CPU_FTR_SMT | \
+	    CPU_FTR_CELL_TB_BUG )
 #define CPU_FTRS_PA6T (CPU_FTR_USE_TB | CPU_FTR_LWSYNC | \
 	    CPU_FTR_PPCAS_ARCH_V2 | CPU_FTR_ALTIVEC_COMP | \
 	    CPU_FTR_PURR | CPU_FTR_REAL_LE)
@@ -493,6 +497,9 @@ enum {
 #ifdef CONFIG_PPC_E500MC
 	    CPU_FTRS_E500MC | CPU_FTRS_E5500 | CPU_FTRS_E6500 |
 #endif
+#ifdef CONFIG_PPC_XENON
+		CPU_FTRS_XENON |
+#endif
 	    0,
 };
 #endif /* __powerpc64__ */
diff -NurpP --minimal linux-3.5.4/arch/powerpc/include/asm/mmu.h linux-3.5.4-xenon/arch/powerpc/include/asm/mmu.h
--- linux-3.5.4/arch/powerpc/include/asm/mmu.h	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/include/asm/mmu.h	2012-10-08 18:39:07.925017610 +0200
@@ -103,6 +103,8 @@
 #define MMU_FTRS_POWER7		MMU_FTRS_POWER4 | MMU_FTR_LOCKLESS_TLBIE
 #define MMU_FTRS_CELL		MMU_FTRS_DEFAULT_HPTE_ARCH_V2 | \
 				MMU_FTR_CI_LARGE_PAGE
+#define MMU_FTRS_XENON		MMU_FTRS_DEFAULT_HPTE_ARCH_V2 | \
+				MMU_FTR_CI_LARGE_PAGE
 #define MMU_FTRS_PA6T		MMU_FTRS_DEFAULT_HPTE_ARCH_V2 | \
 				MMU_FTR_CI_LARGE_PAGE | MMU_FTR_NO_SLBIE_B
 #define MMU_FTRS_A2		MMU_FTR_TYPE_3E | MMU_FTR_USE_TLBILX | \
diff -NurpP --minimal linux-3.5.4/arch/powerpc/Kconfig linux-3.5.4-xenon/arch/powerpc/Kconfig
--- linux-3.5.4/arch/powerpc/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/Kconfig	2012-10-08 18:39:07.925017610 +0200
@@ -120,7 +120,7 @@ config PPC
 	select HAVE_REGS_AND_STACK_ACCESS_API
 	select HAVE_HW_BREAKPOINT if PERF_EVENTS && PPC_BOOK3S_64
 	select HAVE_GENERIC_HARDIRQS
-	select SPARSE_IRQ
+	select HAVE_SPARSE_IRQ
 	select IRQ_PER_CPU
 	select IRQ_DOMAIN
 	select GENERIC_IRQ_SHOW
@@ -1012,3 +1012,4 @@ config PPC_LIB_RHEAP
 	bool
 
 source "arch/powerpc/kvm/Kconfig"
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/kernel/cputable.c linux-3.5.4-xenon/arch/powerpc/kernel/cputable.c
--- linux-3.5.4/arch/powerpc/kernel/cputable.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/kernel/cputable.c	2012-10-08 18:39:07.925017610 +0200
@@ -480,6 +480,18 @@ static struct cpu_spec __initdata cpu_sp
 		.oprofile_type		= PPC_OPROFILE_CELL,
 		.platform		= "ppc-cell-be",
 	},
+	{	/* Xenon */
+		.pvr_mask		= 0xffff0000,
+		.pvr_value		= 0x00710000,
+		.cpu_name		= "Xenon",
+		.cpu_features		= CPU_FTRS_XENON,
+		.cpu_user_features	= COMMON_USER_PPC64 |
+			PPC_FEATURE_SMT,
+		.mmu_features		= MMU_FTRS_XENON,
+		.icache_bsize		= 128,
+		.dcache_bsize		= 128,
+		.platform		= "xenon",
+	},
 	{	/* PA Semi PA6T */
 		.pvr_mask		= 0x7fff0000,
 		.pvr_value		= 0x00900000,
diff -NurpP --minimal linux-3.5.4/arch/powerpc/kernel/crash.c linux-3.5.4-xenon/arch/powerpc/kernel/crash.c
--- linux-3.5.4/arch/powerpc/kernel/crash.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/kernel/crash.c	2012-10-08 18:39:07.929017729 +0200
@@ -253,7 +253,7 @@ static inline void crash_kexec_wait_real
  */
 int crash_shutdown_register(crash_shutdown_t handler)
 {
-	unsigned int i, rc;
+	unsigned int i, rc = 0;
 
 	spin_lock(&crash_handlers_lock);
 	for (i = 0 ; i < CRASH_HANDLER_MAX; i++)
diff -NurpP --minimal linux-3.5.4/arch/powerpc/kernel/head_64.S linux-3.5.4-xenon/arch/powerpc/kernel/head_64.S
--- linux-3.5.4/arch/powerpc/kernel/head_64.S	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/kernel/head_64.S	2012-10-08 18:39:07.929017729 +0200
@@ -578,8 +578,11 @@ _GLOBAL(pmac_secondary_start)
 	.section ".text";
 	.align 2 ;
 
+/*
 	.globl	__secondary_start
 __secondary_start:
+*/
+_INIT_GLOBAL(__secondary_start)
 	/* Set thread priority to MEDIUM */
 	HMT_MEDIUM
 
@@ -624,7 +627,7 @@ __secondary_start:
  * zero the stack back-chain pointer and get the TOC virtual address
  * before going into C code.
  */
-_GLOBAL(start_secondary_prolog)
+_INIT_GLOBAL(start_secondary_prolog)
 	ld	r2,PACATOC(r13)
 	li	r3,0
 	std	r3,0(r1)		/* Zero the stack frame pointer	*/
diff -NurpP --minimal linux-3.5.4/arch/powerpc/kernel/misc_64.S linux-3.5.4-xenon/arch/powerpc/kernel/misc_64.S
--- linux-3.5.4/arch/powerpc/kernel/misc_64.S	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/kernel/misc_64.S	2012-10-08 18:39:07.929017729 +0200
@@ -235,7 +235,7 @@ _GLOBAL(__flush_dcache_icache)
 	blr
 
 
-#if defined(CONFIG_PPC_PMAC) || defined(CONFIG_PPC_MAPLE)
+#if defined(CONFIG_PPC_PMAC) || defined(CONFIG_PPC_MAPLE) || defined(CONFIG_PPC_XENON)
 /*
  * Do an IO access in real mode
  */
diff -NurpP --minimal linux-3.5.4/arch/powerpc/kernel/process.c linux-3.5.4-xenon/arch/powerpc/kernel/process.c
--- linux-3.5.4/arch/powerpc/kernel/process.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/kernel/process.c	2012-10-08 18:39:07.929017729 +0200
@@ -1301,3 +1301,8 @@ unsigned long randomize_et_dyn(unsigned
 
 	return ret;
 }
+
+void arch_trigger_all_cpu_backtrace(void)
+{
+	panic("arch_trigger_all_cpu_backtrace() not implemented yet\n");
+}
diff -NurpP --minimal linux-3.5.4/arch/powerpc/kernel/setup_64.c linux-3.5.4-xenon/arch/powerpc/kernel/setup_64.c
--- linux-3.5.4/arch/powerpc/kernel/setup_64.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/kernel/setup_64.c	2012-10-08 18:39:07.929017729 +0200
@@ -230,7 +230,7 @@ void __init early_setup(unsigned long dt
 }
 
 #ifdef CONFIG_SMP
-void early_setup_secondary(void)
+void __cpuinit early_setup_secondary(void)
 {
 	/* Mark interrupts enabled in PACA */
 	get_paca()->soft_enabled = 0;
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/Kconfig linux-3.5.4-xenon/arch/powerpc/platforms/Kconfig
--- linux-3.5.4/arch/powerpc/platforms/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/platforms/Kconfig	2012-10-08 18:39:07.929017729 +0200
@@ -21,6 +21,7 @@ source "arch/powerpc/platforms/44x/Kconf
 source "arch/powerpc/platforms/40x/Kconfig"
 source "arch/powerpc/platforms/amigaone/Kconfig"
 source "arch/powerpc/platforms/wsp/Kconfig"
+source "arch/powerpc/platforms/xenon/Kconfig"
 
 config KVM_GUEST
 	bool "KVM Guest support"
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/Makefile linux-3.5.4-xenon/arch/powerpc/platforms/Makefile
--- linux-3.5.4/arch/powerpc/platforms/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/arch/powerpc/platforms/Makefile	2012-10-08 18:39:07.933017787 +0200
@@ -20,6 +20,7 @@ obj-$(CONFIG_PPC_MAPLE)		+= maple/
 obj-$(CONFIG_PPC_PASEMI)	+= pasemi/
 obj-$(CONFIG_PPC_CELL)		+= cell/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
+obj-$(CONFIG_PPC_XENON)		+= xenon/
 obj-$(CONFIG_EMBEDDED6xx)	+= embedded6xx/
 obj-$(CONFIG_AMIGAONE)		+= amigaone/
 obj-$(CONFIG_PPC_WSP)		+= wsp/
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/hardware.c linux-3.5.4-xenon/arch/powerpc/platforms/xenon/hardware.c
--- linux-3.5.4/arch/powerpc/platforms/xenon/hardware.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/hardware.c	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,36 @@
+/*
+ *  Xenon hardware related routines.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+
+static int __init xenon_hwmon_init(void)
+{
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("xenon-hwmon", -1, NULL, 0);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
+
+module_init(xenon_hwmon_init);
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/interrupt.c linux-3.5.4-xenon/arch/powerpc/platforms/xenon/interrupt.c
--- linux-3.5.4/arch/powerpc/platforms/xenon/interrupt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/interrupt.c	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,333 @@
+/*
+ * Xenon interrupt controller,
+ *
+ * Maintained by: Felix Domke <tmbinc@elitedvb.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License v2
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/percpu.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/irqdesc.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/prom.h>
+#include <asm/ptrace.h>
+#include <asm/machdep.h>
+
+#include "interrupt.h"
+
+static void *iic_base,
+	*bridge_base, // ea000000
+	*biu,         // e1000000
+	*graphics;    // ec800000
+static struct irq_domain *host;
+
+#define XENON_NR_IRQS 128
+
+#define PRIO_IPI_4       0x08
+#define PRIO_IPI_3       0x10
+#define PRIO_SMM         0x14
+#define PRIO_SFCX        0x18
+#define PRIO_SATA_HDD    0x20
+#define PRIO_SATA_CDROM  0x24
+#define PRIO_OHCI_0      0x2c
+#define PRIO_EHCI_0      0x30
+#define PRIO_OHCI_1      0x34
+#define PRIO_EHCI_1      0x38
+#define PRIO_XMA         0x40
+#define PRIO_AUDIO       0x44
+#define PRIO_ENET        0x4C
+#define PRIO_XPS         0x54
+#define PRIO_GRAPHICS    0x58
+#define PRIO_PROFILER    0x60
+#define PRIO_BIU         0x64
+#define PRIO_IOC         0x68
+#define PRIO_FSB         0x6c
+#define PRIO_IPI_2       0x70
+#define PRIO_CLOCK       0x74
+#define PRIO_IPI_1       0x78
+
+/* bridge (PCI) IRQ -> CPU IRQ */
+static int xenon_pci_irq_map[] = {
+		PRIO_CLOCK, PRIO_SATA_CDROM, PRIO_SATA_HDD, PRIO_SMM,
+		PRIO_OHCI_0, PRIO_EHCI_0, PRIO_OHCI_1, PRIO_EHCI_1,
+		-1, -1, PRIO_ENET, PRIO_XMA,
+		PRIO_AUDIO, PRIO_SFCX, -1, -1};
+
+static void disconnect_pci_irq(int prio)
+{
+	int i;
+
+	printk(KERN_DEBUG "xenon IIC: disconnect irq %i\n", prio);
+
+	for (i=0; i<0x10; ++i)
+		if (xenon_pci_irq_map[i] == prio)
+			writel(0, bridge_base + 0x10 + i * 4);
+}
+
+	/* connects an PCI IRQ to CPU #0 */
+static void connect_pci_irq(int prio)
+{
+	int i;
+
+	printk(KERN_WARNING "xenon IIC: connect irq %i\n", prio);
+
+	for (i=0; i<0x10; ++i)
+		if (xenon_pci_irq_map[i] == prio)
+			writel(0x0800180 | (xenon_pci_irq_map[i]/4), bridge_base + 0x10 + i * 4);
+}
+
+static void iic_mask(struct irq_data *d)
+{
+	disconnect_pci_irq(d->irq);
+}
+
+static void iic_unmask(struct irq_data *d)
+{
+	int i;
+	connect_pci_irq(d->irq);
+	for (i=0; i<6; ++i)
+		out_be64(iic_base + i * 0x1000 + 0x68, 0);
+}
+
+void xenon_init_irq_on_cpu(int cpu)
+{
+	printk(KERN_WARNING "xenon IIC: init on cpu %i\n", cpu);
+		/* init that cpu's interrupt controller */
+	out_be64(iic_base + cpu * 0x1000 + 0x70, 0x7c);
+	out_be64(iic_base + cpu * 0x1000 + 0x8, 0);      /* irql */
+	out_be64(iic_base + cpu * 0x1000, 1<<cpu);       /* "who am i" */
+
+		/* ack all outstanding interrupts */
+	while (in_be64(iic_base + cpu * 0x1000 + 0x50) != 0x7C);
+	out_be64(iic_base + cpu * 0x1000 + 0x68, 0);
+}
+
+static void iic_eoi(struct irq_data *d)
+{
+	int cpu = hard_smp_processor_id();
+	void *my_iic_base = iic_base + cpu * 0x1000;
+	out_be64(my_iic_base + 0x68, 0);
+	mb();
+	in_be64(my_iic_base + 0x8);
+}
+
+static struct irq_chip xenon_pic = {
+	.name = " XENON-PIC ",
+	.irq_mask = iic_mask,
+	.irq_unmask = iic_unmask,
+	.irq_eoi = iic_eoi,
+};
+
+//struct irq_desc irq_desc[XENON_NR_IRQS];
+
+/* Get an IRQ number from the pending state register of the IIC */
+static unsigned int iic_get_irq(void)
+{
+	int cpu = hard_smp_processor_id();
+	void *my_iic_base;
+	int index;
+
+	my_iic_base = iic_base + cpu * 0x1000;
+
+	index = in_be64(my_iic_base + 0x50) & 0x7F; /* read destructive pending interrupt */
+
+	out_be64(my_iic_base + 0x08, 0x7c); /* current task priority */
+	mb();
+	in_be64(my_iic_base + 0x8);
+
+		/* HACK: we will handle some (otherwise unhandled) interrupts here
+		   to prevent them flooding. */
+	switch (index) {
+	case PRIO_GRAPHICS:
+		writel(0, graphics + 0xed0);
+		writel(0, graphics + 0x6540);
+		break;
+	case PRIO_IOC:
+		writel(0, biu + 0x4002c);
+		break;
+	case PRIO_CLOCK:
+		writel(0, bridge_base + 0x106C);
+		break;
+	default:
+		break;
+	}
+
+#if 0
+	/* should be handled */
+	if (index == PRIO_IPI_1)
+		return index;
+	if (index == PRIO_IPI_2)
+		return index;
+	if (index == PRIO_IPI_3)
+		return index;
+	if (index == PRIO_IPI_4)
+		return index;
+#endif
+
+	/* HACK: we need to ACK unhandled interrupts here */
+	if (!irq_desc[index].action) {
+		printk(KERN_WARNING "IRQ 0x%02x unhandled, doing local EOI\n", index);
+		out_be64(my_iic_base + 0x60, 0);
+		iic_eoi(NULL);
+		return NO_IRQ;
+	}
+
+	if (index == 0x7C)
+		return NO_IRQ;
+	else
+		return index;
+}
+
+static int xenon_irq_host_map(struct irq_domain *h, unsigned int virq,
+				irq_hw_number_t hw)
+{
+	irq_set_chip_and_handler(virq, &xenon_pic, handle_percpu_irq);
+	return 0;
+}
+
+static int xenon_irq_host_match(struct irq_domain *h, struct device_node *node)
+{
+	return h->host_data != NULL && node == h->host_data;
+}
+
+static const struct irq_domain_ops xenon_irq_host_ops = {
+	.map = xenon_irq_host_map,
+	.match = xenon_irq_host_match,
+};
+
+void __init xenon_iic_init_IRQ(void)
+{
+	int i;
+	struct device_node *dn;
+	struct resource res;
+
+	printk(KERN_DEBUG "xenon IIC: init\n");
+
+			/* search for our interrupt controller inside the device tree */
+	for (dn = NULL;
+	     (dn = of_find_node_by_name(dn, "interrupt-controller")) != NULL;) {
+		if (!of_device_is_compatible(dn, "xenon"))
+			continue;
+
+		if (of_address_to_resource(dn, 0, &res))
+		{
+			printk(KERN_WARNING "xenon IIC: Can't resolve addresses\n");
+			of_node_put(dn);
+			return;
+		}
+
+		iic_base = ioremap_nocache(res.start, 0x10000);
+
+		//host = irq_alloc_host(NULL, IRQ_HOST_MAP_NOMAP, 0, &xenon_irq_host_ops, 0);
+		host = irq_domain_add_nomap(NULL, 0x80, &xenon_irq_host_ops, NULL);
+		host->host_data = of_node_get(dn);
+		BUG_ON(host == NULL);
+		irq_set_default_host(host);
+	}
+
+	ppc_md.get_irq = iic_get_irq;
+
+	bridge_base = ioremap_nocache(0xea000000, 0x10000);
+	biu = ioremap_nocache(0xe1000000, 0x2000000);
+	graphics = ioremap_nocache(0xec800000, 0x10000);
+
+		/* initialize interrupts */
+	writel(0, bridge_base);
+	writel(0x40000000, bridge_base + 4);
+
+	writel(0x40000000, biu + 0x40074);
+	writel(0xea000050, biu + 0x40078);
+
+	writel(0, bridge_base + 0xc);
+	writel(0x3, bridge_base);
+
+		/* disconnect all PCI IRQs until they are requested */
+	for (i=0; i<0x10; ++i)
+		writel(0, bridge_base + 0x10 + i * 4);
+
+	xenon_init_irq_on_cpu(0);
+}
+
+#ifdef CONFIG_SMP
+
+static int ipi_to_prio(int ipi)
+{
+	switch (ipi) {
+	case PPC_MSG_CALL_FUNCTION:
+		return PRIO_IPI_1;
+		break;
+	case PPC_MSG_CALL_FUNC_SINGLE:
+		return PRIO_IPI_2;
+		break;
+	case PPC_MSG_RESCHEDULE:
+		return PRIO_IPI_3;
+		break;
+	case PPC_MSG_DEBUGGER_BREAK:
+		return PRIO_IPI_4;
+		break;
+	default:
+		printk("unhandled ipi %d\n", ipi);
+		BUG();
+	}
+	return 0;
+}
+
+void xenon_cause_IPI(int target, int msg)
+{
+	int ipi_prio;
+
+	ipi_prio = ipi_to_prio(msg);
+
+	out_be64(iic_base + 0x10 + hard_smp_processor_id() * 0x1000, (0x10000<<target) | ipi_prio);
+}
+
+/*
+static irqreturn_t xenon_ipi_action(int irq, void *dev_id)
+{
+	int ipi = (int)(long)dev_id;
+	smp_request_message_ipi(irq, ipi);
+	return IRQ_HANDLED;
+}
+*/
+
+static void xenon_request_ipi(int ipi, const char *name)
+{
+	int prio = ipi_to_prio(ipi), virq;
+
+	virq = irq_create_mapping(host, prio);
+	if (virq == NO_IRQ)
+	{
+		printk(KERN_ERR
+				"xenon_request_ipi: failed to map IPI%d (%s)\n", prio, name);
+		return;
+	}
+
+	smp_request_message_ipi(virq, ipi);
+	/*
+	if (request_irq(prio, xenon_ipi_action, IRQF_DISABLED,
+			name, (void *)(long)ipi))
+		printk(KERN_ERR "request irq for ipi failed!\n");
+		*/
+}
+
+void xenon_request_IPIs(void)
+{
+	xenon_request_ipi(PPC_MSG_CALL_FUNCTION, "IPI-call");
+	xenon_request_ipi(PPC_MSG_RESCHEDULE, "IPI-resched");
+	xenon_request_ipi(PPC_MSG_CALL_FUNC_SINGLE, "IPI-call-single");
+#ifdef CONFIG_DEBUGGER
+	xenon_request_ipi(PPC_MSG_DEBUGGER_BREAK, "IPI-debug");
+#endif /* CONFIG_DEBUGGER */
+}
+
+#endif
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/interrupt.h linux-3.5.4-xenon/arch/powerpc/platforms/xenon/interrupt.h
--- linux-3.5.4/arch/powerpc/platforms/xenon/interrupt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/interrupt.h	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,10 @@
+#ifndef XENON_INTERRUPT_H
+#define XENON_INTERRUPT_H
+
+extern void xenon_init_irq_on_cpu(int cpu);
+extern void __init xenon_iic_init_IRQ(void);
+extern void xenon_cause_IPI(int target, int msg);
+extern void xenon_request_IPIs(void);
+
+#endif /* ASM_XENON_PIC_H */
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/Kconfig linux-3.5.4-xenon/arch/powerpc/platforms/xenon/Kconfig
--- linux-3.5.4/arch/powerpc/platforms/xenon/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/Kconfig	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,8 @@
+config PPC_XENON
+	bool "Xenon"
+	depends on PPC64
+	select PPC_NATIVE
+	default y
+	help
+	  This option enables support for the Xbox 360 game console
+	  without a hypervisor.
\ Kein Zeilenumbruch am Dateiende.
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/Makefile linux-3.5.4-xenon/arch/powerpc/platforms/xenon/Makefile
--- linux-3.5.4/arch/powerpc/platforms/xenon/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/Makefile	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,3 @@
+obj-y += setup.o interrupt.o pci.o time.o hardware.o
+
+obj-$(CONFIG_SMP) += smp.o
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/pci.c linux-3.5.4-xenon/arch/powerpc/platforms/xenon/pci.c
--- linux-3.5.4/arch/powerpc/platforms/xenon/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/pci.c	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,313 @@
+/*
+ * Xenon PCI support
+ * Maintained by: Felix Domke <tmbinc@elitedvb.net>
+ * Minor modification by: wolie <wolie@telia.com>
+ * based on:
+ * Copyright (C) 2004 Benjamin Herrenschmuidt (benh@kernel.crashing.org),
+ *		      IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+
+#include <asm/sections.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/machdep.h>
+#include <asm/iommu.h>
+#include <asm/ppc-pci.h>
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+#define OFFSET(bus, slot, func)	\
+	((((bus) << 8) + PCI_DEVFN(slot, func)) << 12)
+
+static int xenon_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+			      int offset, int len, u32 *val)
+{
+	struct pci_controller *hose;
+	unsigned int slot = PCI_SLOT(devfn);
+	unsigned int func = PCI_FUNC(devfn);
+	void* addr;
+
+	hose = pci_bus_to_host(bus);
+	if (hose == NULL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	DBG("xenon_pci_read_config, slot %d, func %d\n", slot, func);
+
+#if 0
+	if (PCI_SLOT(devfn) >= 32)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_SLOT(devfn) == 3)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_SLOT(devfn) == 6)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_SLOT(devfn) == 0xB)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_FUNC(devfn) >= 2)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+#endif
+	DBG("xenon_pci_read_config, %p, devfn=%d, offset=%d, len=%d\n", bus, devfn, offset, len);
+
+	addr = ((void*)hose->cfg_addr) + offset;
+
+	/* map GPU to slot 0x0f */
+	if (slot == 0x0f)
+		addr += OFFSET(0, 0x02, func);
+	else
+		addr += OFFSET(1, slot, func);
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		*val = in_8((u8 *)addr);
+		break;
+	case 2:
+		*val = in_le16((u16 *)addr);
+		break;
+	default:
+		*val = in_le32((u32 *)addr);
+		break;
+	}
+	DBG("->%08x\n", (int)*val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int xenon_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+			       int offset, int len, u32 val)
+{
+	struct pci_controller *hose;
+	unsigned int slot = PCI_SLOT(devfn);
+	unsigned int func = PCI_FUNC(devfn);
+	void *addr;
+
+	hose = pci_bus_to_host(bus);
+	if (hose == NULL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	DBG("xenon_pci_write_config, slot %d, func %d\n", slot, func);
+
+	if (PCI_SLOT(devfn) >= 32)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+#if 0
+	if (PCI_SLOT(devfn) == 3)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+#endif
+	DBG("xenon_pci_write_config, %p, devfn=%d, offset=%x, len=%d, val=%08x\n", bus, devfn, offset, len, val);
+
+	addr = ((void*)hose->cfg_addr) + offset;
+
+	/* map GPU to slot 0x0f */
+	if (slot == 0x0f)
+		addr += OFFSET(0, 0x02, func);
+	else
+		addr += OFFSET(1, slot, func);
+
+	if (len == 4)
+		DBG("was: %08x\n", readl(addr));
+	if (len == 2)
+		DBG("was: %04x\n", readw(addr));
+	if (len == 1)
+		DBG("was: %02x\n", readb(addr));
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		writeb(val, addr);
+		break;
+	case 2:
+		writew(val, addr);
+		break;
+	default:
+		writel(val, addr);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops xenon_pci_ops =
+{
+	.read	= xenon_pci_read_config,
+	.write	= xenon_pci_write_config,
+};
+
+
+#if 1
+void __init xenon_pci_init(void)
+{
+	struct pci_controller *hose;
+	struct device_node *np, *root;
+	struct device_node *dev = NULL;
+
+	root = of_find_node_by_path("/");
+	if (root == NULL) {
+		printk(KERN_CRIT "xenon_pci_init: can't find root of device tree\n");
+		return;
+	}
+	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;) {
+		if (np->name == NULL)
+			continue;
+		// printk("found node %p %s\n", np, np->name);
+		if (strcmp(np->name, "pci") == 0) {
+			of_node_get(np);
+			dev = np;
+		}
+	}
+	of_node_put(root);
+
+	if (!dev)
+	{
+		printk("couldn't find PCI node!\n");
+		return;
+	}
+
+	hose = pcibios_alloc_controller(dev);
+	if (hose == NULL)
+	{
+		printk("pcibios_alloc_controller failed!\n");
+		return;
+	}
+
+	hose->first_busno = 0;
+	hose->last_busno = 1;
+
+	hose->ops = &xenon_pci_ops;
+	hose->cfg_addr = ioremap(0xd0000000, 0x1000000);
+
+	pci_process_bridge_OF_ranges(hose, dev, 1);
+
+	/* Setup the linkage between OF nodes and PHBs */
+	pci_devs_phb_init();
+
+//	of_rescan_bus(root, ci_bus *bus)
+
+	/* Tell pci.c to not change any resource allocations.  */
+	pci_set_flags(PCI_PROBE_ONLY);
+
+	of_node_put(dev);
+	DBG("PCI initialized\n");
+
+	pci_io_base = 0;
+
+	// pcibios_scan_phb(hose, dev);
+
+	ppc_md.pci_dma_dev_setup = NULL;
+	ppc_md.pci_dma_bus_setup = NULL;
+	set_pci_dma_ops(&dma_direct_ops);
+}
+
+#else
+
+
+static int __init xenon_add_bridge(struct device_node *dev)
+{
+	int len;
+	struct pci_controller *hose;
+	struct resource rsrc;
+	char *disp_name;
+	const int *bus_range;
+	int primary = 1, has_address = 0;
+
+	printk(KERN_DEBUG "Adding PCI host bridge %s\n", dev->full_name);
+
+	/* Fetch host bridge registers address */
+	has_address = (of_address_to_resource(dev, 0, &rsrc) == 0);
+
+	/* Get bus range if any */
+	bus_range = of_get_property(dev, "bus-range", &len);
+	if (bus_range == NULL || len < 2 * sizeof(int)) {
+		printk(KERN_WARNING "Can't get bus-range for %s, assume"
+		       " bus 0\n", dev->full_name);
+	}
+
+	hose = pcibios_alloc_controller(dev);
+	if (!hose)
+		return -ENOMEM;
+	hose->first_busno = bus_range ? bus_range[0] : 0;
+	hose->last_busno = bus_range ? bus_range[1] : 0xff;
+
+	hose->ops = &xenon_pci_ops;
+
+	/* FIXME: should come from config */
+	hose->cfg_addr = ioremap(0xd0000000, 0x1000000);
+
+	disp_name = NULL;
+
+	printk(KERN_INFO "Found %s PCI host bridge at 0x%016llx. "
+	       "Firmware bus number: %d->%d\n",
+		disp_name, (unsigned long long)rsrc.start, hose->first_busno,
+		hose->last_busno);
+
+	printk(KERN_DEBUG " ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",
+		hose, hose->cfg_addr, hose->cfg_data);
+
+	/* Interpret the "ranges" property */
+	/* This also maps the I/O region and sets isa_io/mem_base */
+	pci_process_bridge_OF_ranges(hose, dev, primary);
+
+	/* Fixup "bus-range" OF property */
+	// fixup_bus_range(dev);
+
+	return 0;
+}
+
+void __init xenon_pci_init(void)
+{
+	struct device_node *np, *root;
+
+	ppc_pci_set_flags(PPC_PCI_CAN_SKIP_ISA_ALIGN);
+
+	root = of_find_node_by_path("/");
+	if (root == NULL) {
+		printk(KERN_CRIT "xenon_pci_init: can't find root "
+		       "of device tree\n");
+		return;
+	}
+	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;) {
+		if (np->name == NULL)
+			continue;
+		if (strcmp(np->name, "pci") == 0) {
+			if (xenon_add_bridge(np) == 0)
+				of_node_get(np);
+		}
+	}
+	of_node_put(root);
+
+	/* Setup the linkage between OF nodes and PHBs */
+	pci_devs_phb_init();
+
+
+	/* We can allocate missing resources if any */
+	pci_probe_only = 0;
+	pci_probe_only = 1;
+
+	/* do we need that? */
+	pci_io_base = 0;
+
+	/* do we need that? */
+	ppc_md.pci_dma_dev_setup = NULL;
+	ppc_md.pci_dma_bus_setup = NULL;
+	set_pci_dma_ops(&dma_direct_ops);
+}
+
+#endif
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/pci.h linux-3.5.4-xenon/arch/powerpc/platforms/xenon/pci.h
--- linux-3.5.4/arch/powerpc/platforms/xenon/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/pci.h	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,7 @@
+#ifndef XENON_PCI_H
+#define XENON_PCI_H
+
+extern void __init xenon_pci_init(void);
+
+#endif
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/setup.c linux-3.5.4-xenon/arch/powerpc/platforms/xenon/setup.c
--- linux-3.5.4/arch/powerpc/platforms/xenon/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/setup.c	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,150 @@
+/*
+ *  linux/arch/powerpc/platforms/xenon/xenon_setup.c
+ *
+ *  Maintained by: Felix Domke <tmbinc@elitedvb.net>
+ *  Minor modification by: wolie <wolie@telia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/root_dev.h>
+#include <linux/console.h>
+#include <linux/kexec.h>
+
+#include <asm/mmu-hash64.h>
+
+#include <asm/mmu.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/ppc-pci.h>
+#include "interrupt.h"
+#include "pci.h"
+#include "smp.h"
+
+static void xenon_show_cpuinfo(struct seq_file *m)
+{
+	struct device_node *root;
+	const char *model = "";
+
+	root = of_find_node_by_path("/");
+	if (root)
+		model = of_get_property(root, "model", NULL);
+	seq_printf(m, "machine\t\t: %s\n", model);
+	of_node_put(root);
+}
+
+static void __init xenon_init_irq(void)
+{
+	xenon_iic_init_IRQ();
+}
+
+static void __init xenon_setup_arch(void)
+{
+#ifdef CONFIG_SMP
+	smp_init_xenon();
+#endif
+		/* init to some ~sane value until calibrate_delay() runs */
+	loops_per_jiffy = 50000000;
+
+	if (ROOT_DEV == 0)
+		ROOT_DEV = Root_SDA1;
+
+	xenon_pci_init();
+#ifdef CONFIG_DUMMY_CONSOLE
+	conswitchp = &dummy_con;
+#endif
+}
+
+static int __init xenon_probe(void)
+{
+	unsigned long root = of_get_flat_dt_root();
+
+	if (!of_flat_dt_is_compatible(root, "XENON"))
+		return 0;
+
+	hpte_init_native();
+
+	return 1;
+}
+
+static void xenon_panic(char *str)
+{
+	smp_send_stop();
+	printk("\n");
+	printk("   System does not reboot automatically.\n");
+	printk("   Please press POWER button.\n");
+	printk("\n");
+
+	local_irq_disable();
+	while (1) ;
+}
+
+void xenon_smc_restart(char *cmd);
+
+static void xenon_restart(char *cmd)
+{
+	printk("   System restart ... \n");
+
+	smp_send_stop();
+	xenon_smc_restart(cmd);
+
+	local_irq_disable();
+	while (1) ;
+}
+
+void xenon_smc_power_off(void);
+
+static void xenon_power_off(void)
+{
+	printk("   System power off ... \n");
+
+	smp_send_stop();
+	xenon_smc_power_off();
+
+	local_irq_disable();
+	while (1) ;
+}
+
+void xenon_smc_halt(void);
+
+static void xenon_halt(void)
+{
+	printk("   System halt ... \n");
+
+	smp_send_stop();
+	xenon_smc_halt();
+
+	local_irq_disable();
+	while (1) ;
+}
+
+#if 0
+static int xenon_check_legacy_ioport(unsigned int baseport)
+{
+	return -ENODEV;
+}
+#endif
+
+define_machine(xenon) {
+	.name			= "Xenon",
+	.probe			= xenon_probe,
+	.setup_arch		= xenon_setup_arch,
+	.show_cpuinfo		= xenon_show_cpuinfo,
+	.calibrate_decr		= generic_calibrate_decr,
+	.init_IRQ       	= xenon_init_irq,
+	.panic			= xenon_panic,
+	.restart		= xenon_restart,
+	.power_off		= xenon_power_off,
+	.halt			= xenon_halt,
+#if 0 && defined(CONFIG_KEXEC)
+	.machine_kexec		= default_machine_kexec,
+	.machine_kexec_prepare	= default_machine_kexec_prepare,
+	.machine_crash_shutdown	= default_machine_crash_shutdown,
+#endif
+};
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/smp.c linux-3.5.4-xenon/arch/powerpc/platforms/xenon/smp.c
--- linux-3.5.4/arch/powerpc/platforms/xenon/smp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/smp.c	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,97 @@
+/*
+ * SMP support for Xenon machines.
+ *
+ * Based on CBE's smp.c.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/cpu.h>
+#include <linux/module.h>
+#include <asm/machdep.h>
+#include "interrupt.h"
+
+static int __init smp_xenon_probe(void)
+{
+	xenon_request_IPIs();
+
+	return cpus_weight(CPU_MASK_ALL);
+}
+
+static void __devinit smp_xenon_setup_cpu(int cpu)
+{
+	if (cpu != boot_cpuid)
+		xenon_init_irq_on_cpu(cpu);
+}
+
+static int __devinit smp_xenon_kick_cpu(int nr)
+{
+	BUG_ON(nr < 0 || nr >= NR_CPUS);
+
+	pr_debug("smp_xenon_kick_cpu %d\n", nr);
+
+	/*
+	 * The processor is currently spinning, waiting for the
+	 * cpu_start field to become non-zero After we set cpu_start,
+	 * the processor will continue on to secondary_start
+	 */
+	paca[nr].cpu_start = 1;
+
+	return 0;
+}
+
+static int smp_xenon_cpu_bootable(unsigned int nr)
+{
+	/* Special case - we inhibit secondary thread startup
+	 * during boot if the user requests it.  Odd-numbered
+	 * cpus are assumed to be secondary threads.
+	 */
+	if (system_state < SYSTEM_RUNNING &&
+	    cpu_has_feature(CPU_FTR_SMT) &&
+	    !smt_enabled_at_boot && nr % 2 != 0)
+		return 0;
+
+	return 1;
+}
+
+extern void xenon_cause_IPI(int target, int msg);
+
+static void smp_xenon_message_pass(int target, int msg)
+{
+	unsigned int i;
+
+	if (target < NR_CPUS) {
+		xenon_cause_IPI(target, msg);
+	} else {
+		for_each_online_cpu(i) {
+			/*
+			if (target == MSG_ALL_BUT_SELF
+			    && i == smp_processor_id())
+				continue;
+			*/
+			xenon_cause_IPI(i, msg);
+		}
+	}
+}
+
+static struct smp_ops_t xenon_smp_ops = {
+	.message_pass	= smp_xenon_message_pass,
+	.probe		= smp_xenon_probe,
+	.kick_cpu	= smp_xenon_kick_cpu,
+	.setup_cpu	= smp_xenon_setup_cpu,
+	.cpu_bootable	= smp_xenon_cpu_bootable,
+};
+
+/* This is called very early */
+void __init smp_init_xenon(void)
+{
+	pr_debug(" -> smp_init_xenon()\n");
+
+	smp_ops = &xenon_smp_ops;
+
+	pr_debug(" <- smp_init_xenon()\n");
+}
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/smp.h linux-3.5.4-xenon/arch/powerpc/platforms/xenon/smp.h
--- linux-3.5.4/arch/powerpc/platforms/xenon/smp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/smp.h	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,9 @@
+#ifndef XENON_SMP_H
+#define XENON_SMP_H
+
+#ifdef CONFIG_SMP
+extern void smp_init_xenon(void);
+#endif
+
+#endif
+
diff -NurpP --minimal linux-3.5.4/arch/powerpc/platforms/xenon/time.c linux-3.5.4-xenon/arch/powerpc/platforms/xenon/time.c
--- linux-3.5.4/arch/powerpc/platforms/xenon/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/arch/powerpc/platforms/xenon/time.c	2012-10-08 18:39:07.933017787 +0200
@@ -0,0 +1,37 @@
+/*
+ *  Xenon time and rtc routines.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <asm/rtc.h>
+
+static int __init xenon_rtc_init(void)
+{
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("rtc-xenon", -1, NULL, 0);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
+
+module_init(xenon_rtc_init);
+
diff -NurpP --minimal linux-3.5.4/drivers/ata/Kconfig linux-3.5.4-xenon/drivers/ata/Kconfig
--- linux-3.5.4/drivers/ata/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/ata/Kconfig	2012-10-08 18:39:07.933017787 +0200
@@ -267,6 +267,14 @@ config SATA_SVW
 
 	  If unsure, say N.
 
+config SATA_XENON
+	tristate "Xenon SATA support"
+	depends on PCI
+	help
+	  This option enables support for Xenon southbridge.
+
+	  If unsure, say N.
+
 config SATA_ULI
 	tristate "ULi Electronics SATA support"
 	depends on PCI
diff -NurpP --minimal linux-3.5.4/drivers/ata/libata-core.c linux-3.5.4-xenon/drivers/ata/libata-core.c
--- linux-3.5.4/drivers/ata/libata-core.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/ata/libata-core.c	2012-10-08 18:39:07.941017822 +0200
@@ -1900,7 +1900,7 @@ retry:
 	/* Device presence detection is unreliable on some
 	 * controllers.  Always poll IDENTIFY if available.
 	 */
-	tf.flags |= ATA_TFLAG_POLLING;
+//	tf.flags |= ATA_TFLAG_POLLING;
 
 	if (ap->ops->read_id)
 		err_mask = ap->ops->read_id(dev, &tf, id);
diff -NurpP --minimal linux-3.5.4/drivers/ata/Makefile linux-3.5.4-xenon/drivers/ata/Makefile
--- linux-3.5.4/drivers/ata/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/ata/Makefile	2012-10-08 18:39:07.941017822 +0200
@@ -9,6 +9,7 @@ obj-$(CONFIG_SATA_FSL)		+= sata_fsl.o
 obj-$(CONFIG_SATA_INIC162X)	+= sata_inic162x.o
 obj-$(CONFIG_SATA_SIL24)	+= sata_sil24.o
 obj-$(CONFIG_SATA_DWC)		+= sata_dwc_460ex.o
+obj-$(CONFIG_SATA_XENON)	+= sata_xenon.o
 
 # SFF w/ custom DMA
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
@@ -106,3 +107,4 @@ libata-y	:= libata-core.o libata-scsi.o
 libata-$(CONFIG_ATA_SFF)	+= libata-sff.o
 libata-$(CONFIG_SATA_PMP)	+= libata-pmp.o
 libata-$(CONFIG_ATA_ACPI)	+= libata-acpi.o
+
diff -NurpP --minimal linux-3.5.4/drivers/ata/sata_xenon.c linux-3.5.4-xenon/drivers/ata/sata_xenon.c
--- linux-3.5.4/drivers/ata/sata_xenon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/ata/sata_xenon.c	2012-10-08 18:39:07.941017822 +0200
@@ -0,0 +1,256 @@
+/*
+ *  sata_xenon.c - SATA support for xenon southbridge
+ *
+ *  based on sata_sis.c, modifications by Felix Domke <tmbinc@elitedvb.net>
+ *  minor modification by: wolie <wolie@telia.com>
+ *
+ *  		    Please ALWAYS copy linux-ide@vger.kernel.org
+ *		    on emails.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+
+#define DRV_NAME	"sata_xenon"
+#define DRV_VERSION	"0.1.1"
+
+	/* small note: it's completely unknown whether the xenon southbridge sata
+	   is really based on SiS technology.
+	   Most of SATA is standardized anyway.
+
+
+	   So, we have these two pci devices, one for each port.
+
+	   They have two BARs, one for the IDE registers (0..7,
+	   altstatus/devctl is +0xA), and one for the BMDMA.
+
+	   SCR seem to be sis-like in pci config space, but that should
+	   be verified!
+
+	   Note on the DVD-ROM part:
+
+	   The drives usually require some tweaks to be usable under linux.
+
+	   You either need to hack the scsi layer, or, in case of the GDR3120L,
+	   set 'modeB' in the bootloader.
+	*/
+
+enum {
+	/* PCI configuration registers */
+	SIS_SCR_BASE		= 0xc0, /* sata0 phy SCR registers */
+};
+
+static int xenon_init_one (struct pci_dev *pdev, const struct pci_device_id *ent);
+static int xenon_scr_read (struct ata_link *link, unsigned int sc_reg, u32 *val);
+static int xenon_scr_write (struct ata_link *link, unsigned int sc_reg, u32 val);//void
+static void xenon_bmdma_error_handler(struct ata_port *ap);
+
+static const struct pci_device_id xenon_pci_tbl[] = {
+	{ PCI_VDEVICE(MICROSOFT, 0x5803), 0 },
+	{ PCI_VDEVICE(MICROSOFT, 0x5802), 0 },
+
+	{ }	/* terminate list */
+};
+
+static struct pci_driver xenon_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= xenon_pci_tbl,
+	.probe			= xenon_init_one,
+	.remove			= ata_pci_remove_one,
+};
+
+static struct scsi_host_template xenon_sht = {
+	ATA_BMDMA_SHT(DRV_NAME),
+};
+
+static struct ata_port_operations xenon_ops = {
+	.inherits		= &ata_bmdma_port_ops,
+// 	.lost_interrupt		= ATA_OP_NULL,
+	.error_handler		= xenon_bmdma_error_handler,
+	.scr_read		= xenon_scr_read,
+	.scr_write		= xenon_scr_write,
+};
+
+static const struct ata_port_info xenon_port_info = {
+	.flags		= ATA_FLAG_SATA,
+	.pio_mask	= ATA_PIO4,
+	.mwdma_mask	= ATA_MWDMA2,
+	.udma_mask	= ATA_UDMA6, //0x7F
+	.port_ops	= &xenon_ops,
+//	.irq_handler	= ata_interrupt,
+//	.private_data   = NULL
+};
+
+
+
+MODULE_DESCRIPTION("low-level driver for Xenon Southbridge SATA controller");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, xenon_pci_tbl);
+MODULE_VERSION(DRV_VERSION);
+
+static unsigned int get_scr_cfg_addr(unsigned int sc_reg)
+{
+	if ((sc_reg > SCR_CONTROL) || (sc_reg == SCR_ERROR)) /* doesn't exist in PCI cfg space */
+		return -1;
+
+	return SIS_SCR_BASE + (4 * sc_reg);
+
+}
+
+static int xenon_scr_read (struct ata_link *link, unsigned int sc_reg, u32 *val) //u32
+{
+	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
+	unsigned int cfg_addr;
+	u32 val2;
+
+	cfg_addr = get_scr_cfg_addr(sc_reg);
+
+	if (cfg_addr == -1)
+		return 0; /* assume no error */
+
+	pci_read_config_dword(pdev, cfg_addr, &val2);
+
+	*val = val2;
+	return 0;
+}
+
+static int xenon_scr_write (struct ata_link *link, unsigned int sc_reg, u32 val) //void
+{
+	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
+	unsigned int cfg_addr;
+
+	cfg_addr = get_scr_cfg_addr(sc_reg);
+
+	if (cfg_addr == -1)
+		return -EINVAL;
+
+	pci_write_config_dword(pdev, cfg_addr, val);
+	return 0;
+}
+
+static int xenon_softreset(struct ata_link *link, unsigned int *classes, unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
+		/* Host 0 (used for DVD-ROM) has a quirk when used with
+		   an Toshiba/Samsung drive: It can hang after a device reset.
+
+		   While the exact reason is unclear (anyone with a SATA port
+		   analyzer?), this workaround will not let the reset happen, and
+		   emulate the detection of an ATAPI device.
+
+		   When the workaround is enabled, only ATAPI devices are supported
+		   on host 0, but on this hardware, nothing else is possible anyway. */
+	if (pdev->device == 0x5802)
+	{
+		classes[0] = ATA_DEV_ATAPI;
+		classes[1] = ATA_DEV_NONE;
+		return 0;
+	} else
+		return ata_sff_softreset(link, classes, 150);
+}
+
+static void xenon_bmdma_error_handler(struct ata_port *ap)
+{
+	ata_do_eh(ap, ata_std_prereset, xenon_softreset, sata_std_hardreset, ata_std_postreset);
+}
+
+
+static int xenon_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	static int printed_version;
+	struct ata_host *host;
+	struct ata_ioports *ioaddr;
+	struct ata_port_info pi = xenon_port_info;
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	int rc;
+	int pci_dev_busy = 0;
+
+	if (!printed_version++)
+		dev_printk(KERN_INFO, &pdev->dev, "version " DRV_VERSION "\n");
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc) {
+		pci_dev_busy = 1;
+		goto err_out;
+	}
+
+	rc = pci_set_dma_mask(pdev, ATA_DMA_MASK);
+	if (rc)
+		goto err_out_regions;
+
+	rc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);
+	if (rc)
+		goto err_out_regions;
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 1);
+	if (!host)
+		return -ENOMEM;
+
+	ioaddr = &host->ports[0]->ioaddr;
+	ioaddr->cmd_addr = ioremap(pci_resource_start(pdev, 0), PAGE_SIZE);
+	ioaddr->altstatus_addr = ioaddr->cmd_addr + 0xa;
+	ioaddr->ctl_addr = ioaddr->cmd_addr + 0xa;
+	ioaddr->bmdma_addr = ioremap(pci_resource_start(pdev, 1), PAGE_SIZE);
+
+	ata_sff_std_ports(ioaddr);
+
+	pci_set_master(pdev);
+	pci_intx(pdev, 1);
+
+	return ata_host_activate(host, pdev->irq, ata_sff_interrupt,
+				 IRQF_SHARED, &xenon_sht);
+
+err_out_regions:
+	pci_release_regions(pdev);
+
+err_out:
+	if (!pci_dev_busy)
+		pci_disable_device(pdev);
+	return rc;
+}
+
+static int __init xenon_init(void)
+{
+	return pci_register_driver(&xenon_pci_driver);
+}
+
+static void __exit xenon_exit(void)
+{
+	pci_unregister_driver(&xenon_pci_driver);
+}
+
+module_init(xenon_init);
+module_exit(xenon_exit);
+
diff -NurpP --minimal linux-3.5.4/drivers/char/Kconfig linux-3.5.4-xenon/drivers/char/Kconfig
--- linux-3.5.4/drivers/char/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/char/Kconfig	2012-10-08 18:39:07.941017822 +0200
@@ -15,6 +15,26 @@ config DEVKMEM
 	  kind of kernel debugging operations.
 	  When in doubt, say "N".
 
+config XENON_SMC
+	tristate "Xenon System Management Controller (SMC)"
+	depends on PPC_XENON
+	help
+	  Character interface to the System Management controller in the
+	  Xbox 360. Allows to send arbitrary SMC commands and receive
+	  SMC replies.
+
+config XENON_ANA
+	tristate "Xenon (H)ana Character Device"
+	depends on PPC_XENON
+	help
+	  Character interface to the (H)ana chip on the Xbox 360.
+
+config XENON_PROBE
+	tristate "Xenon Memory Probe Device"
+	depends on PPC_XENON && EXPERIMENTAL
+	help
+	  Character interface to do memory probing on the Xbox 360.
+
 config STALDRV
 	bool "Stallion multiport serial support"
 	depends on SERIAL_NONSTANDARD
diff -NurpP --minimal linux-3.5.4/drivers/char/Makefile linux-3.5.4-xenon/drivers/char/Makefile
--- linux-3.5.4/drivers/char/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/char/Makefile	2012-10-08 18:39:07.941017822 +0200
@@ -17,6 +17,9 @@ obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_IBM_BSR)		+= bsr.o
 obj-$(CONFIG_SGI_MBCS)		+= mbcs.o
 obj-$(CONFIG_BFIN_OTP)		+= bfin-otp.o
+obj-$(CONFIG_XENON_SMC)  	+= xenon_smc.o
+obj-$(CONFIG_XENON_ANA)  	+= xenon_ana.o
+obj-$(CONFIG_XENON_PROBE)  	+= xenon_probe.o
 
 obj-$(CONFIG_PRINTER)		+= lp.o
 
diff -NurpP --minimal linux-3.5.4/drivers/char/xenon_ana.c linux-3.5.4-xenon/drivers/char/xenon_ana.c
--- linux-3.5.4/drivers/char/xenon_ana.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/char/xenon_ana.c	2012-10-08 18:39:07.941017822 +0200
@@ -0,0 +1,210 @@
+/*
+ *  Xenon (H)ana via SMC character driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+#define DRV_NAME	"xenon_ana"
+#define DRV_VERSION	"0.2"
+
+
+int xenon_smc_message_wait(void *msg);
+
+static uint32_t ana_read_reg(uint8_t addr)
+{
+	unsigned char msg[16] = { 0x11,
+		0x10, 0x05, 0x80 | 0x70, 0x00, 0xF0, addr };
+
+	xenon_smc_message_wait(msg);
+	return msg[4] | (msg[5] << 8) | (msg[6] << 16) | (msg[7] << 24);
+}
+
+static int ana_write_reg(uint8_t addr, uint32_t val)
+{
+	unsigned char msg[16] = { 0x11,
+		0x60, 0x00, 0x80 | 0x70, 0x00, 0x00,
+		addr, 0x00, val & 0xFF, (val >> 8) & 0xFF,
+		(val >> 16) & 0xFF, (val >> 24) & 0xFF };
+
+	xenon_smc_message_wait(msg);
+	return msg[1];
+}
+
+static loff_t ana_llseek(struct file *file, loff_t offset, int origin)
+{
+	switch (origin) {
+	case 1:
+		offset += file->f_pos;
+		break;
+	case 2:
+		offset += 0x400;
+		break;
+	}
+	if (offset < 0)
+		return -EINVAL;
+
+	file->f_pos = offset;
+	return file->f_pos;
+}
+
+typedef union {
+	uint32_t val;
+	uint8_t p[4];
+} 	ana_reg_t;
+
+static ssize_t ana_read(struct file *file, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= 0x400UL)
+		return -EINVAL;
+
+	while (count) {
+		/* optimize reads in same reg */
+		int addr = ppa/4;
+		int shift = ppa % 4;
+		ana_reg_t r = { .val = ana_read_reg(addr) };
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, &r.p[shift], len))
+			return -EFAULT;
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= 0x400)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static ssize_t ana_write(struct file *file, const char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= 0x400UL)
+		return -EINVAL;
+
+	while (count) {
+		/* coalesce writes to same reg */
+		int addr = ppa/4;
+		int shift = ppa % 4;
+		ana_reg_t r;
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+
+		/* handle partial write */
+		if (len != 4)
+			r.val = ana_read_reg(addr);
+
+		if (copy_from_user(&r.p[shift], buf, len))
+			return -EFAULT;
+
+		/* FIXME: handle return code */
+		ana_write_reg(addr, r.val);
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= 0x400)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static long ana_ioctl(struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int ana_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int ana_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+const struct file_operations ana_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= ana_llseek,
+	.read		= ana_read,
+	.write		= ana_write,
+	.unlocked_ioctl	= ana_ioctl,
+	.open		= ana_open,
+	.release	= ana_release,
+};
+
+static struct miscdevice ana_dev = {
+	.minor =  MISC_DYNAMIC_MINOR,
+	"ana",
+	&ana_fops
+};
+
+int __init ana_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Xenon (H)ana char driver version " DRV_VERSION "\n");
+
+	ret = misc_register(&ana_dev);
+	return ret;
+}
+
+void __exit ana_exit(void)
+{
+	misc_deregister(&ana_dev);
+}
+
+module_init(ana_init);
+module_exit(ana_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Character Interface for Xenon (H)ana");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
diff -NurpP --minimal linux-3.5.4/drivers/char/xenon_probe.c linux-3.5.4-xenon/drivers/char/xenon_probe.c
--- linux-3.5.4/drivers/char/xenon_probe.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/char/xenon_probe.c	2012-10-08 18:39:07.945017839 +0200
@@ -0,0 +1,229 @@
+/*
+ *  Xenon Memory Probe character driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#define DRV_NAME	"xenon_probe"
+#define DRV_VERSION	"0.1"
+
+static unsigned long base = 0xc8000000;
+static unsigned long size = 0x10000;
+static bool little_endian = 0;
+
+module_param(base, ulong, 0);
+MODULE_PARM_DESC(base, "Probe Memory Base");
+
+module_param(size, ulong, 0);
+MODULE_PARM_DESC(size, "Probe Memory Size");
+
+module_param(little_endian, bool, 0);
+MODULE_PARM_DESC(little_endian, "Probe Memory Endianess");
+
+static void __iomem *mapped = NULL;
+
+
+static uint32_t probe_map(uint32_t val)
+{
+	if (little_endian)
+		return le32_to_cpu(val);
+	else
+		return be32_to_cpu(val);
+}
+
+static uint32_t probe_rmap(uint32_t val)
+{
+	if (little_endian)
+		return cpu_to_le32(val);
+	else
+		return cpu_to_be32(val);
+}
+
+
+static loff_t probe_llseek(struct file *file, loff_t offset, int origin)
+{
+	switch (origin) {
+	case 1:
+		offset += file->f_pos;
+		break;
+	case 2:
+		offset += size;
+		break;
+	}
+	if ((offset < 0) || (offset >= size))
+		return -EINVAL;
+
+	file->f_pos = offset;
+	return file->f_pos;
+}
+
+typedef union {
+	uint32_t val;
+	uint8_t p[4];
+} 	probe_mem_t;
+
+static ssize_t probe_read(struct file *file,
+	char __user *buf, size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= size)
+		return -EINVAL;
+
+	printk("probe_read(%x,%zx)\n", ppa, count);
+	while (count) {
+		/* optimize reads in same longword */
+		unsigned long addr = ppa & ~3;
+		int shift = ppa % 4;
+		probe_mem_t r = { .val = probe_map(readl(mapped + addr)) };
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, &r.p[shift], len))
+			return -EFAULT;
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= size)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static ssize_t probe_write(struct file *file,
+	const char __user *buf, size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= size)
+		return -EINVAL;
+
+	printk("probe_write(%x,%zx)\n", ppa, count);
+	while (count) {
+		/* coalesce writes to same reg */
+		unsigned long addr = ppa & ~3;
+		int shift = ppa % 4;
+		probe_mem_t r;
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+
+		/* handle partial write */
+		if (len != 4)
+			r.val = probe_map(readl(mapped + addr));
+
+		if (copy_from_user(&r.p[shift], buf, len))
+			return -EFAULT;
+
+		writel(probe_rmap(r.val), mapped + addr);
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= size)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static long probe_ioctl(struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int probe_open(struct inode *inode, struct file *file)
+{
+	return generic_file_open(inode, file);
+}
+
+static int probe_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+const struct file_operations probe_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= probe_llseek,
+	.read		= probe_read,
+	.write		= probe_write,
+	.unlocked_ioctl	= probe_ioctl,
+	.open		= probe_open,
+	.release	= probe_release,
+};
+
+static struct miscdevice probe_dev = {
+	.minor =  MISC_DYNAMIC_MINOR,
+	"probe",
+	&probe_fops
+};
+
+int __init probe_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Xenon Memory Probe driver version " DRV_VERSION "\n");
+
+	mapped = ioremap(base, size);
+	if (!mapped)
+		return -EINVAL;
+
+	printk(KERN_INFO "XMP mapped 0x%04lx bytes @0x%08lx\n",
+		size, base);
+
+	ret = misc_register(&probe_dev);
+	return ret;
+}
+
+void __exit probe_exit(void)
+{
+	misc_deregister(&probe_dev);
+}
+
+module_init(probe_init);
+module_exit(probe_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Xenon Memory Probe Interface");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
diff -NurpP --minimal linux-3.5.4/drivers/char/xenon_smc.c linux-3.5.4-xenon/drivers/char/xenon_smc.c
--- linux-3.5.4/drivers/char/xenon_smc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/char/xenon_smc.c	2012-10-08 18:39:07.945017839 +0200
@@ -0,0 +1,124 @@
+/*
+ *  Xenon SMC character driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+#define DRV_NAME	"xenon_smc"
+#define DRV_VERSION	"0.2"
+
+
+/* single access for now */
+
+static unsigned long is_active;
+static unsigned char msg[16];
+
+
+
+static ssize_t smc_read(struct file *file, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	if ((count != 16) || *ppos)
+		return -EINVAL;
+	if (copy_to_user(buf, msg, 0x10))
+		return -EFAULT;
+
+	return 16;
+}
+
+int xenon_smc_message_wait(void *msg);
+
+static ssize_t smc_write(struct file *file, const char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	if ((count != 16) || *ppos)
+		return -EINVAL;
+
+	if (copy_from_user(msg, buf, 16))
+		return -EFAULT;
+
+	xenon_smc_message_wait(msg);
+
+	return 16;
+}
+
+static long smc_ioctl(struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int smc_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &is_active))
+		return -EBUSY;
+
+	return nonseekable_open(inode, file);
+}
+
+static int smc_release(struct inode *inode, struct file *file)
+{
+	clear_bit(0, &is_active);
+	return 0;
+}
+
+
+const struct file_operations smc_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= smc_read,
+	.write		= smc_write,
+	.unlocked_ioctl	= smc_ioctl,
+	.open		= smc_open,
+	.release	= smc_release,
+};
+
+static struct miscdevice smc_dev = {
+	.minor =  MISC_DYNAMIC_MINOR,
+	"smc",
+	&smc_fops
+};
+
+int __init smc_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Xenon SMC char driver version " DRV_VERSION "\n");
+
+	ret = misc_register(&smc_dev);
+	return ret;
+}
+
+void __exit smc_exit(void)
+{
+	misc_deregister(&smc_dev);
+}
+
+module_init(smc_init);
+module_exit(smc_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Character Interface for Xenon Southbridge SMC");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
diff -NurpP --minimal linux-3.5.4/drivers/hwmon/Kconfig linux-3.5.4-xenon/drivers/hwmon/Kconfig
--- linux-3.5.4/drivers/hwmon/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/hwmon/Kconfig	2012-10-08 18:39:07.945017839 +0200
@@ -1391,6 +1391,13 @@ config SENSORS_MC13783_ADC
         help
           Support for the A/D converter on MC13783 and MC13892 PMIC.
 
+config SENSORS_XENON
+	tristate "Xenon SMC"
+	depends on PPC_XENON
+	help
+	  This driver provides support for the Xenon SMC sensors and
+	  fan control.
+
 if ACPI
 
 comment "ACPI drivers"
diff -NurpP --minimal linux-3.5.4/drivers/hwmon/Makefile linux-3.5.4-xenon/drivers/hwmon/Makefile
--- linux-3.5.4/drivers/hwmon/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/hwmon/Makefile	2012-10-08 18:39:07.945017839 +0200
@@ -127,6 +127,7 @@ obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l7
 obj-$(CONFIG_SENSORS_W83L786NG)	+= w83l786ng.o
 obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
+obj-$(CONFIG_SENSORS_XENON)	+= xenon-hwmon.o
 
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
diff -NurpP --minimal linux-3.5.4/drivers/hwmon/xenon-hwmon.c linux-3.5.4-xenon/drivers/hwmon/xenon-hwmon.c
--- linux-3.5.4/drivers/hwmon/xenon-hwmon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/hwmon/xenon-hwmon.c	2012-10-08 18:39:07.945017839 +0200
@@ -0,0 +1,200 @@
+/*
+ *  Xenon HW Monitor via SMC driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#define DRV_NAME	"xenon-hwmon"
+#define DRV_VERSION	"0.1"
+
+#if 0
+struct hwmon {
+	spinlock_t	lock;
+
+	struct device	*xenon_hwmon_dev;
+};
+#endif
+static unsigned int fan_speed[2];
+
+int xenon_smc_message_wait(void *msg);
+
+static unsigned long xenon_get_temp(unsigned nr)
+{
+	unsigned char msg[16] = { 0x07 };
+	static unsigned int temp[4] = { 0 };
+
+	/* FIXME: only every N jiffies */
+	xenon_smc_message_wait(msg);
+	temp[0] = (msg[1] | (msg[2] << 8)) * 1000 / 256;
+	temp[1] = (msg[3] | (msg[4] << 8)) * 1000 / 256;
+	temp[2] = (msg[5] | (msg[6] << 8)) * 1000 / 256;
+	temp[3] = (msg[7] | (msg[8] << 8)) * 1000 / 256;
+
+	return temp[nr & 3];
+}
+
+void xenon_smc_message(void *msg);
+
+static int xenon_set_cpu_fan_speed(unsigned val)
+{
+	unsigned char msg[16] = { 0x94, (val & 0x7F) | 0x80 };
+
+	xenon_smc_message(msg);
+	return 0;
+}
+
+static int xenon_set_gpu_fan_speed(unsigned val)
+{
+	unsigned char msg[16] = { 0x89, (val & 0x7F) | 0x80 };
+
+	xenon_smc_message(msg);
+	return 0;
+}
+
+
+static ssize_t show_fan_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int fan_nr = to_sensor_dev_attr(attr)->index;
+	// void *p = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", fan_speed[fan_nr]);
+}
+
+static ssize_t set_fan_speed(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int fan_nr = to_sensor_dev_attr(attr)->index;
+	unsigned int val = simple_strtol(buf, NULL, 10);
+	// void *p = dev_get_drvdata(dev);
+
+	fan_speed[fan_nr] = val & 0xFF;
+
+	if (fan_nr == 0)
+		xenon_set_cpu_fan_speed(val);
+	if (fan_nr == 1)
+		xenon_set_gpu_fan_speed(val);
+
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR(cpu_fan_speed, S_IRUGO | S_IWUSR,
+		show_fan_speed, set_fan_speed, 0);
+static SENSOR_DEVICE_ATTR(gpu_fan_speed, S_IRUGO | S_IWUSR,
+		show_fan_speed, set_fan_speed, 1);
+
+static ssize_t show_temp(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int temp_nr = to_sensor_dev_attr(attr)->index;
+	// struct dev *p = dev_get_drvdata(pdev);
+	unsigned temp = xenon_get_temp(temp_nr);
+
+	return sprintf(buf, "%d\n", temp);
+}
+
+static SENSOR_DEVICE_ATTR(cpu_temp, S_IRUGO, show_temp, NULL, 0);
+static SENSOR_DEVICE_ATTR(gpu_temp, S_IRUGO, show_temp, NULL, 1);
+static SENSOR_DEVICE_ATTR(edram_temp, S_IRUGO, show_temp, NULL, 2);
+static SENSOR_DEVICE_ATTR(motherboard_temp, S_IRUGO, show_temp, NULL, 3);
+
+static ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "xenon\n");
+}
+
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);
+
+static struct attribute *xenon_hwmon_attributes[] = {
+	&sensor_dev_attr_cpu_fan_speed.dev_attr.attr,
+	&sensor_dev_attr_gpu_fan_speed.dev_attr.attr,
+	&sensor_dev_attr_cpu_temp.dev_attr.attr,
+	&sensor_dev_attr_gpu_temp.dev_attr.attr,
+	&sensor_dev_attr_edram_temp.dev_attr.attr,
+	&sensor_dev_attr_motherboard_temp.dev_attr.attr,
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group xenon_hwmon_group = {
+	.attrs = xenon_hwmon_attributes,
+};
+
+static int __init xenon_hwmon_probe(struct platform_device *pdev)
+{
+	struct device *dev;
+	int err;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &xenon_hwmon_group);
+	if (err)
+		goto out;
+
+	dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(dev)) {
+		err = PTR_ERR(dev);
+		goto out_sysfs_remove_group;
+	}
+
+	platform_set_drvdata(pdev, dev);
+	return 0;
+
+out_sysfs_remove_group:
+	sysfs_remove_group(&pdev->dev.kobj, &xenon_hwmon_group);
+out:
+	return err;
+}
+
+static int __exit xenon_hwmon_remove(struct platform_device *pdev)
+{
+	hwmon_device_unregister(&pdev->dev);
+	sysfs_remove_group(&pdev->dev.kobj, &xenon_hwmon_group);
+	return 0;
+}
+
+
+static struct platform_driver xenon_hwmon_driver = {
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(xenon_hwmon_remove),
+};
+
+static int __init xenon_hwmon_init(void)
+{
+	int ret = platform_driver_probe(&xenon_hwmon_driver, xenon_hwmon_probe);
+
+	printk("xenon_hwmon_init() = %d\n", ret);
+	return ret;
+}
+
+static void __exit xenon_hwmon_exit(void)
+{
+	platform_driver_unregister(&xenon_hwmon_driver);
+}
+
+module_init(xenon_hwmon_init);
+module_exit(xenon_hwmon_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Character Interface for Xenon (H)ana");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff -NurpP --minimal linux-3.5.4/drivers/input/joystick/xpad.c.new linux-3.5.4-xenon/drivers/input/joystick/xpad.c.new
--- linux-3.5.4/drivers/input/joystick/xpad.c.new	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/input/joystick/xpad.c.new	2012-10-08 18:39:07.945017839 +0200
@@ -0,0 +1,1078 @@
+/*
+ * Xbox gamepad driver with Xbox 360 wired/wireless support
+ *
+ * Last Modified:	2 March 2009
+ *			Mike Murphy <mamurph@cs.clemson.edu>
+ *
+ * Copyright (c) 2002 Marko Friedemann <mfr@bmx-chemnitz.de>
+ *               2004 Oliver Schwartz <Oliver.Schwartz@gmx.de>,
+ *                    Steven Toth <steve@toth.demon.co.uk>,
+ *                    Franz Lehner <franz@caos.at>,
+ *                    Ivan Hawkes <blackhawk@ivanhawkes.com>
+ *               2005 Dominic Cerquetti <binary1230@yahoo.com>
+ *               2006 Adam Buchbinder <adam.buchbinder@gmail.com>
+ *               2007 Jan Kratochvil <honza@jikos.cz>
+ *               2010 Christoph Fritz <chf.fritz@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ * This driver is based on:
+ *  - information from     http://euc.jp/periphs/xbox-controller.ja.html
+ *  - the iForce driver    drivers/char/joystick/iforce.c
+ *  - the skeleton-driver  drivers/usb/usb-skeleton.c
+ *  - Xbox 360 information http://www.free60.org/wiki/Gamepad
+ *
+ * Thanks to:
+ *  - ITO Takayuki for providing essential xpad information on his website
+ *  - Vojtech Pavlik     - iforce driver / input subsystem
+ *  - Greg Kroah-Hartman - usb-skeleton driver
+ *  - XBOX Linux project - extra USB id's
+ *
+ * TODO:
+ *  - fine tune axes (especially trigger axes)
+ *  - fix "analog" buttons (reported as digital now)
+ *  - get rumble working
+ *  - need USB IDs for other dance pads
+ *
+ * History:
+ *
+ * 2002-06-27 - 0.0.1 : first version, just said "XBOX HID controller"
+ *
+ * 2002-07-02 - 0.0.2 : basic working version
+ *  - all axes and 9 of the 10 buttons work (german InterAct device)
+ *  - the black button does not work
+ *
+ * 2002-07-14 - 0.0.3 : rework by Vojtech Pavlik
+ *  - indentation fixes
+ *  - usb + input init sequence fixes
+ *
+ * 2002-07-16 - 0.0.4 : minor changes, merge with Vojtech's v0.0.3
+ *  - verified the lack of HID and report descriptors
+ *  - verified that ALL buttons WORK
+ *  - fixed d-pad to axes mapping
+ *
+ * 2002-07-17 - 0.0.5 : simplified d-pad handling
+ *
+ * 2004-10-02 - 0.0.6 : DDR pad support
+ *  - borrowed from the XBOX linux kernel
+ *  - USB id's for commonly used dance pads are present
+ *  - dance pads will map D-PAD to buttons, not axes
+ *  - pass the module paramater 'dpad_to_buttons' to force
+ *    the D-PAD to map to buttons if your pad is not detected
+ *
+ * Later changes can be tracked in SCM.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/module.h>
+#include <linux/usb/input.h>
+
+#define DRIVER_AUTHOR "Marko Friedemann <mfr@bmx-chemnitz.de>"
+#define DRIVER_DESC "X-Box pad driver"
+
+#define XPAD_PKT_LEN 32
+
+/* xbox d-pads should map to buttons, as is required for DDR pads
+   but we map them to axes when possible to simplify things */
+#define MAP_DPAD_TO_BUTTONS		(1 << 0)
+#define MAP_TRIGGERS_TO_BUTTONS		(1 << 1)
+#define MAP_STICKS_TO_NULL		(1 << 2)
+#define DANCEPAD_MAP_CONFIG	(MAP_DPAD_TO_BUTTONS |			\
+				MAP_TRIGGERS_TO_BUTTONS | MAP_STICKS_TO_NULL)
+
+#define XTYPE_XBOX        0
+#define XTYPE_XBOX360     1
+#define XTYPE_XBOX360W    2
+#define XTYPE_UNKNOWN     3
+
+static int dpad_to_buttons;
+module_param(dpad_to_buttons, bool, S_IRUGO);
+MODULE_PARM_DESC(dpad_to_buttons, "Map D-PAD to buttons rather than axes for unknown pads");
+
+static int triggers_to_buttons;
+module_param(triggers_to_buttons, bool, S_IRUGO);
+MODULE_PARM_DESC(triggers_to_buttons, "Map triggers to buttons rather than axes for unknown pads");
+
+static int sticks_to_null;
+module_param(sticks_to_null, bool, S_IRUGO);
+MODULE_PARM_DESC(sticks_to_null, "Do not map sticks at all for unknown pads");
+
+static const struct xpad_device {
+	u16 idVendor;
+	u16 idProduct;
+	char *name;
+	u8 mapping;
+	u8 xtype;
+} xpad_device[] = {
+	{ 0x045e, 0x0202, "Microsoft X-Box pad v1 (US)", 0, XTYPE_XBOX },
+	{ 0x045e, 0x0289, "Microsoft X-Box pad v2 (US)", 0, XTYPE_XBOX },
+	{ 0x045e, 0x0285, "Microsoft X-Box pad (Japan)", 0, XTYPE_XBOX },
+	{ 0x045e, 0x0287, "Microsoft Xbox Controller S", 0, XTYPE_XBOX },
+	{ 0x045e, 0x0719, "Xbox 360 Wireless Receiver", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
+	{ 0x0c12, 0x8809, "RedOctane Xbox Dance Pad", DANCEPAD_MAP_CONFIG, XTYPE_XBOX },
+	{ 0x044f, 0x0f07, "Thrustmaster, Inc. Controller", 0, XTYPE_XBOX },
+	{ 0x046d, 0xc242, "Logitech Chillstream Controller", 0, XTYPE_XBOX360 },
+	{ 0x046d, 0xca84, "Logitech Xbox Cordless Controller", 0, XTYPE_XBOX },
+	{ 0x046d, 0xca88, "Logitech Compact Controller for Xbox", 0, XTYPE_XBOX },
+	{ 0x05fd, 0x1007, "Mad Catz Controller (unverified)", 0, XTYPE_XBOX },
+	{ 0x05fd, 0x107a, "InterAct 'PowerPad Pro' X-Box pad (Germany)", 0, XTYPE_XBOX },
+	{ 0x0738, 0x4516, "Mad Catz Control Pad", 0, XTYPE_XBOX },
+	{ 0x0738, 0x4522, "Mad Catz LumiCON", 0, XTYPE_XBOX },
+	{ 0x0738, 0x4526, "Mad Catz Control Pad Pro", 0, XTYPE_XBOX },
+	{ 0x0738, 0x4536, "Mad Catz MicroCON", 0, XTYPE_XBOX },
+	{ 0x0738, 0x4540, "Mad Catz Beat Pad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
+	{ 0x0738, 0x4556, "Mad Catz Lynx Wireless Controller", 0, XTYPE_XBOX },
+	{ 0x0738, 0x4716, "Mad Catz Wired Xbox 360 Controller", 0, XTYPE_XBOX360 },
+	{ 0x0738, 0x4738, "Mad Catz Wired Xbox 360 Controller (SFIV)", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
+	{ 0x0738, 0x6040, "Mad Catz Beat Pad Pro", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
+	{ 0x0c12, 0x8802, "Zeroplus Xbox Controller", 0, XTYPE_XBOX },
+	{ 0x0c12, 0x880a, "Pelican Eclipse PL-2023", 0, XTYPE_XBOX },
+	{ 0x0c12, 0x8810, "Zeroplus Xbox Controller", 0, XTYPE_XBOX },
+	{ 0x0c12, 0x9902, "HAMA VibraX - *FAULTY HARDWARE*", 0, XTYPE_XBOX },
+	{ 0x0e4c, 0x1097, "Radica Gamester Controller", 0, XTYPE_XBOX },
+	{ 0x0e4c, 0x2390, "Radica Games Jtech Controller", 0, XTYPE_XBOX },
+	{ 0x0e6f, 0x0003, "Logic3 Freebird wireless Controller", 0, XTYPE_XBOX },
+	{ 0x0e6f, 0x0005, "Eclipse wireless Controller", 0, XTYPE_XBOX },
+	{ 0x0e6f, 0x0006, "Edge wireless Controller", 0, XTYPE_XBOX },
+	{ 0x0e6f, 0x0006, "Pelican 'TSZ' Wired Xbox 360 Controller", 0, XTYPE_XBOX360 },
+	{ 0x0e6f, 0x0201, "Pelican PL-3601 'TSZ' Wired Xbox 360 Controller", 0, XTYPE_XBOX360 },
+	{ 0x0e8f, 0x0201, "SmartJoy Frag Xpad/PS2 adaptor", 0, XTYPE_XBOX },
+	{ 0x0f30, 0x0202, "Joytech Advanced Controller", 0, XTYPE_XBOX },
+	{ 0x0f30, 0x8888, "BigBen XBMiniPad Controller", 0, XTYPE_XBOX },
+	{ 0x102c, 0xff0c, "Joytech Wireless Advanced Controller", 0, XTYPE_XBOX },
+	{ 0x12ab, 0x8809, "Xbox DDR dancepad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
+	{ 0x1430, 0x4748, "RedOctane Guitar Hero X-plorer", 0, XTYPE_XBOX360 },
+	{ 0x1430, 0x8888, "TX6500+ Dance Pad (first generation)", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
+	{ 0x146b, 0x0601, "BigBen Interactive XBOX 360 Controller", 0, XTYPE_XBOX360 },
+	{ 0x045e, 0x028e, "Microsoft X-Box 360 pad", 0, XTYPE_XBOX360 },
+	{ 0x1bad, 0x0003, "Harmonix Rock Band Drumkit", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },
+	{ 0x0f0d, 0x0016, "Hori Real Arcade Pro.EX", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
+	{ 0x0f0d, 0x000d, "Hori Fighting Stick EX2", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
+	{ 0xffff, 0xffff, "Chinese-made Xbox Controller", 0, XTYPE_XBOX },
+	{ 0x0000, 0x0000, "Generic X-Box pad", 0, XTYPE_UNKNOWN }
+};
+
+/* buttons shared with xbox and xbox360 */
+static const signed short xpad_common_btn[] = {
+	BTN_A, BTN_B, BTN_X, BTN_Y,			/* "analog" buttons */
+	BTN_START, BTN_SELECT, BTN_THUMBL, BTN_THUMBR,	/* start/back/sticks */
+	-1						/* terminating entry */
+};
+
+/* original xbox controllers only */
+static const signed short xpad_btn[] = {
+	BTN_C, BTN_Z,		/* "analog" buttons */
+	-1			/* terminating entry */
+};
+
+/* used when dpad is mapped to buttons */
+static const signed short xpad_btn_pad[] = {
+	BTN_TRIGGER_HAPPY1, BTN_TRIGGER_HAPPY2,		/* d-pad left, right */
+	BTN_TRIGGER_HAPPY3, BTN_TRIGGER_HAPPY4,		/* d-pad up, down */
+	-1				/* terminating entry */
+};
+
+/* used when triggers are mapped to buttons */
+static const signed short xpad_btn_triggers[] = {
+	BTN_TL2, BTN_TR2,		/* triggers left/right */
+	-1
+};
+
+
+/* buttons for x360 controller */
+static const signed short xpad360_btn[] = {
+	BTN_TL, BTN_TR,		/* Button LB/RB */
+	BTN_MODE,		/* The big X button */
+	-1
+};
+
+/* sticks and triggers common to all devices */
+static const signed short xpad_abs[] = {
+	ABS_X, ABS_Y,		/* left stick */
+	ABS_RX, ABS_RY,		/* right stick */
+	-1			/* terminating entry */
+};
+
+/* used when dpad is mapped to axes */
+static const signed short xpad_abs_pad[] = {
+	ABS_HAT0X, ABS_HAT0Y,	/* d-pad axes */
+	-1			/* terminating entry */
+};
+
+/* used when triggers are mapped to axes */
+static const signed short xpad_abs_triggers[] = {
+	ABS_Z, ABS_RZ,		/* triggers left/right */
+	-1
+};
+
+/* Xbox 360 has a vendor-specific class, so we cannot match it with only
+ * USB_INTERFACE_INFO (also specifically refused by USB subsystem), so we
+ * match against vendor id as well. Wired Xbox 360 devices have protocol 1,
+ * wireless controllers have protocol 129. */
+#define XPAD_XBOX360_VENDOR_PROTOCOL(vend,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_INT_INFO, \
+	.idVendor = (vend), \
+	.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \
+	.bInterfaceSubClass = 93, \
+	.bInterfaceProtocol = (pr)
+#define XPAD_XBOX360_VENDOR(vend) \
+	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend,1) }, \
+	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend,129) }
+
+static struct usb_device_id xpad_table [] = {
+	{ USB_INTERFACE_INFO('X', 'B', 0) },	/* X-Box USB-IF not approved class */
+	XPAD_XBOX360_VENDOR(0x045e),		/* Microsoft X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x046d),		/* Logitech X-Box 360 style controllers */
+	XPAD_XBOX360_VENDOR(0x0738),		/* Mad Catz X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x0e6f),		/* 0x0e6f X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x1430),		/* RedOctane X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x146b),		/* BigBen Interactive Controllers */
+	XPAD_XBOX360_VENDOR(0x1bad),		/* Rock Band Drums */
+	XPAD_XBOX360_VENDOR(0x0f0d),            /* Hori Controllers */
+	{ }
+};
+
+MODULE_DEVICE_TABLE (usb, xpad_table);
+
+struct usb_xpad {
+	struct input_dev *dev;		/* input device interface */
+	struct usb_device *udev;	/* usb device */
+
+	int pad_present;
+
+	struct urb *irq_in;		/* urb for interrupt in report */
+	unsigned char *idata;		/* input data */
+	dma_addr_t idata_dma;
+
+	struct urb *bulk_out;
+	unsigned char *bdata;
+
+#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
+	struct urb *irq_out;		/* urb for interrupt out report */
+	unsigned char *odata;		/* output data */
+	dma_addr_t odata_dma;
+	struct mutex odata_mutex;
+#endif
+
+#if defined(CONFIG_JOYSTICK_XPAD_LEDS)
+	struct xpad_led *led;
+#endif
+
+	char phys[64];			/* physical device path */
+
+	int mapping;			/* map d-pad to buttons or to axes */
+	int xtype;			/* type of xbox device */
+};
+
+/*
+ *	xpad_process_packet
+ *
+ *	Completes a request by converting the data into events for the
+ *	input subsystem.
+ *
+ *	The used report descriptor was taken from ITO Takayukis website:
+ *	 http://euc.jp/periphs/xbox-controller.ja.html
+ */
+
+static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
+{
+	struct input_dev *dev = xpad->dev;
+
+	if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
+		/* left stick */
+		input_report_abs(dev, ABS_X,
+				 (__s16) le16_to_cpup((__le16 *)(data + 12)));
+		input_report_abs(dev, ABS_Y,
+				 ~(__s16) le16_to_cpup((__le16 *)(data + 14)));
+
+		/* right stick */
+		input_report_abs(dev, ABS_RX,
+				 (__s16) le16_to_cpup((__le16 *)(data + 16)));
+		input_report_abs(dev, ABS_RY,
+				 ~(__s16) le16_to_cpup((__le16 *)(data + 18)));
+	}
+
+	/* triggers left/right */
+	if (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {
+		input_report_key(dev, BTN_TL2, data[10]);
+		input_report_key(dev, BTN_TR2, data[11]);
+	} else {
+		input_report_abs(dev, ABS_Z, data[10]);
+		input_report_abs(dev, ABS_RZ, data[11]);
+	}
+
+	/* digital pad */
+	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
+		/* dpad as buttons (left, right, up, down) */
+		input_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & 0x04);
+		input_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);
+		input_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);
+		input_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);
+	} else {
+		input_report_abs(dev, ABS_HAT0X,
+				 !!(data[2] & 0x08) - !!(data[2] & 0x04));
+		input_report_abs(dev, ABS_HAT0Y,
+				 !!(data[2] & 0x02) - !!(data[2] & 0x01));
+	}
+
+	/* start/back buttons and stick press left/right */
+	input_report_key(dev, BTN_START,  data[2] & 0x10);
+	input_report_key(dev, BTN_SELECT, data[2] & 0x20);
+	input_report_key(dev, BTN_THUMBL, data[2] & 0x40);
+	input_report_key(dev, BTN_THUMBR, data[2] & 0x80);
+
+	/* "analog" buttons A, B, X, Y */
+	input_report_key(dev, BTN_A, data[4]);
+	input_report_key(dev, BTN_B, data[5]);
+	input_report_key(dev, BTN_X, data[6]);
+	input_report_key(dev, BTN_Y, data[7]);
+
+	/* "analog" buttons black, white */
+	input_report_key(dev, BTN_C, data[8]);
+	input_report_key(dev, BTN_Z, data[9]);
+
+	input_sync(dev);
+}
+
+
+/*
+ *	xpad360_process_packet
+ *
+ *	Completes a request by converting the data into events for the
+ *	input subsystem. It is version for xbox 360 controller
+ *
+ *	The used report descriptor was taken from:
+ *		http://www.free60.org/wiki/Gamepad
+ */
+
+static void xpad360_process_packet(struct usb_xpad *xpad, u16 cmd,
+		unsigned char *data)
+{
+	struct input_dev *dev = xpad->dev;
+	int trigger;
+
+	/* digital pad */
+	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
+		/* dpad as buttons (left, right, up, down) */
+		input_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & 0x04);
+		input_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);
+		input_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);
+		input_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);
+	} else {
+		input_report_abs(dev, ABS_HAT0X,
+				 !!(data[2] & 0x08) - !!(data[2] & 0x04));
+		input_report_abs(dev, ABS_HAT0Y,
+				 !!(data[2] & 0x02) - !!(data[2] & 0x01));
+	}
+
+	/* start/back buttons */
+	input_report_key(dev, BTN_START,  data[2] & 0x10);
+	input_report_key(dev, BTN_SELECT, data[2] & 0x20);
+
+	/* stick press left/right */
+	input_report_key(dev, BTN_THUMBL, data[2] & 0x40);
+	input_report_key(dev, BTN_THUMBR, data[2] & 0x80);
+
+	/* buttons A,B,X,Y,TL,TR and MODE */
+	input_report_key(dev, BTN_A,	data[3] & 0x10);
+	input_report_key(dev, BTN_B,	data[3] & 0x20);
+	input_report_key(dev, BTN_X,	data[3] & 0x40);
+	input_report_key(dev, BTN_Y,	data[3] & 0x80);
+	input_report_key(dev, BTN_TL,	data[3] & 0x01);
+	input_report_key(dev, BTN_TR,	data[3] & 0x02);
+	input_report_key(dev, BTN_MODE,	data[3] & 0x04);
+
+	if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
+		/* left stick */
+		input_report_abs(dev, ABS_X,
+				 (__s16) le16_to_cpup((__le16 *)(data + 6)));
+		input_report_abs(dev, ABS_Y,
+				 ~(__s16) le16_to_cpup((__le16 *)(data + 8)));
+
+		/* right stick */
+		input_report_abs(dev, ABS_RX,
+				 (__s16) le16_to_cpup((__le16 *)(data + 10)));
+		input_report_abs(dev, ABS_RY,
+				 ~(__s16) le16_to_cpup((__le16 *)(data + 12)));
+	}
+
+	/* triggers left/right */
+	if (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {
+		input_report_key(dev, BTN_TL2, data[4]);
+		input_report_key(dev, BTN_TR2, data[5]);
+	} else {
+		input_report_abs(dev, ABS_Z, data[4]);
+		input_report_abs(dev, ABS_RZ, data[5]);
+	}
+
+	input_sync(dev);
+}
+
+/*
+ * xpad360w_process_packet
+ *
+ * Completes a request by converting the data into events for the
+ * input subsystem. It is version for xbox 360 wireless controller.
+ *
+ * Byte.Bit
+ * 00.1 - Status change: The controller or headset has connected/disconnected
+ *                       Bits 01.7 and 01.6 are valid
+ * 01.f - Some kind of unique identifier message (see above)
+ * 01.7 - Controller present
+ * 01.6 - Headset present
+ * 01.1 - Pad state (Bytes 4+) valid
+ *
+ */
+
+static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd,
+		unsigned char *data)
+{
+	int padnum = 0;
+
+	/* Presence change */
+	if (data[0] & 0x08) {
+		padnum = xpad->controller_number;
+		if (data[1] & 0x80) {
+			/* ignore duplicates */
+			if (!xpad->controller_present) {
+				xpad->controller_present = 1;
+				/*schedule_work(&xpad->work);*/
+				/* Wait for id packet before setting
+				 * controller type and LEDs */
+			}
+		} else {
+			xpad->controller_present = 0;
+			xpad->controller_unique_id[0] = '\0';
+			xpad->controller_type = XCONTROLLER_TYPE_NONE;
+			/* We do NOT flush the shared workqueue here, because
+			 * this function is called from an interrupt handler.
+			 * If the controller has disconnected from the receiver,
+			 * the worst that will happen from the work task running
+			 * is that a packet will be transmitted from the
+			 * receiver to a non-listening controller
+			 */
+		}
+	}
+
+	/* Process packets according to type */
+	if (data[1] == 0x0f) {
+		if (!xpad->controller_unique_id[0]) {
+			if (xpad->id_packet) {
+				memcpy(xpad->id_packet, data, 29);
+				schedule_work(&xpad->work);
+			}
+		}
+	} else if (data[1] & 0x1) {
+		xpad360_process_packet(xpad, cmd, &data[4]);
+	}
+}
+
+
+static void xpad_irq_in(struct urb *urb)
+{
+	struct usb_xpad *xpad = urb->context;
+	int retval, status;
+
+	status = urb->status;
+
+	switch (status) {
+	case 0:
+		/* success */
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d",
+			__func__, status);
+		return;
+	default:
+		dbg("%s - nonzero urb status received: %d",
+			__func__, status);
+		goto exit;
+	}
+
+	switch (xpad->xtype) {
+	case XTYPE_XBOX360:
+		xpad360_process_packet(xpad, 0, xpad->idata);
+		break;
+	case XTYPE_XBOX360W:
+		xpad360w_process_packet(xpad, 0, xpad->idata);
+		break;
+	default:
+		xpad_process_packet(xpad, 0, xpad->idata);
+	}
+
+exit:
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
+		err("%s - usb_submit_urb failed with result %d",
+		     __func__, retval);
+}
+
+/* end input section */
+
+/*****************************************************************************/
+/* IRQ output section: present in object code only if the force feedback or
+ * LED interface is enabled.
+ */
+
+#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
+static void xpad_irq_out(struct urb *urb)
+{
+	int retval, status;
+
+	status = urb->status;
+
+	switch (status) {
+	case 0:
+		/* success */
+		return;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d", __func__, status);
+		return;
+
+	default:
+		dbg("%s - nonzero urb status received: %d", __func__, status);
+		goto exit;
+	}
+
+exit:
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
+		err("%s - usb_submit_urb failed with result %d",
+		    __func__, retval);
+}
+
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
+{
+	struct usb_endpoint_descriptor *ep_irq_out;
+	int error = -ENOMEM;
+
+	if (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX)
+		return 0;
+
+	xpad->odata = usb_alloc_coherent(xpad->udev, XPAD_PKT_LEN,
+					 GFP_KERNEL, &xpad->odata_dma);
+	if (!xpad->odata)
+		goto fail1;
+
+	mutex_init(&xpad->odata_mutex);
+
+	xpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);
+	if (!xpad->irq_out)
+		goto fail2;
+
+	ep_irq_out = &intf->cur_altsetting->endpoint[1].desc;
+	usb_fill_int_urb(xpad->irq_out, xpad->udev,
+			 usb_sndintpipe(xpad->udev,
+				ep_irq_out->bEndpointAddress),
+			 xpad->odata, XPAD_PKT_LEN,
+			 xpad_irq_out, xpad, ep_irq_out->bInterval);
+	xpad->irq_out->transfer_dma = xpad->odata_dma;
+	xpad->irq_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	return 0;
+
+ fail2:	usb_free_coherent(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);
+ fail1:	return error;
+}
+
+static void xpad_stop_output(struct usb_xpad *xpad)
+{
+	if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX)
+		usb_kill_urb(xpad->irq_out);
+}
+
+static void xpad_deinit_output(struct usb_xpad *xpad)
+{
+	if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX) {
+		usb_free_urb(xpad->irq_out);
+		usb_free_coherent(xpad->udev, XPAD_PKT_LEN,
+				xpad->odata, xpad->odata_dma);
+	}
+}
+#else
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }
+static void xpad_deinit_output(struct usb_xpad *xpad) {}
+static void xpad_stop_output(struct usb_xpad *xpad) {}
+#endif
+
+#ifdef CONFIG_JOYSTICK_XPAD_FF
+static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
+{
+	struct usb_xpad *xpad = input_get_drvdata(dev);
+
+	if (effect->type == FF_RUMBLE) {
+		__u16 strong = effect->u.rumble.strong_magnitude;
+		__u16 weak = effect->u.rumble.weak_magnitude;
+
+		switch (xpad->xtype) {
+
+		case XTYPE_XBOX:
+			xpad->odata[0] = 0x00;
+			xpad->odata[1] = 0x06;
+			xpad->odata[2] = 0x00;
+			xpad->odata[3] = strong / 256;	/* left actuator */
+			xpad->odata[4] = 0x00;
+			xpad->odata[5] = weak / 256;	/* right actuator */
+			xpad->irq_out->transfer_buffer_length = 6;
+
+			return usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
+
+		case XTYPE_XBOX360:
+			xpad->odata[0] = 0x00;
+			xpad->odata[1] = 0x08;
+			xpad->odata[2] = 0x00;
+			xpad->odata[3] = strong / 256;  /* left actuator? */
+			xpad->odata[4] = weak / 256;	/* right actuator? */
+			xpad->odata[5] = 0x00;
+			xpad->odata[6] = 0x00;
+			xpad->odata[7] = 0x00;
+			xpad->irq_out->transfer_buffer_length = 8;
+
+			return usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
+
+		default:
+			dbg("%s - rumble command sent to unsupported xpad type: %d",
+				__func__, xpad->xtype);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int xpad_init_ff(struct usb_xpad *xpad)
+{
+	if (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX)
+		return 0;
+
+	input_set_capability(xpad->dev, EV_FF, FF_RUMBLE);
+
+	return input_ff_create_memless(xpad->dev, NULL, xpad_play_effect);
+}
+
+#else
+/* dummy implementation for xpad_probe */
+static int xpad_init_ff(struct usb_xpad *xpad) { return 0; }
+#endif
+
+
+/* end force feedback section */
+
+/*****************************************************************************/
+
+/* LED handling section: provides support for the ring of LEDs on the 360
+ * controllers. */
+
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+
+
+/* XBox 360 wireless controller follows protocol from xboxdrv userspace
+ * driver:
+ *    http://pingus.seul.org/~grumbel/xboxdrv/
+ */
+static void xpad_send_led_command(struct usb_xpad *xpad, int command)
+{
+	if (command >= 0 && command < 14) {
+		mutex_lock(&xpad->odata_mutex);
+		if (xpad->xtype == XTYPE_XBOX360W) {
+			xpad->odata[0] = 0x00;
+			xpad->odata[1] = 0x00;
+			xpad->odata[2] = 0x08;
+			xpad->odata[3] = 0x40 + (command % 0x0e);
+			xpad->odata[4] = 0x00;
+			xpad->odata[5] = 0x00;
+			xpad->odata[6] = 0x00;
+			xpad->odata[7] = 0x00;
+			xpad->odata[8] = 0x00;
+			xpad->odata[9] = 0x00;
+			xpad->odata[10] = 0x00;
+			xpad->odata[11] = 0x00;
+			xpad->irq_out->transfer_buffer_length = 12;
+		} else {
+			xpad->odata[0] = 0x01;
+			xpad->odata[1] = 0x03;
+			xpad->odata[2] = command;
+			xpad->irq_out->transfer_buffer_length = 3;
+		}
+		usb_submit_urb(xpad->irq_out, GFP_KERNEL);
+		mutex_unlock(&xpad->odata_mutex);
+	}
+}
+
+static void xpad_led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value)
+{
+	struct xpad_led *xpad_led = container_of(led_cdev,
+						 struct xpad_led, led_cdev);
+
+	xpad_send_led_command(xpad_led->xpad, value);
+}
+
+
+static int xpad_led_probe(struct usb_xpad *xpad)
+{
+	static atomic_t led_seq	= ATOMIC_INIT(0);
+	long led_no;
+	struct xpad_led *led;
+	struct led_classdev *led_cdev;
+	int error;
+
+	if ((xpad->xtype != XTYPE_XBOX360) && (xpad->xtype != XTYPE_XBOX360W))
+		return 0;
+
+	xpad->led = led = kzalloc(sizeof(struct xpad_led), GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
+
+	led_no = (long)atomic_inc_return(&led_seq) - 1;
+
+	snprintf(led->name, sizeof(led->name), "xpad%ld", led_no);
+	led->xpad = xpad;
+
+	led_cdev = &led->led_cdev;
+	led_cdev->name = led->name;
+	led_cdev->brightness_set = xpad_led_set;
+
+	error = led_classdev_register(&xpad->udev->dev, led_cdev);
+	if (error) {
+		kfree(led);
+		xpad->led = NULL;
+		return error;
+	}
+
+	/*
+	 * Light up the segment corresponding to controller number
+	 */
+	xpad_send_led_command(xpad, (led_no % 4) + 2);
+
+	return 0;
+}
+
+static void xpad_led_disconnect(struct usb_xpad *xpad)
+{
+	struct xpad_led *xpad_led = xpad->led;
+
+	if (xpad_led) {
+		led_classdev_unregister(&xpad_led->led_cdev);
+		kfree(xpad_led->name);
+	}
+}
+#else
+/* dummies for xpad_probe and xpad_disconnect */
+static int xpad_led_probe(struct usb_xpad *xpad) { return 0; }
+static void xpad_led_disconnect(struct usb_xpad *xpad) { }
+#endif
+
+/* end LED section */
+
+/*****************************************************************************/
+
+/* Module and device functions */
+
+static int xpad_open(struct input_dev *dev)
+{
+	struct usb_xpad *xpad = input_get_drvdata(dev);
+
+	/* URB was submitted in probe */
+	if (xpad->xtype == XTYPE_XBOX360W)
+		return 0;
+
+	xpad->irq_in->dev = xpad->udev;
+	if (usb_submit_urb(xpad->irq_in, GFP_KERNEL))
+		return -EIO;
+
+	return 0;
+}
+
+static void xpad_close(struct input_dev *dev)
+{
+	struct usb_xpad *xpad = input_get_drvdata(dev);
+
+	if (xpad->xtype != XTYPE_XBOX360W)
+		usb_kill_urb(xpad->irq_in);
+	xpad_stop_output(xpad);
+}
+
+static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
+{
+	set_bit(abs, input_dev->absbit);
+
+	switch (abs) {
+	case ABS_X:
+	case ABS_Y:
+	case ABS_RX:
+	case ABS_RY:	/* the two sticks */
+		input_set_abs_params(input_dev, abs, -32768, 32767, 16, 128);
+		break;
+	case ABS_Z:
+	case ABS_RZ:	/* the triggers (if mapped to axes) */
+		input_set_abs_params(input_dev, abs, 0, 255, 0, 0);
+		break;
+	case ABS_HAT0X:
+	case ABS_HAT0Y:	/* the d-pad (only if dpad is mapped to axes */
+		input_set_abs_params(input_dev, abs, -1, 1, 0, 0);
+		break;
+	}
+}
+
+static int xpad_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_xpad *xpad;
+	struct input_dev *input_dev;
+	struct usb_endpoint_descriptor *ep_irq_in;
+	int controller_type;
+	int i;
+	int error = -ENOMEM;
+
+	for (i = 0; xpad_device[i].idVendor; i++) {
+		if ((le16_to_cpu(udev->descriptor.idVendor) ==
+						xpad_device[i].idVendor) &&
+				(le16_to_cpu(udev->descriptor.idProduct) ==
+						xpad_device[i].idProduct))
+			break;
+	}
+
+	xpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!xpad || !input_dev)
+		goto fail1;
+
+	xpad->idata = usb_alloc_coherent(udev, XPAD_PKT_LEN,
+					 GFP_KERNEL, &xpad->idata_dma);
+	if (!xpad->idata)
+		goto fail1;
+
+	xpad->irq_in = usb_alloc_urb(0, GFP_KERNEL);
+	if (!xpad->irq_in)
+		goto fail2;
+
+	xpad->udev = udev;
+	xpad->mapping = xpad_device[i].mapping;
+	xpad->xtype = xpad_device[i].xtype;
+
+	if (xpad->xtype == XTYPE_UNKNOWN) {
+		if (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {
+			if (intf->cur_altsetting->desc.bInterfaceProtocol == 129)
+				xpad->xtype = XTYPE_XBOX360W;
+			else
+				xpad->xtype = XTYPE_XBOX360;
+		} else
+			xpad->xtype = XTYPE_XBOX;
+
+		if (dpad_to_buttons)
+			xpad->mapping |= MAP_DPAD_TO_BUTTONS;
+		if (triggers_to_buttons)
+			xpad->mapping |= MAP_TRIGGERS_TO_BUTTONS;
+		if (sticks_to_null)
+			xpad->mapping |= MAP_STICKS_TO_NULL;
+	}
+
+	xpad->dev = input_dev;
+	usb_make_path(udev, xpad->phys, sizeof(xpad->phys));
+	strlcat(xpad->phys, "/input0", sizeof(xpad->phys));
+
+	input_dev->name = xpad_device[i].name;
+	input_dev->phys = xpad->phys;
+	usb_to_input_id(udev, &input_dev->id);
+	input_dev->dev.parent = &intf->dev;
+
+	input_set_drvdata(input_dev, xpad);
+
+	input_dev->open = xpad_open;
+	input_dev->close = xpad_close;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+
+	if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
+		input_dev->evbit[0] |= BIT_MASK(EV_ABS);
+		/* set up axes */
+		for (i = 0; xpad_abs[i] >= 0; i++)
+			xpad_set_up_abs(input_dev, xpad_abs[i]);
+	}
+
+	/* set up standard buttons */
+	for (i = 0; xpad_common_btn[i] >= 0; i++)
+		__set_bit(xpad_common_btn[i], input_dev->keybit);
+
+	/* set up model-specific ones */
+	if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W) {
+		for (i = 0; xpad360_btn[i] >= 0; i++)
+			__set_bit(xpad360_btn[i], input_dev->keybit);
+	} else {
+		for (i = 0; xpad_btn[i] >= 0; i++)
+			__set_bit(xpad_btn[i], input_dev->keybit);
+	}
+
+	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
+		for (i = 0; xpad_btn_pad[i] >= 0; i++)
+			__set_bit(xpad_btn_pad[i], input_dev->keybit);
+	} else {
+		for (i = 0; xpad_abs_pad[i] >= 0; i++)
+		    xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
+	}
+
+	if (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {
+		for (i = 0; xpad_btn_triggers[i] >= 0; i++)
+			__set_bit(xpad_btn_triggers[i], input_dev->keybit);
+	} else {
+		for (i = 0; xpad_abs_triggers[i] >= 0; i++)
+			xpad_set_up_abs(input_dev, xpad_abs_triggers[i]);
+	}
+
+	error = xpad_init_output(intf, xpad);
+	if (error)
+		goto fail2;
+
+	error = xpad_init_ff(xpad);
+	if (error)
+		goto fail3;
+
+	error = xpad_led_probe(xpad);
+	if (error)
+		goto fail3;
+
+	ep_irq_in = &intf->cur_altsetting->endpoint[0].desc;
+	usb_fill_int_urb(xpad->irq_in, udev,
+			 usb_rcvintpipe(udev, ep_irq_in->bEndpointAddress),
+			 xpad->idata, XPAD_PKT_LEN, xpad_irq_in,
+			 xpad, ep_irq_in->bInterval);
+	xpad->irq_in->transfer_dma = xpad->idata_dma;
+	xpad->irq_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	error = input_register_device(xpad->dev);
+	if (error)
+		goto fail4;
+
+	usb_set_intfdata(intf, xpad);
+
+	xpad->controller_type = controller_type;
+	if (controller_type != XCONTROLLER_TYPE_NONE)
+		xpad_init_controller(xpad);
+
+	/*
+	 * Submit the int URB immediatly rather than waiting for open
+	 * because we get status messages from the device whether
+	 * or not any controllers are attached.  In fact, it's
+	 * exactly the message that a controller has arrived that
+	 * we're waiting for.
+	 */
+	if (xpad->xtype == XTYPE_XBOX360W) {
+		xpad->controller_present = 0;
+		xpad->controller_number =
+			(intf->cur_altsetting->desc.bInterfaceNumber / 2) + 1;
+		xpad->irq_in->dev = xpad->udev;
+		error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
+		if (error)
+			goto fail5;
+		xpad->id_packet = kzalloc(XPAD_PKT_LEN *
+					sizeof(unsigned char), GFP_KERNEL);
+		if (!xpad->id_packet)
+			goto fail5;
+	} else {
+		xpad->controller_present = 1;
+		xpad->controller_number = 0;
+	}
+
+	/* Set up device attributes */
+	xpad->sysfs_ok = 1;
+	xpad->controller_unique_id[0] = '\0';
+	error = sysfs_create_group(&input_dev->dev.kobj,
+						&xpad_default_attr_group);
+	if (error) {
+		/* Driver will work without the sysfs interface, but parameters
+		 * will not be adjustable, so this failure is a warning. */
+		printk(KERN_WARNING
+			"xpad: sysfs_create_group failed with error %d\n",
+			error);
+		xpad->sysfs_ok = 0;
+	}
+
+	INIT_WORK(&xpad->work, &xpad_work_controller);
+
+	return 0;
+
+ fail5: usb_set_intfdata(intf, NULL);
+	input_unregister_device(xpad->dev);
+	xpad_led_disconnect(xpad);
+ fail4:	usb_free_urb(xpad->irq_in);
+ fail3:	xpad_deinit_output(xpad);
+ fail2:	usb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);
+ fail1:	input_free_device(input_dev);
+	kfree(xpad);
+	return error;
+
+}
+
+static void xpad_disconnect(struct usb_interface *intf)
+{
+	struct usb_xpad *xpad = usb_get_intfdata (intf);
+
+	usb_set_intfdata(intf, NULL);
+	if (xpad) {
+		xpad_led_disconnect(xpad);
+		input_unregister_device(xpad->dev);
+		xpad_deinit_output(xpad);
+		if (xpad->xtype == XTYPE_XBOX360W) {
+			usb_kill_urb(xpad->bulk_out);
+			usb_free_urb(xpad->bulk_out);
+			usb_kill_urb(xpad->irq_in);
+		}
+		usb_free_urb(xpad->irq_in);
+		usb_free_coherent(xpad->udev, XPAD_PKT_LEN,
+				xpad->idata, xpad->idata_dma);
+		kfree(xpad);
+	}
+}
+
+static struct usb_driver xpad_driver = {
+	.name		= "xpad",
+	.probe		= xpad_probe,
+	.disconnect	= xpad_disconnect,
+	.id_table	= xpad_table,
+};
+
+static int __init usb_xpad_init(void)
+{
+	int result = usb_register(&xpad_driver);
+	if (result == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
+	return result;
+}
+
+static void __exit usb_xpad_exit(void)
+{
+	usb_deregister(&xpad_driver);
+}
+
+
+module_init(usb_xpad_init);
+module_exit(usb_xpad_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -NurpP --minimal linux-3.5.4/drivers/input/joystick/xpad.h linux-3.5.4-xenon/drivers/input/joystick/xpad.h
--- linux-3.5.4/drivers/input/joystick/xpad.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/input/joystick/xpad.h	2012-10-08 18:39:07.945017829 +0200
@@ -0,0 +1,399 @@
+/*
+ * Xbox gamepad driver with Xbox 360 wired/wireless support
+ *
+ * Last Modified:	2 March 2009
+ *			Mike Murphy <mamurph@cs.clemson.edu>
+ *
+ * Copyright (c) 2002 Marko Friedemann <mfr@bmx-chemnitz.de>
+ *               2004 Oliver Schwartz <Oliver.Schwartz@gmx.de>,
+ *                    Steven Toth <steve@toth.demon.co.uk>,
+ *                    Franz Lehner <franz@caos.at>,
+ *                    Ivan Hawkes <blackhawk@ivanhawkes.com>
+ *               2005 Dominic Cerquetti <binary1230@yahoo.com>
+ *               2006 Adam Buchbinder <adam.buchbinder@gmail.com>
+ *               2007 Jan Kratochvil <honza@jikos.cz>
+ *               2009 Clemson University
+ *		      (contact: Mike Murphy <mamurph@cs.clemson.edu>)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ * This driver is based on:
+ *  - information from     http://euc.jp/periphs/xbox-controller.ja.html
+ *  - the iForce driver    drivers/char/joystick/iforce.c
+ *  - the skeleton-driver  drivers/usb/usb-skeleton.c
+ *  - Xbox 360 information http://www.free60.org/wiki/Gamepad
+ *  - xboxdrv docs         http://pingus.seul.org/~grumbel/xboxdrv/
+ *
+ * Thanks to:
+ *  - ITO Takayuki for providing essential xpad information on his website
+ *  - Vojtech Pavlik     - iforce driver / input subsystem
+ *  - Greg Kroah-Hartman - usb-skeleton driver
+ *  - XBOX Linux project - extra USB id's
+ *
+ * TODO:
+ *  - fix "analog" buttons (reported as digital now)
+ *  - need USB IDs for other dance pads
+ *
+ * Driver history is located at the bottom of this file.
+ */
+
+#ifndef _XPAD_H
+#define _XPAD_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/module.h>
+#include <linux/usb/input.h>
+#include <linux/workqueue.h>
+
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/string.h>
+
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+#include <linux/leds.h>
+
+struct xpad_led {
+	char name[16];
+	struct led_classdev led_cdev;
+	struct usb_xpad *xpad;
+};
+#endif
+
+
+#define DRIVER_AUTHOR "Marko Friedemann <mfr@bmx-chemnitz.de>"
+#define DRIVER_DESC "Xbox/360 pad driver"
+
+#define XPAD_PKT_LEN 32
+
+
+/* xbox d-pads should map to buttons, as is required for DDR pads
+   but we map them to axes when possible to simplify things */
+#define MAP_DPAD_TO_BUTTONS    0
+#define MAP_DPAD_TO_AXES       1
+#define MAP_DPAD_UNKNOWN       2
+
+/* Type of controller *interface* (original, wired 360, wireless 360) */
+#define XTYPE_XBOX        0
+#define XTYPE_XBOX360     1
+#define XTYPE_XBOX360W    2
+#define XTYPE_UNKNOWN     3
+
+/* Type of controller (e.g. pad, guitar, other input device) */
+#define XCONTROLLER_TYPE_NONE		0
+#define XCONTROLLER_TYPE_PAD		1
+#define XCONTROLLER_TYPE_GUITAR		2
+#define XCONTROLLER_TYPE_DANCE_PAD	3
+#define XCONTROLLER_TYPE_OTHER		255
+
+
+/* The Xbox 360 controllers have sensitive sticks that often do not center
+ * exactly. A dead zone causes stick events below a certain threshhold to be
+ * reported as zero.
+ *
+ * The default dead zone size is 8192, which was obtained by testing a
+ * wireless 360 controller with jstest(1) and consulting gaming forums for
+ * a recommended dead zone for this controller. The consensus opinion was
+ * 0.25 (on a scale from 0 to 1), which corresponds to 8192 (out of 32767).
+ */
+#define XDEAD_ZONE_DEFAULT   8192
+
+/* Default limit for the sticks is the maximum axis value (32767), which will
+ * cause the sticks to have a radial axis as designed in the hardware. To
+ * enable square axis support, set the stick limits to 23170 or lower at run
+ * time via the sysfs interface. */
+#define XSTICK_LIMIT_DEFAULT 32767
+
+/* Rumble normally enabled */
+#define XRUMBLE_DEFAULT		1
+
+/* Normally, trigger axes report in the range 0 to 32767 (positive axis only) */
+#define XFULL_TRIGGER_AXIS_DEFAULT	0
+
+
+/* Xbox 360 has a vendor-specific class, so we cannot match it with only
+ * USB_INTERFACE_INFO (also specifically refused by USB subsystem), so we
+ * match against vendor id as well. Wired Xbox 360 devices have protocol 1,
+ * wireless controllers have protocol 129. */
+#define XPAD_XBOX360_VENDOR_PROTOCOL(vend,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_VENDOR | \
+			USB_DEVICE_ID_MATCH_INT_INFO, \
+	.idVendor = (vend), \
+	.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \
+	.bInterfaceSubClass = 93, \
+	.bInterfaceProtocol = (pr)
+#define XPAD_XBOX360_VENDOR(vend) \
+	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend, 1) }, \
+	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend, 129) }
+
+
+
+/* Some of the fields in the following structure are for later use with
+ * userspace applications to recognize individual controllers. The dead zones
+ * and axis limits can be changed "on the fly" and are effective immediately.
+ *
+ * The fields labeled "ro" and "rw" are intended to be read-only and
+ * read-write, respectively, when exposed in sysfs. Most of the read-only
+ * fields are to support *wireless* 360 controllers. The controller_number
+ * is used to set the LED, while controller_present tracks whether the
+ * controller is connected to the wireless receiver. Controller type applies
+ * to all models (wired and wireless), and tracks whether the device is a pad,
+ * guitar, etc. for later userspace use. See the comment above regarding
+ * type and unique ID detection on wireless 360 receivers.
+ */
+struct usb_xpad {
+	struct input_dev *dev;		/* input device interface */
+	struct usb_device *udev;	/* usb device */
+
+	struct urb *irq_in;		/* urb for interrupt in report */
+	unsigned char *idata;		/* input data */
+	dma_addr_t idata_dma;
+
+#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
+	struct urb *irq_out;		/* urb for interrupt out report */
+	unsigned char *odata;		/* output data */
+	dma_addr_t odata_dma;
+	struct mutex odata_mutex;
+#endif
+
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+	struct xpad_led *led;
+#endif
+
+	char phys[64];			/* physical device path */
+
+	int dpad_mapping;		/* map d-pad to buttons or to axes */
+	int xtype;			/* type of xbox device */
+
+	/* Work structure for moving the call to xpad_send_led_command
+	 * outside the interrupt handler for packet processing */
+	struct work_struct work;
+
+	/* id packet for wireless 360 controller */
+	unsigned char *id_packet;
+
+	int controller_number;		/* controller # (1-4) for 360w. ro */
+	int controller_present;         /* 360w controller presence. ro */
+	int controller_type;            /* controller type. ro */
+	char controller_unique_id[17];  /* unique ID of controller (360w). ro */
+	unsigned int left_dead_zone;    /* dead zone for left stick. rw */
+	unsigned int right_dead_zone;   /* dead zone for right stick. rw */
+	unsigned int left_stick_limit;  /* axis limit for left stick. rw */
+	unsigned int right_stick_limit; /* axis limit for right stick. rw */
+	int rumble_enable;              /* enable/disable rumble. rw */
+	int left_trigger_full_axis;     /* full axis - left trigger. rw */
+	int right_trigger_full_axis;    /* full axis - right trigger. rw */
+
+	int sysfs_ok;                   /* sysfs interface OK */
+};
+#define to_xpad(d) input_get_drvdata(to_input_dev(d))
+
+
+/* Function prototypes for non-sysfs interface functions */
+static void set_dead_zone(unsigned int new_size, unsigned int *dz,
+	unsigned int stick_limit);
+static void set_stick_limit(unsigned int new_size, unsigned int *sl,
+	unsigned int dead_zone);
+static void xpad_init_controller(struct usb_xpad *xpad);
+static void xpad_work_controller(struct work_struct *w);
+static void xpad_process_sticks(struct usb_xpad *xpad, __le16 *data);
+static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd,
+	unsigned char *data);
+static void xpad360_process_packet(struct usb_xpad *xpad, u16 cmd,
+	unsigned char *data);
+static void xpad360w_identify_controller(struct usb_xpad *xpad);
+static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd,
+	unsigned char *data);
+static void xpad_irq_in(struct urb *urb);
+static void xpad_irq_out(struct urb *urb);
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad);
+static void xpad_stop_output(struct usb_xpad *xpad);
+static void xpad_stop_output(struct usb_xpad *xpad);
+static int xpad_play_effect(struct input_dev *dev, void *data,
+			    struct ff_effect *effect);
+static int xpad_init_ff(struct usb_xpad *xpad);
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+static void xpad_send_led_command(struct usb_xpad *xpad, int command);
+static void xpad_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value);
+static int xpad_led_probe(struct usb_xpad *xpad);
+static void xpad_led_disconnect(struct usb_xpad *xpad);
+#endif
+static int xpad_open(struct input_dev *dev);
+static void xpad_close(struct input_dev *dev);
+static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs);
+static int xpad_probe(struct usb_interface *intf,
+	const struct usb_device_id *id);
+static void xpad_disconnect(struct usb_interface *intf);
+static int __init usb_xpad_init(void);
+static void __exit usb_xpad_exit(void);
+
+
+/* sysfs interface */
+static ssize_t xpad_show_uint(struct device *dev, struct device_attribute *attr,
+		char *buf);
+static ssize_t xpad_store_uint(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t xpad_store_bool(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t xpad_store_ro(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count);
+static ssize_t xpad_show_int(struct device *dev, struct device_attribute *attr,
+		char *buf);
+static ssize_t xpad_show_id(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+
+
+/* Device attributes */
+static DEVICE_ATTR(left_dead_zone, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(right_dead_zone, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(left_stick_limit, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(right_stick_limit, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(rumble_enable, 0644, xpad_show_int, xpad_store_bool);
+static DEVICE_ATTR(left_trigger_full_axis, 0644, xpad_show_int,
+			xpad_store_bool);
+static DEVICE_ATTR(right_trigger_full_axis, 0644, xpad_show_int,
+			xpad_store_bool);
+static DEVICE_ATTR(controller_number, 0444, xpad_show_int, xpad_store_ro);
+static DEVICE_ATTR(controller_present, 0444, xpad_show_int, xpad_store_ro);
+static DEVICE_ATTR(controller_type, 0444, xpad_show_int, xpad_store_ro);
+static DEVICE_ATTR(id, 0444, xpad_show_id, xpad_store_ro);
+
+static struct attribute *xpad_default_attrs[] = {
+	&dev_attr_left_dead_zone.attr,
+	&dev_attr_right_dead_zone.attr,
+	&dev_attr_left_stick_limit.attr,
+	&dev_attr_right_stick_limit.attr,
+	&dev_attr_rumble_enable.attr,
+	&dev_attr_left_trigger_full_axis.attr,
+	&dev_attr_right_trigger_full_axis.attr,
+	&dev_attr_controller_number.attr,
+	&dev_attr_controller_present.attr,
+	&dev_attr_controller_type.attr,
+	&dev_attr_id.attr,
+	NULL
+};
+
+static struct attribute_group xpad_default_attr_group = {
+	.attrs = xpad_default_attrs,
+	.name = "game_device",
+};
+
+#endif
+
+/* Driver History:
+ *
+ * 2009-03-02 : Code cleanup
+ *  - used min(), max(), and abs() where appropriate, simplifying code
+ *  - moved code that generates data objects out of xpad.h and into xpad.c
+ *  - changed legacy #if defined(...) to #ifdef
+ *  - removed unnecessary typecasts
+ *  - wireless 360 controller identification now done in workqueue task
+ *  - thanks Andrew Morton, Greg K-H, and Linus Torvalds
+ *
+ * 2009-02-28 : Triggers now half-axes by default
+ *  - triggers will now be positive half-axes only, unless a full axis mapping
+ *    is enabled via the sysfs interface on a per-trigger basis
+ *  - moved INIT_WORK to xpad_probe and removed INIT_WORK/PREPARE_WORK from
+ *    interrupt handler; also removed the work_pending flag from struct
+ *    usb_xpad (always flush shared workqueue on unload)
+ *  - read-write sysfs attributes now have 644 default permissions
+ *
+ * 2009-02-23 : Changes per mailing list (thanks Frederic Weisbecker)
+ *  - no more check for CONFIG_SYSFS: sysfs functions will simply return
+ *    0 if sysfs has not been enabled
+ *  - fixed weird ordering in sscanf return check
+ *  - checked code with scripts/checkpatch.pl and made style adjustments
+ *
+ * 2009-02-21 : Refactored and changed stick handling
+ *  - split code into two pieces (xpad.h and xpad.c)
+ *  - cleaned up sysfs interface
+ *  - changed square axis algorithm to an axis limit algorithm, which allows
+ *    size of inscribed square to be adjusted; available for both sticks
+ *  - dead zones now per-stick
+ *
+ * 2009-02-18 : Changes per mailing list (and some additions)
+ *  - revised sysfs interface (thanks Greg K-H)
+ *  - check return values of sscanf (thanks Oliver Neukum)
+ *  - urb submission while holding mutex now once again GFP_KERNEL
+ *    (thanks Oliver Neukum)
+ *  - work structure fixes (thanks Oliver Neukum)
+ *  - uevents generated for wireless controller online/offline
+ *  - sysfs interface only if CONFIG_SYSFS is set
+ *
+ * 2009-02-15 : Minor adjustments
+ *  - added KOBJ_ONLINE/KOBJ_OFFLINE events when controllers are connected to
+ *    or disconnected from the wireless 360 receiver
+ *  - ignore duplicate connect messages on the same connection
+ *  - added option to enable/disable rumble on a per-controller basis
+ *  - rumble events are not sent to guitar or dance pad devices
+ *
+ * 2009-02-14 : Added sysfs interface
+ *  - dead zones and square axis settings can now be made per-controller
+ *  - removed dead_zone and square_axis module parameters (use sysfs)
+ *  - new square axis algorithm
+ *
+ * 2009-02-13 : Disable square axis for right stick
+ *  - square axis applies to left stick only
+ *
+ * 2009-02-12 : Scaling for dead zone and square axis support
+ *  - axes now scale from 0 to 32767 starting at edge of dead zone
+ *  - increased default dead zone to 8192
+ *  - initial square axis support (reliable only with left stick)
+ *
+ * 2009-02-07 : More wireless 360 controller fixes
+ *  - removed bulk urb completely
+ *  - use xpad_send_led_command to set controller number on LED display
+ *    (wireless 360 controller)
+ *  - dead_zone is now an adjustable module parameter
+ *
+ * 2009-02-06 : Axis handling improvements
+ *  - unified handler for left and right sticks
+ *  - initial support for dead zones
+ *
+ * 2009-02-02 : Wireless 360 controller fixes
+ *  - followed PROTOCOL description from xboxdrv userspace driver
+ *  - LED and rumble support added for wireless 360 controller (protocol
+ *    is different from wired!)
+ *
+ * 2004-10-02 - 0.0.6 : DDR pad support
+ *  - borrowed from the XBOX linux kernel
+ *  - USB id's for commonly used dance pads are present
+ *  - dance pads will map D-PAD to buttons, not axes
+ *  - pass the module paramater 'dpad_to_buttons' to force
+ *    the D-PAD to map to buttons if your pad is not detected
+ *
+ * 2002-07-17 - 0.0.5 : simplified d-pad handling
+ *
+ * 2002-07-16 - 0.0.4 : minor changes, merge with Vojtech's v0.0.3
+ *  - verified the lack of HID and report descriptors
+ *  - verified that ALL buttons WORK
+ *  - fixed d-pad to axes mapping
+ *
+ * 2002-07-14 - 0.0.3 : rework by Vojtech Pavlik
+ *  - indentation fixes
+ *  - usb + input init sequence fixes
+ *
+ * 2002-07-02 - 0.0.2 : basic working version
+ *  - all axes and 9 of the 10 buttons work (german InterAct device)
+ *  - the black button does not work
+ *
+ * 2002-06-27 - 0.0.1 : first version, just said "XBOX HID controller"
+ *
+ */
diff -NurpP --minimal linux-3.5.4/drivers/Makefile linux-3.5.4-xenon/drivers/Makefile
--- linux-3.5.4/drivers/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/Makefile	2012-10-08 18:39:07.945017829 +0200
@@ -9,6 +9,7 @@
 obj-y				+= pinctrl/
 obj-y				+= gpio/
 obj-$(CONFIG_PCI)		+= pci/
+obj-$(CONFIG_PPC_XENON)		+= xenon/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
 obj-y				+= video/
diff -NurpP --minimal linux-3.5.4/drivers/net/ethernet/Kconfig linux-3.5.4-xenon/drivers/net/ethernet/Kconfig
--- linux-3.5.4/drivers/net/ethernet/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/net/ethernet/Kconfig	2012-10-08 18:39:07.945017829 +0200
@@ -175,6 +175,9 @@ source "drivers/net/ethernet/toshiba/Kco
 source "drivers/net/ethernet/tundra/Kconfig"
 source "drivers/net/ethernet/via/Kconfig"
 source "drivers/net/ethernet/wiznet/Kconfig"
+config XENON_ENET
+	tristate "Xenon Fast Ethernet Adapter support"
+	depends on PCI
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 
diff -NurpP --minimal linux-3.5.4/drivers/net/ethernet/Makefile linux-3.5.4-xenon/drivers/net/ethernet/Makefile
--- linux-3.5.4/drivers/net/ethernet/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/net/ethernet/Makefile	2012-10-08 18:39:07.945017829 +0200
@@ -59,6 +59,7 @@ obj-$(CONFIG_NET_VENDOR_REALTEK) += real
 obj-$(CONFIG_SH_ETH) += renesas/
 obj-$(CONFIG_NET_VENDOR_RDC) += rdc/
 obj-$(CONFIG_S6GMAC) += s6gmac.o
+obj-$(CONFIG_XENON_ENET) += xenon_net.o
 obj-$(CONFIG_NET_VENDOR_SEEQ) += seeq/
 obj-$(CONFIG_NET_VENDOR_SILAN) += silan/
 obj-$(CONFIG_NET_VENDOR_SIS) += sis/
diff -NurpP --minimal linux-3.5.4/drivers/net/ethernet/xenon_net.c linux-3.5.4-xenon/drivers/net/ethernet/xenon_net.c
--- linux-3.5.4/drivers/net/ethernet/xenon_net.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/net/ethernet/xenon_net.c	2012-10-08 18:39:07.945017829 +0200
@@ -0,0 +1,696 @@
+/*
+ * xenon_net.c: Driver for Xenon Southbridge Fast Ethernet
+ *
+ * Copyright 2007 Felix Domke <tmbinc@elitedvb.net>
+ * Minor modification by: wolie <wolie@telia.com>
+ *
+ * Licensed under the GPL v2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/crc32.h>
+#include <asm/io.h>
+
+#define XENONNET_VERSION		"1.0.1"
+#define MODNAME			"xenon_net"
+#define XENONNET_DRIVER_LOAD_MSG	"Xenon Fast Ethernet driver " XENONNET_VERSION " loaded"
+#define PFX			MODNAME ": "
+
+#define RX_RING_SIZE 16
+#define TX_RING_SIZE 16
+
+#define TX_TIMEOUT    (6*HZ)
+
+static char version[] __devinitdata =
+KERN_INFO XENONNET_DRIVER_LOAD_MSG "\n"
+KERN_INFO "\n";
+
+static struct pci_device_id xenon_net_pci_tbl[] = {
+	{PCI_VENDOR_ID_MICROSOFT, 0x580a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE (pci, xenon_net_pci_tbl);
+
+/* Symbolic offsets to registers. */
+enum XENONNET_registers {
+	TX_CONFIG = 0x00,
+	TX_DESCRIPTOR_BASE = 0x04,
+	TX_DESCRIPTOR_STATUS = 0x0C,
+	RX_CONFIG = 0x10,
+	RX_DESCRIPTOR_BASE = 0x14,
+	INTERRUPT_STATUS = 0x20,
+	INTERRUPT_MASK = 0x24,
+	CONFIG_0 = 0x28,
+	POWER = 0x30,
+	PHY_CONFIG = 0x40,
+	PHY_CONTROL = 0x44,
+	CONFIG_1 = 0x50,
+	RETRY_COUNT = 0x54,
+	MULTICAST_FILTER_CONTROL = 0x60,
+	ADDRESS_0 = 0x62,
+	MULTICAST_HASH = 0x68,
+	MAX_PACKET_SIZE = 0x78,
+	ADDRESS_1 = 0x7A
+};
+
+struct xenon_net_private {
+	void *mmio_addr;
+
+	struct net_device *dev2;
+	struct napi_struct napi;
+
+	struct pci_dev *pdev;
+	struct net_device_stats stats;
+
+	/* we maintain a list of rx and tx descriptors */
+	void *tx_descriptor_base;
+	void *rx_descriptor_base;
+	dma_addr_t tx_descriptor_base_dma;
+	dma_addr_t rx_descriptor_base_dma;
+
+	struct sk_buff *rx_skbuff[RX_RING_SIZE];
+	dma_addr_t rx_skbuff_dma[RX_RING_SIZE];
+
+	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+	dma_addr_t tx_skbuff_dma[TX_RING_SIZE];
+
+	atomic_t tx_next_free, tx_next_done;
+
+	int rx_buf_sz, rx_next;
+
+	spinlock_t lock;
+};
+
+
+static void xenon_set_tx_descriptor (struct xenon_net_private *tp, int index, u32 len, dma_addr_t addr, int valid)
+{
+	volatile u32 *descr = tp->tx_descriptor_base + index * 0x10;
+	descr[0] = cpu_to_le32(len);
+	descr[2] = cpu_to_le32(addr);
+	descr[3] = cpu_to_le32(len | ((index == TX_RING_SIZE - 1) ? 0x80000000 : 0));
+	wmb();
+	if (valid)
+		descr[1] = cpu_to_le32(0xc0230000);
+	else
+		descr[1] = 0;
+}
+
+static void xenon_set_rx_descriptor (struct xenon_net_private *tp, int index, u32 len, dma_addr_t addr, int valid)
+{
+	volatile u32 *descr = tp->rx_descriptor_base + index * 0x10;
+	descr[0] = cpu_to_le32(0);
+	descr[2] = cpu_to_le32(addr);
+	descr[3] = cpu_to_le32(len | ((index == RX_RING_SIZE - 1) ? 0x80000000 : 0));
+	wmb();
+	if (valid)
+		descr[1] = cpu_to_le32(0xc0000000);
+	else
+		descr[1] = 0;
+}
+
+
+static void xenon_net_tx_interrupt (struct net_device *dev,
+				  struct xenon_net_private *tp,
+				  void *ioaddr)
+{
+	BUG_ON (dev == NULL);
+	BUG_ON (tp == NULL);
+	BUG_ON (ioaddr == NULL);
+
+	while (atomic_read(&tp->tx_next_free) != atomic_read(&tp->tx_next_done))
+	{
+		int e = atomic_read(&tp->tx_next_done) % TX_RING_SIZE;
+
+		volatile u32 *descr = tp->tx_descriptor_base + e * 0x10;
+		if (le32_to_cpu(descr[1]) & 0x80000000)
+			break;
+
+		if (!tp->tx_skbuff[e])
+		{
+			printk(KERN_WARNING "spurious TX complete?!\n");
+			break;
+		}
+
+		pci_unmap_single(tp->pdev, tp->tx_skbuff_dma[e], tp->tx_skbuff[e]->len, PCI_DMA_TODEVICE);
+		dev_kfree_skb_irq(tp->tx_skbuff[e]);
+
+		tp->tx_skbuff[e] = 0;
+		tp->tx_skbuff_dma[e] = 0;
+
+		atomic_inc(&tp->tx_next_done);
+	}
+
+	if ((atomic_read(&tp->tx_next_free) - atomic_read(&tp->tx_next_done)) < TX_RING_SIZE)
+		netif_start_queue (dev);
+}
+
+static int xenon_net_rx_interrupt (struct net_device *dev,
+				  struct xenon_net_private *tp, void *ioaddr)
+{
+	int received; //count and send to work_done
+
+	BUG_ON (dev == NULL);
+	BUG_ON (tp == NULL);
+	BUG_ON (ioaddr == NULL);
+
+	received = 0;
+
+	while (1)
+	{
+		int index = tp->rx_next;
+		volatile u32 *descr = tp->rx_descriptor_base + index * 0x10;
+		dma_addr_t mapping;
+		u32 size;
+		struct sk_buff *skb = tp->rx_skbuff[index], *new_skb;
+
+		if (le32_to_cpu(descr[1]) & 0x80000000)
+			break;
+		size = le32_to_cpu(descr[0]) & 0xFFFF;
+
+		mapping = tp->rx_skbuff_dma[index];
+
+		new_skb = dev_alloc_skb(tp->rx_buf_sz);
+		new_skb->dev = dev;
+
+		pci_unmap_single(tp->pdev, mapping, tp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+		skb->ip_summed = CHECKSUM_NONE;
+		skb_put(skb, size);
+		skb->protocol = eth_type_trans (skb, dev);
+		netif_receive_skb(skb);
+
+		received++;
+
+		dev->last_rx = jiffies;
+
+		mapping = tp->rx_skbuff_dma[index] = pci_map_single(tp->pdev,
+				new_skb->data, tp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+		tp->rx_skbuff[index] = new_skb;
+
+		xenon_set_rx_descriptor(tp, index, tp->rx_buf_sz, tp->rx_skbuff_dma[index], 1);
+
+		tp->rx_next = (tp->rx_next + 1) % RX_RING_SIZE;
+	}
+	writel(0x00101c11, ioaddr + RX_CONFIG);
+
+	return received;
+}
+
+static int xenon_net_poll(struct napi_struct *napi, int budget)
+{
+	int work_done;
+	struct xenon_net_private *tp = container_of(napi, struct xenon_net_private, napi);
+	struct net_device *dev = tp->dev2;
+
+	work_done = 0;
+
+	work_done += xenon_net_rx_interrupt(dev, tp, tp->mmio_addr);
+
+	if (work_done < budget) {
+		__napi_complete(napi);
+	}
+
+	return work_done;
+}
+
+
+
+static irqreturn_t xenon_net_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+	u32 status;
+
+	spin_lock (&tp->lock);
+
+	status = readl(ioaddr + INTERRUPT_STATUS);
+
+	if (status & 0x40)
+	{
+		if (napi_schedule_prep(&tp->napi)) {
+			status &= ~0x40;
+			__napi_schedule(&tp->napi);
+		}
+	}
+
+	if (status & 4)
+	{
+		xenon_net_tx_interrupt(dev, tp, ioaddr);
+		status &= ~0x4;
+	}
+
+//	if (status)
+//		printk(KERN_WARN "other interrupt: %08x\n", status);
+
+	spin_unlock (&tp->lock);
+
+	return IRQ_HANDLED;
+}
+
+
+
+/* Initialize the Rx and Tx rings, along with various 'dev' bits. */
+static void xenon_net_init_ring (struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	int i;
+
+	tp->rx_next = 0;
+	atomic_set (&tp->tx_next_done, 0);
+	atomic_set (&tp->tx_next_free, 0);
+
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		tp->tx_skbuff[i] = NULL;
+		tp->tx_skbuff_dma[i] = 0;
+	}
+
+			/* allocate descriptor memory */
+	tp->tx_descriptor_base = pci_alloc_consistent(tp->pdev,
+			TX_RING_SIZE * 0x10 + RX_RING_SIZE * 0x10,
+			&tp->tx_descriptor_base_dma);
+
+			/* rx is right after tx */
+	tp->rx_descriptor_base = tp->tx_descriptor_base + TX_RING_SIZE * 0x10;
+	tp->rx_descriptor_base_dma = tp->tx_descriptor_base_dma + TX_RING_SIZE * 0x10;
+
+	for (i = 0; i < TX_RING_SIZE; ++i)
+		xenon_set_tx_descriptor(tp, i, 0, 0, 0);
+
+	tp->rx_buf_sz = dev->mtu + 32;
+
+	for (i = 0; i < RX_RING_SIZE; ++i)
+	{
+		struct sk_buff *skb = dev_alloc_skb(tp->rx_buf_sz);
+		tp->rx_skbuff[i] = skb;
+		if (skb == NULL)
+			break;
+		skb->dev = dev;	/* Mark as being used by this device. */
+		tp->rx_skbuff_dma[i] = pci_map_single(tp->pdev, skb->data, tp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+		xenon_set_rx_descriptor(tp, i, tp->rx_buf_sz, tp->rx_skbuff_dma[i], 1);
+	}
+}
+
+/* Start the hardware at open or resume. */
+static void xenon_net_hw_start (struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+
+	/* Soft reset the chip. */
+	writel(0, ioaddr + INTERRUPT_MASK);
+	writel(0x08558001, ioaddr + CONFIG_0);
+	udelay (100);
+	writel(0x08550001, ioaddr + CONFIG_0);
+
+	writel(4, ioaddr + PHY_CONTROL);
+	udelay (100);
+	writel(0, ioaddr + PHY_CONTROL);
+
+	writew(1522, ioaddr + MAX_PACKET_SIZE);
+
+	writel(0x2360, ioaddr + CONFIG_1);
+
+	writew(0x0e38, ioaddr + MULTICAST_FILTER_CONTROL);
+
+	/* Restore our idea of the MAC address. */
+	writew(cpu_to_le16 (*(u16 *) (dev->dev_addr + 0)), ioaddr + ADDRESS_0);
+	writel(cpu_to_le32 (*(u32 *) (dev->dev_addr + 2)), ioaddr + ADDRESS_0 + 2);
+
+	writew(cpu_to_le16 (*(u16 *) (dev->dev_addr + 0)), ioaddr + ADDRESS_1);
+	writel(cpu_to_le32 (*(u32 *) (dev->dev_addr + 2)), ioaddr + ADDRESS_1 + 2);
+
+	writel(0, ioaddr + MULTICAST_HASH);
+	writel(0, ioaddr + MULTICAST_HASH + 4);
+
+	writel(0x00001c00, ioaddr + TX_CONFIG);
+	writel(0x00101c00, ioaddr + RX_CONFIG);
+
+	writel(0x04001901, ioaddr + PHY_CONFIG);
+
+	tp->rx_next = 0;
+
+		/* write base 0 */
+	writel(0x00001c00, ioaddr + TX_CONFIG);
+	writel(tp->tx_descriptor_base_dma, ioaddr + TX_DESCRIPTOR_BASE);
+
+		/* write base 1 */
+	writel(0x00011c00, ioaddr + TX_CONFIG);
+	writel(tp->tx_descriptor_base_dma, ioaddr + TX_DESCRIPTOR_BASE);
+	writel(0x00001c00, ioaddr + TX_CONFIG);
+
+	writel(tp->rx_descriptor_base_dma, ioaddr + RX_DESCRIPTOR_BASE);
+	writel(0x04001001, ioaddr + PHY_CONFIG);
+	writel(0, ioaddr + CONFIG_1);
+
+	writel(0x08550001, ioaddr + CONFIG_0);
+
+	writel(0x00001c01, ioaddr + TX_CONFIG); /* enable tx */
+	writel(0x00101c11, ioaddr + RX_CONFIG); /* enable rx */
+
+	writel(0x00010054, ioaddr + INTERRUPT_MASK);
+	writel(0x00010054, ioaddr + INTERRUPT_STATUS);
+
+	netif_start_queue (dev);
+}
+
+
+static int xenon_net_open (struct net_device *dev)
+{
+	int retval;
+
+	struct xenon_net_private *tp = netdev_priv(dev);
+	napi_enable(&tp->napi);
+
+	retval = request_irq (dev->irq, xenon_net_interrupt, IRQF_SHARED, dev->name, dev);
+	if (retval)
+		return retval;
+
+	xenon_net_init_ring (dev); /* allocates ringbuffer, clears them */
+	xenon_net_hw_start (dev);  /* start HW */
+
+	return 0;
+}
+
+static int xenon_net_start_xmit (struct sk_buff *skb, struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+	int entry;
+	dma_addr_t mapping;
+	u32 len;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->lock, flags);
+
+	/* Calculate the next Tx descriptor entry. */
+	entry = atomic_read (&tp->tx_next_free) % TX_RING_SIZE;
+
+	BUG_ON (tp->tx_skbuff[entry] != NULL);
+	BUG_ON (tp->tx_skbuff_dma[entry] != 0);
+	BUG_ON (skb_shinfo(skb)->nr_frags != 0);
+
+	tp->tx_skbuff[entry] = skb;
+
+	len = skb->len;
+
+	mapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);
+	tp->tx_skbuff_dma[entry] = mapping;
+
+	xenon_set_tx_descriptor(tp, entry, skb->len, mapping, 1);
+
+	dev->trans_start = jiffies;
+	atomic_inc (&tp->tx_next_free);
+	if ((atomic_read (&tp->tx_next_free) - atomic_read (&tp->tx_next_done)) >= TX_RING_SIZE)
+		netif_stop_queue (dev);
+
+	writel(0x00101c11, ioaddr + TX_CONFIG); /* enable TX */
+
+	spin_unlock_irqrestore(&tp->lock, flags);
+
+	return 0;
+}
+
+static void xenon_net_tx_clear (struct xenon_net_private *tp)
+{
+	int i;
+
+	atomic_set (&tp->tx_next_free, 0);
+	atomic_set (&tp->tx_next_done, 0);
+
+	/* Dump the unsent Tx packets. */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		if (tp->tx_skbuff_dma[i] != 0) {
+			pci_unmap_single (tp->pdev, tp->tx_skbuff_dma[i],
+					  tp->tx_skbuff[i]->len, PCI_DMA_TODEVICE);
+		}
+		if (tp->tx_skbuff[i])
+		{
+			dev_kfree_skb (tp->tx_skbuff[i]);
+			tp->tx_skbuff[i] = NULL;
+			tp->stats.tx_dropped++;
+		}
+	}
+}
+
+static void xenon_net_tx_timeout (struct net_device *dev)
+{
+	/* Error handling was taken from eexpress.c */
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+	unsigned long flags;
+
+	writel(0, ioaddr + INTERRUPT_MASK);
+
+	disable_irq(dev->irq);
+
+	printk(KERN_INFO "%s: transmit timed out, reseting.\n", dev->name);
+
+	/* Stop a shared interrupt from scavenging while we are. */
+	spin_lock_irqsave(&tp->lock, flags);
+	xenon_net_tx_clear(tp);
+	xenon_net_hw_start(dev);
+	spin_unlock_irqrestore(&tp->lock, flags);
+	enable_irq(dev->irq);
+
+	dev->trans_start = jiffies;
+	tp->stats.tx_errors++;
+	netif_wake_queue(dev);
+}
+
+static int xenon_net_close (struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	netif_stop_queue (dev);
+	napi_disable(&tp->napi);
+	free_irq (dev->irq, dev);
+	xenon_net_tx_clear (tp);
+	pci_free_consistent(tp->pdev, TX_RING_SIZE * 0x10 + RX_RING_SIZE * 0x10,
+			    tp->tx_descriptor_base, tp->tx_descriptor_base_dma);
+	tp->tx_descriptor_base = NULL;
+	tp->rx_descriptor_base = NULL;
+
+	return 0;
+}
+
+
+static struct net_device_ops xenon_netdev_ops = {
+	.ndo_open 		= xenon_net_open,
+	.ndo_stop 		= xenon_net_close,
+	.ndo_start_xmit 	= xenon_net_start_xmit,
+//	.ndo_set_multicast_list = xenon_net_set_multicast_list,
+	.ndo_tx_timeout 	= xenon_net_tx_timeout,
+//	.ndo_set_mac_address	= xenon_net_set_mac,
+//	.ndo_change_mtu 	= xenon_net_change_mtu,
+	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+static int __devinit xenon_net_init_board (struct pci_dev *pdev,
+					 struct net_device **dev_out,
+					 void **ioaddr_out)
+{
+	void *ioaddr = NULL;
+	struct net_device *dev;
+	struct xenon_net_private *tp;
+	int rc, i;
+	unsigned long mmio_start, mmio_end, mmio_flags, mmio_len;
+
+	BUG_ON (pdev == NULL);
+	BUG_ON (ioaddr_out == NULL);
+
+	*ioaddr_out = NULL;
+	*dev_out = NULL;
+
+	/* dev zeroed in alloc_etherdev */
+	dev = alloc_etherdev (sizeof (*tp));
+	if (dev == NULL) {
+		dev_err(&pdev->dev, "unable to alloc new ethernet\n");
+		return -ENOMEM;
+	}
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	tp = netdev_priv(dev);
+
+	/* enable device (incl. PCI PM wakeup), and bus-mastering */
+	rc = pci_enable_device (pdev);
+	if (rc)
+		goto err_out;
+
+	mmio_start = pci_resource_start (pdev, 0);
+	mmio_end = pci_resource_end (pdev, 0);
+	mmio_flags = pci_resource_flags (pdev, 0);
+	mmio_len = pci_resource_len (pdev, 0);
+
+	/* make sure PCI base addr 0 is MMIO */
+	if (!(mmio_flags & IORESOURCE_MEM)) {
+		dev_err(&pdev->dev, "region #0 not an MMIO resource, aborting\n");
+		rc = -ENODEV;
+		goto err_out;
+	}
+
+	rc = pci_request_regions (pdev, MODNAME);
+	if (rc)
+		goto err_out;
+
+	pci_set_master (pdev);
+
+	/* ioremap MMIO region */
+	ioaddr = ioremap (mmio_start, mmio_len);
+	if (ioaddr == NULL) {
+		dev_err(&pdev->dev, "cannot remap MMIO, aborting\n");
+		rc = -EIO;
+		goto err_out_free_res;
+	}
+
+	dev->netdev_ops = &xenon_netdev_ops;
+	i = register_netdev(dev);
+	if (i)
+		goto err_out_unmap;
+
+	*ioaddr_out = ioaddr;
+	*dev_out = dev;
+	return 0;
+
+err_out_unmap:
+#ifndef USE_IO_OPS
+	iounmap(ioaddr);
+err_out_free_res:
+#endif
+	pci_release_regions (pdev);
+err_out:
+	free_netdev (dev);
+	return rc;
+}
+static int __devinit xenon_net_init_one (struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct net_device *dev = NULL;
+	struct xenon_net_private *tp;
+	int i;
+	void *ioaddr = NULL;
+
+/* when built into the kernel, we only print version if device is found */
+#ifndef MODULE
+	static int printed_version;
+	if (!printed_version++)
+		printk(version);
+#endif
+
+	BUG_ON (pdev == NULL);
+	BUG_ON (ent == NULL);
+
+
+	i = xenon_net_init_board (pdev, &dev, &ioaddr);
+	if (i < 0)
+		return i;
+
+	tp = netdev_priv(dev);
+
+	BUG_ON (ioaddr == NULL);
+	BUG_ON (dev == NULL);
+	BUG_ON (tp == NULL);
+
+//	random_ether_addr(dev->dev_addr);
+//	memcpy(dev->dev_addr, "\x00\x78\x65\x6E\6F\6E", 6);
+	memcpy(dev->dev_addr, "\x00\x01\x30\x44\x55\x66", 6);   /* same as xell */
+
+	tp->dev2 = dev;
+//	dev->ethtool_ops = &xenon_net_ethtool_ops;
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	netif_napi_add(dev, &tp->napi, xenon_net_poll, 64);
+
+	dev->irq = pdev->irq;
+	dev->base_addr = (unsigned long) ioaddr;
+
+	/* priv/tp zeroed and aligned in alloc_etherdev */
+	tp = netdev_priv(dev);
+
+	tp->pdev = pdev;
+	tp->mmio_addr = ioaddr;
+	spin_lock_init(&tp->lock);
+
+	pci_set_drvdata(pdev, dev);
+
+	printk (KERN_INFO "%s: at 0x%lx, "
+		"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+		"IRQ %d\n",
+		dev->name,
+		dev->base_addr,
+		dev->dev_addr[0], dev->dev_addr[1],
+		dev->dev_addr[2], dev->dev_addr[3],
+		dev->dev_addr[4], dev->dev_addr[5],
+		dev->irq);
+
+	return 0;
+}
+
+
+static void __devexit xenon_net_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata (pdev);
+	struct xenon_net_private *np;
+
+	BUG_ON (dev == NULL);
+
+	np = netdev_priv(dev);
+	BUG_ON (np == NULL);
+
+	unregister_netdev (dev);
+
+#ifndef USE_IO_OPS
+	iounmap (np->mmio_addr);
+#endif /* !USE_IO_OPS */
+
+	pci_release_regions (pdev);
+
+	free_netdev (dev);
+
+	pci_set_drvdata (pdev, NULL);
+
+	pci_disable_device (pdev);
+}
+
+
+
+static struct pci_driver xenon_net_pci_driver = {
+	.name		= MODNAME,
+	.id_table	= xenon_net_pci_tbl,
+	.probe		= xenon_net_init_one,
+	.remove		= __devexit_p(xenon_net_remove_one),
+};
+
+static int __init xenon_net_init_module (void)
+{
+/* when a module, this is printed whether or not devices are found in probe */
+#ifdef MODULE
+	printk(version);
+#endif
+	return pci_register_driver(&xenon_net_pci_driver);
+}
+
+
+static void __exit xenon_net_cleanup_module (void)
+{
+	pci_unregister_driver (&xenon_net_pci_driver);
+}
+
+
+module_init(xenon_net_init_module);
+module_exit(xenon_net_cleanup_module);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Felix Domke <tmbinc@elitedvb.net>");
+MODULE_DESCRIPTION("Xenon Southbridge Fast Ethernet Driver");
+
diff -NurpP --minimal linux-3.5.4/drivers/pci/probe.c linux-3.5.4-xenon/drivers/pci/probe.c
--- linux-3.5.4/drivers/pci/probe.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/pci/probe.c	2012-10-08 18:39:07.945017829 +0200
@@ -929,6 +929,8 @@ int pci_setup_device(struct pci_dev *dev
 	struct pci_bus_region region;
 	struct resource *res;
 
+	printk("pci_setup_device() [%p,%u,%04x:%04x]\n",
+		dev->bus, dev->devfn, dev->vendor, dev->device);
 	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))
 		return -EIO;
 
diff -NurpP --minimal linux-3.5.4/drivers/rtc/Kconfig linux-3.5.4-xenon/drivers/rtc/Kconfig
--- linux-3.5.4/drivers/rtc/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/rtc/Kconfig	2012-10-08 18:39:07.945017829 +0200
@@ -964,6 +964,16 @@ config RTC_DRV_PS3
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ps3.
 
+config RTC_DRV_XENON
+	tristate "Xenon RTC"
+	depends on PPC_XENON
+	help
+	  If you say yes here you will get support for the RTC on the
+	  Xbox 360.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-xenon.
+
 config RTC_DRV_COH901331
 	tristate "ST-Ericsson COH 901 331 RTC"
 	depends on ARCH_U300
diff -NurpP --minimal linux-3.5.4/drivers/rtc/Makefile linux-3.5.4-xenon/drivers/rtc/Makefile
--- linux-3.5.4/drivers/rtc/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/rtc/Makefile	2012-10-08 18:39:07.945017829 +0200
@@ -111,3 +111,4 @@ obj-$(CONFIG_RTC_DRV_VT8500)	+= rtc-vt85
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_XENON)	+= rtc-xenon.o
diff -NurpP --minimal linux-3.5.4/drivers/rtc/rtc-xenon.c linux-3.5.4-xenon/drivers/rtc/rtc-xenon.c
--- linux-3.5.4/drivers/rtc/rtc-xenon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/rtc/rtc-xenon.c	2012-10-08 18:39:07.945017829 +0200
@@ -0,0 +1,134 @@
+/*
+ *  Xenon RTC via SMC driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+
+
+#define DRV_NAME	"rtc-xenon"
+#define DRV_VERSION	"0.1"
+
+	/* for whatever reason, 15.Nov.2001 00:00 GMT */
+#define	RTC_BASE	1005782400UL
+
+
+int xenon_smc_message_wait(void *msg);
+
+static unsigned long xenon_get_rtc(void)
+{
+	unsigned char msg[16] = { 0x04 };
+	unsigned long msec;
+
+	xenon_smc_message_wait(msg);
+	msec = msg[1] | (msg[2] << 8) | (msg[3] << 16) |
+		(msg[4] << 24) | ((unsigned long)msg[5] << 32);
+	return RTC_BASE + msec/1000;
+}
+
+void xenon_smc_message(void *msg);
+
+static int xenon_set_rtc(unsigned long secs)
+{
+	unsigned long msec = (secs - RTC_BASE) * 1000;
+	unsigned char msg[16] = {
+		0x85, msec & 0xFF, (msec >> 8) & 0xFF,
+		(msec >> 16) & 0xFF, (msec >> 24) & 0xFF,
+		(msec >> 32) & 0xFF };
+
+	xenon_smc_message(msg);
+	return 0;
+}
+
+static int xenon_read_time(struct device *dev, struct rtc_time *tm)
+{
+	rtc_time_to_tm(xenon_get_rtc(), tm);
+	return 0;
+}
+
+
+static int xenon_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long msec;
+	int err;
+
+	err = rtc_tm_to_time(tm, &msec);
+	if (err)
+		return err;
+
+	return xenon_set_rtc(msec);
+}
+
+static const struct rtc_class_ops xenon_rtc_ops = {
+	.read_time	= xenon_read_time,
+	.set_time	= xenon_set_time,
+};
+
+static int __init xenon_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = rtc_device_register(DRV_NAME, &pdev->dev,
+				     &xenon_rtc_ops, THIS_MODULE);
+
+	printk("xenon_rtc_probe(%p) = %p\n", pdev, rtc);
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	platform_set_drvdata(pdev, rtc);
+	return 0;
+}
+
+static int __exit xenon_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(rtc);
+	return 0;
+}
+
+static struct platform_driver xenon_rtc_driver = {
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(xenon_rtc_remove),
+};
+
+static int __init xenon_rtc_init(void)
+{
+	int ret = platform_driver_probe(&xenon_rtc_driver, xenon_rtc_probe);
+
+	printk("xenon_rtc_init() = %d\n", ret);
+	return ret;
+	// return platform_driver_probe(&xenon_rtc_driver, xenon_rtc_probe);
+}
+
+static void __exit xenon_rtc_exit(void)
+{
+	platform_driver_unregister(&xenon_rtc_driver);
+}
+
+module_init(xenon_rtc_init);
+module_exit(xenon_rtc_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Xenon RTC driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+MODULE_ALIAS("platform:rtc-xenon");
diff -NurpP --minimal linux-3.5.4/drivers/scsi/scsi_scan.c linux-3.5.4-xenon/drivers/scsi/scsi_scan.c
--- linux-3.5.4/drivers/scsi/scsi_scan.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/scsi/scsi_scan.c	2012-10-08 18:39:07.945017829 +0200
@@ -583,6 +583,7 @@ static int scsi_probe_lun(struct scsi_de
 		memset(scsi_cmd, 0, 6);
 		scsi_cmd[0] = INQUIRY;
 		scsi_cmd[4] = (unsigned char) try_inquiry_len;
+		scsi_cmd[5] = 0xc0; /* HACK */
 
 		memset(inq_result, 0, try_inquiry_len);
 
diff -NurpP --minimal linux-3.5.4/drivers/tty/serial/Kconfig linux-3.5.4-xenon/drivers/tty/serial/Kconfig
--- linux-3.5.4/drivers/tty/serial/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/tty/serial/Kconfig	2012-10-08 18:39:07.945017829 +0200
@@ -1360,4 +1360,22 @@ config SERIAL_EFM32_UART_CONSOLE
 	depends on SERIAL_EFM32_UART=y
 	select SERIAL_CORE_CONSOLE
 
+config SERIAL_XENON
+	tristate "Xenon XBOX 360 serial port support"
+	select SERIAL_CORE
+	help
+	  If you have an XBOX 360, you can enable its onboard
+	  serial port by enabling this options.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called xenon_uart.
+
+config SERIAL_XENON_CONSOLE
+	bool "Console on XBOX 360 serial port"
+	depends on SERIAL_XENON=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you have enabled the serial port on the XBOX 360
+	  you can make it the console by answering Y to this option.
+
 endmenu
diff -NurpP --minimal linux-3.5.4/drivers/tty/serial/Makefile linux-3.5.4-xenon/drivers/tty/serial/Makefile
--- linux-3.5.4/drivers/tty/serial/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/tty/serial/Makefile	2012-10-08 18:39:07.945017829 +0200
@@ -72,6 +72,7 @@ obj-$(CONFIG_SERIAL_MRST_MAX3110)	+= mrs
 obj-$(CONFIG_SERIAL_MFD_HSU)	+= mfd.o
 obj-$(CONFIG_SERIAL_IFX6X60)  	+= ifx6x60.o
 obj-$(CONFIG_SERIAL_PCH_UART)	+= pch_uart.o
+obj-$(CONFIG_SERIAL_XENON)	+= xenon_uart.o
 obj-$(CONFIG_SERIAL_MSM_SMD)	+= msm_smd_tty.o
 obj-$(CONFIG_SERIAL_MXS_AUART) += mxs-auart.o
 obj-$(CONFIG_SERIAL_LANTIQ)	+= lantiq.o
diff -NurpP --minimal linux-3.5.4/drivers/tty/serial/xenon_uart.c linux-3.5.4-xenon/drivers/tty/serial/xenon_uart.c
--- linux-3.5.4/drivers/tty/serial/xenon_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/tty/serial/xenon_uart.c	2012-10-08 18:39:07.945017829 +0200
@@ -0,0 +1,418 @@
+/* linux/drivers/serial/xenon.c
+ *
+ * Driver for Xenon XBOX 360 Serial
+ *
+ * Copyright (C) 2010 Herbert Poetzl
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/io.h>
+
+#if 0
+#define	dprintk(f, x...) do {				\
+		printk(KERN_DEBUG f "\n" , ##x);	\
+	} while (0)
+#else
+#define dprintk(f, x...) do { } while (0)
+#endif
+
+
+static int xenon_status(unsigned char __iomem *membase)
+{
+	// return ((*(volatile uint32_t*)0x80000200ea001018) & 0x02000000);
+	return (*(volatile uint32_t*)(membase + 0x08));
+}
+
+static void xenon_putch(unsigned char __iomem *membase, int ch)
+{
+	/* wait for tx fifo ready */
+	while (!(xenon_status(membase) & 0x02000000));
+
+	/* put character into fifo */
+	// *(volatile uint32_t*)0x80000200ea001014 = (ch << 24) & 0xFF000000;
+	*(volatile uint32_t*)(membase + 0x04) = (ch << 24) & 0xFF000000;
+}
+
+static int xenon_getch(unsigned char __iomem *membase)
+{
+	uint32_t status;
+
+	/* wait for data ready */
+	while ((status = xenon_status(membase)) & ~0x03000000);
+
+	if (status & 0x01000000)
+		return *(volatile uint32_t*)(membase + 0x00) >> 24;
+	return -1;
+}
+
+
+
+static void xenon_stop_rx(struct uart_port *port)
+{
+	dprintk("Xenon xenon_stop_rx()");
+}
+
+static void xenon_enable_ms(struct uart_port *port)
+{
+	dprintk("Xenon xenon_enable_ms()");
+}
+
+static void xenon_stop_tx(struct uart_port *port)
+{
+	dprintk("Xenon xenon_stop_tx()");
+}
+
+static void xenon_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	// int count;
+
+	if (port->x_char) {
+		xenon_putch(port->membase, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		xenon_stop_tx(port);
+		return;
+	}
+
+#if 0
+	count = port->fifosize >> 1;
+	do {
+		xenon_putch(port->membase, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+#else
+	while (!uart_circ_empty(xmit)) {
+		xenon_putch(port->membase, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+#endif
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		xenon_stop_tx(port);
+}
+
+static void xenon_start_tx(struct uart_port *port)
+{
+	dprintk("Xenon xenon_start_tx()");
+	xenon_tx_chars(port);
+}
+
+
+#if 0
+static void xenon_send_xchar(struct uart_port *port, char ch)
+{
+	dprintk("Xenon xenon_send_xchar(%d)", ch);
+	xenon_putch(port->membase, ch);
+}
+#endif
+
+static unsigned int xenon_tx_empty(struct uart_port *port)
+{
+	dprintk("Xenon xenon_tx_empty()");
+	return 0;
+}
+
+static unsigned int xenon_get_mctrl(struct uart_port *port)
+{
+	dprintk("Xenon xenon_get_mctrl()");
+	return 0;
+}
+
+static void xenon_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	dprintk("Xenon xenon_set_mctrl()");
+}
+
+static void xenon_break_ctl(struct uart_port *port, int break_state)
+{
+	dprintk("Xenon xenon_break_ctl()");
+}
+
+static void xenon_set_termios(struct uart_port *port,
+			     struct ktermios *new, struct ktermios *old)
+{
+	int baud, quot, cflag = new->c_cflag;
+
+	dprintk("Xenon xenon_set_termios()");
+	/* get the byte size */
+	switch (cflag & CSIZE) {
+	case CS5:
+		dprintk(" - data bits = 5");
+		break;
+	case CS6:
+		dprintk(" - data bits = 6");
+		break;
+	case CS7:
+		dprintk(" - data bits = 7");
+		break;
+	default: // CS8
+		dprintk(" - data bits = 8");
+		break;
+	}
+
+	/* determine the parity */
+	if (cflag & PARENB)
+		if (cflag & PARODD)
+			pr_debug(" - parity = odd\n");
+		else
+			pr_debug(" - parity = even\n");
+	else
+		pr_debug(" - parity = none\n");
+
+	/* figure out the stop bits requested */
+	if (cflag & CSTOPB)
+		pr_debug(" - stop bits = 2\n");
+	else
+		pr_debug(" - stop bits = 1\n");
+
+	/* figure out the flow control settings */
+	if (cflag & CRTSCTS)
+		pr_debug(" - RTS/CTS is enabled\n");
+	else
+		pr_debug(" - RTS/CTS is disabled\n");
+
+	/* Set baud rate */
+	baud = uart_get_baud_rate(port, new, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+}
+
+static int xenon_startup(struct uart_port *port)
+{
+	dprintk("Xenon xenon_startup()");
+	/* this is the first time this port is opened */
+	/* do any hardware initialization needed here */
+	return 0;
+}
+
+static void xenon_shutdown(struct uart_port *port)
+{
+	dprintk("Xenon xenon_shutdown()");
+	/* The port is being closed by the last user. */
+	/* Do any hardware specific stuff here */
+}
+
+static const char *xenon_type(struct uart_port *port)
+{
+	return "Xenon SMC";
+}
+
+static void xenon_release_port(struct uart_port *port)
+{
+	dprintk("Xenon xenon_release_port()");
+}
+
+static int xenon_request_port(struct uart_port *port)
+{
+	dprintk("Xenon xenon_request_port()");
+	return 0;
+}
+
+static void xenon_config_port(struct uart_port *port, int flags)
+{
+	dprintk("Xenon xenon_config_port()");
+
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_XENON;
+	}
+}
+
+static int xenon_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	dprintk("Xenon xenon_verify_port()");
+	return 0;
+}
+
+
+#ifdef CONFIG_CONSOLE_POLL
+
+static int xenon_poll_get_char(struct uart_port *port)
+{
+	return xenon_getch(port->membase);
+}
+
+static void xenon_poll_put_char(struct uart_port *port, unsigned char c)
+{
+	xenon_putch(port->membase, c);
+}
+
+#endif
+
+
+static struct uart_ops xenon_ops = {
+	.tx_empty	= xenon_tx_empty,
+	.set_mctrl	= xenon_set_mctrl,
+	.get_mctrl	= xenon_get_mctrl,
+	.stop_tx	= xenon_stop_tx,
+	.start_tx	= xenon_start_tx,
+//	.send_xchar	= xenon_send_xchar,
+	.stop_rx	= xenon_stop_rx,
+	.enable_ms	= xenon_enable_ms,
+	.break_ctl	= xenon_break_ctl,
+	.startup	= xenon_startup,
+	.shutdown	= xenon_shutdown,
+//	.flush_buffer	= xenon_flush_buffer,
+	.set_termios	= xenon_set_termios,
+//	.set_ldisc	= xenon_set_ldisc,
+//	.pm		= xenon_pm,
+//	.set_wake	= xenon_set_wake,
+	.type		= xenon_type,
+	.release_port	= xenon_release_port,
+	.request_port	= xenon_request_port,
+	.config_port	= xenon_config_port,
+	.verify_port	= xenon_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char	= xenon_poll_put_char,
+	.poll_get_char	= xenon_poll_get_char,
+#endif
+};
+
+static struct uart_port xenon_port = {
+	.type		= PORT_XENON,
+	.ops		= &xenon_ops,
+	.flags		= UPF_FIXED_TYPE | UPF_IOREMAP,
+	.mapbase	= 0x200ea001010ULL,
+	.iotype         = UPIO_MEM,
+	.uartclk	= 1843200,
+};
+
+static struct console xenon_console;
+
+static struct uart_driver xenon_reg = {
+	.owner  	= THIS_MODULE,
+	.driver_name	= "xenon_uart",
+	.dev_name	= "ttyS",
+	.major  	= TTY_MAJOR,
+	.minor  	= 64,
+	.nr		= 1,
+#ifdef	CONFIG_SERIAL_XENON_CONSOLE
+	.cons		= &xenon_console,
+#endif
+};
+
+
+static int __init xenon_init(void)
+{
+	int result;
+
+	printk(KERN_INFO "Xenon XBOX 360 serial driver\n");
+
+	result = uart_register_driver(&xenon_reg);
+	dprintk("Xenon uart_register_driver() = %d", result);
+	if (result)
+		return result;
+
+	xenon_port.membase = ioremap_nocache(xenon_port.mapbase, 0x10);
+
+	result = uart_add_one_port(&xenon_reg, &xenon_port);
+	dprintk("Xenon uart_add_one_port() = %d", result);
+	if (result)
+		uart_unregister_driver(&xenon_reg);
+
+	return result;
+}
+
+static void __exit xenon_exit(void)
+{
+	printk(KERN_INFO "Xenon XBOX 360 serial driver exit\n");
+	uart_remove_one_port(&xenon_reg, &xenon_port);
+	uart_unregister_driver(&xenon_reg);
+}
+
+module_init(xenon_init);
+module_exit(xenon_exit);
+
+
+#ifdef CONFIG_SERIAL_XENON_CONSOLE
+
+static void xenon_console_putchar(struct uart_port *port, int ch)
+{
+	xenon_putch(port->membase, ch);
+}
+
+/*
+ * Print a string to the serial port trying not to disturb
+ * any possible real use of the port...
+ */
+static void xenon_console_write(struct console *cons,
+	const char *s, unsigned int count)
+{
+	uart_console_write(&xenon_port, s, count, xenon_console_putchar);
+}
+
+/*
+ * Setup serial console baud/bits/parity.  We do two things here:
+ * - construct a cflag setting for the first uart_open()
+ * - initialise the serial port
+ * Return non-zero if we didn't find a serial port.
+ */
+static int __init xenon_console_setup(struct console *cons, char *options)
+{
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+#if 0
+	ret = xenon_map_port(uport);
+	if (ret)
+		return ret;
+
+	xenon_reset(port);
+	xenon_pm(port, 0, -1);
+#endif
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	return uart_set_options(&xenon_port, cons, baud, parity, bits, flow);
+}
+
+static struct console xenon_console = {
+	.name	= "ttyS",
+	.write	= xenon_console_write,
+	.device	= uart_console_device,
+	.setup	= xenon_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &xenon_reg,
+};
+
+static int __init xenon_serial_console_init(void)
+{
+	xenon_port.membase = ioremap_nocache(xenon_port.mapbase, 0x10);
+
+	register_console(&xenon_console);
+	return 0;
+}
+
+console_initcall(xenon_serial_console_init);
+
+#endif /* CONFIG_SERIAL_XENON_CONSOLE */
+
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Xenon XBOX 360 Serial port driver");
+MODULE_LICENSE("GPL v2");
+// MODULE_ALIAS("platform:xenon-uart");
diff -NurpP --minimal linux-3.5.4/drivers/video/cfbimgblt.c linux-3.5.4-xenon/drivers/video/cfbimgblt.c
--- linux-3.5.4/drivers/video/cfbimgblt.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/video/cfbimgblt.c	2012-10-08 18:39:07.945017829 +0200
@@ -69,9 +69,17 @@ static const u32 cfb_tab32[] = {
 	0x00000000, 0xffffffff
 };
 
+#if 0
 #define FB_WRITEL fb_writel
 #define FB_READL  fb_readl
 
+#define FB_WRITEL(p,b,addr) fb_writel(b,addr)
+#define FB_READL(p,addr)  fb_readl(addr)
+#else
+#define FB_READL(p,addr)  fb_readl(xenon_convert(p, addr))
+#define FB_WRITEL(p,b,addr) fb_writel(b, xenon_convert(p, addr))
+#endif
+
 static inline void color_imageblit(const struct fb_image *image, 
 				   struct fb_info *p, u8 __iomem *dst1, 
 				   u32 start_index,
@@ -96,7 +104,7 @@ static inline void color_imageblit(const
 		if (start_index) {
 			u32 start_mask = ~fb_shifted_pixels_mask_u32(p,
 						start_index, bswapmask);
-			val = FB_READL(dst) & start_mask;
+			val = FB_READL(p, dst) & start_mask;
 			shift = start_index;
 		}
 		while (n--) {
@@ -108,7 +116,7 @@ static inline void color_imageblit(const
 			color <<= FB_LEFT_POS(p, bpp);
 			val |= FB_SHIFT_HIGH(p, color, shift ^ bswapmask);
 			if (shift >= null_bits) {
-				FB_WRITEL(val, dst++);
+				FB_WRITEL(p, val, dst++);
 	
 				val = (shift == null_bits) ? 0 : 
 					FB_SHIFT_LOW(p, color, 32 - shift);
@@ -121,7 +129,7 @@ static inline void color_imageblit(const
 			u32 end_mask = fb_shifted_pixels_mask_u32(p, shift,
 						bswapmask);
 
-			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
+			FB_WRITEL(p, (FB_READL(p, dst) & end_mask) | val, dst);
 		}
 		dst1 += p->fix.line_length;
 		if (pitch_index) {
@@ -164,7 +172,7 @@ static inline void slow_imageblit(const
 		if (start_index) {
 			u32 start_mask = ~fb_shifted_pixels_mask_u32(p,
 						start_index, bswapmask);
-			val = FB_READL(dst) & start_mask;
+			val = FB_READL(p, dst) & start_mask;
 			shift = start_index;
 		}
 
@@ -175,7 +183,7 @@ static inline void slow_imageblit(const
 			
 			/* Did the bitshift spill bits to the next long? */
 			if (shift >= null_bits) {
-				FB_WRITEL(val, dst++);
+				FB_WRITEL(p, val, dst++);
 				val = (shift == null_bits) ? 0 :
 					FB_SHIFT_LOW(p, color, 32 - shift);
 			}
@@ -189,7 +197,7 @@ static inline void slow_imageblit(const
 			u32 end_mask = fb_shifted_pixels_mask_u32(p, shift,
 						bswapmask);
 
-			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
+			FB_WRITEL(p, (FB_READL(p, dst) & end_mask) | val, dst);
 		}
 		
 		dst1 += pitch;
@@ -254,7 +262,7 @@ static inline void fast_imageblit(const
 		for (j = k; j--; ) {
 			shift -= ppw;
 			end_mask = tab[(*src >> shift) & bit_mask];
-			FB_WRITEL((end_mask & eorx)^bgx, dst++);
+			FB_WRITEL(p, (end_mask & eorx)^bgx, dst++);
 			if (!shift) { shift = 8; src++; }		
 		}
 		dst1 += p->fix.line_length;
diff -NurpP --minimal linux-3.5.4/drivers/video/Kconfig linux-3.5.4-xenon/drivers/video/Kconfig
--- linux-3.5.4/drivers/video/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/video/Kconfig	2012-10-08 18:39:07.945017829 +0200
@@ -789,6 +789,15 @@ config FB_N411
          This enables support for the Apollo display controller in its
          Hecuba form using the n411 devkit.
 
+config FB_XENON
+	bool "Xbox 360 Framebuffer Support"
+	depends on (FB = y) && PPC
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the Microsoft Xbox 360.
+
 config FB_HGA
 	tristate "Hercules mono graphics support"
 	depends on FB && X86
diff -NurpP --minimal linux-3.5.4/drivers/video/Makefile linux-3.5.4-xenon/drivers/video/Makefile
--- linux-3.5.4/drivers/video/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/drivers/video/Makefile	2012-10-08 18:39:07.945017829 +0200
@@ -154,6 +154,7 @@ obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
 obj-$(CONFIG_FB_VESA)             += vesafb.o
 obj-$(CONFIG_FB_EFI)              += efifb.o
+obj-$(CONFIG_FB_XENON)            += xenonfb.o
 obj-$(CONFIG_FB_VGA16)            += vga16fb.o
 obj-$(CONFIG_FB_OF)               += offb.o
 obj-$(CONFIG_FB_BF537_LQ035)      += bf537-lq035.o
diff -NurpP --minimal linux-3.5.4/drivers/video/xenonfb.c linux-3.5.4-xenon/drivers/video/xenonfb.c
--- linux-3.5.4/drivers/video/xenonfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/video/xenonfb.c	2012-10-08 18:39:07.945017829 +0200
@@ -0,0 +1,379 @@
+/*
+ * framebuffer driver for Microsoft Xbox 360
+ *
+ * (c) 2006 ...
+ * Original vesafb driver written by Gerd Knorr <kraxel@goldbach.in-berlin.de>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/screen_info.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/dmi.h>
+
+#include <asm/io.h>
+
+#include <video/vga.h>
+
+/* --------------------------------------------------------------------- */
+
+static struct fb_var_screeninfo xenonfb_defined __initdata = {
+	.activate		= FB_ACTIVATE_NOW,
+	.height			= -1,
+	.width			= -1,
+	.right_margin		= 32,
+	.upper_margin		= 16,
+	.lower_margin		= 4,
+	.vsync_len		= 4,
+	.vmode			= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo xenonfb_fix __initdata = {
+	.id			= "XENON FB",
+	.type			= FB_TYPE_PACKED_PIXELS,
+	.accel			= FB_ACCEL_NONE,
+	.visual			= FB_VISUAL_TRUECOLOR,
+};
+
+typedef struct {
+	uint32_t unknown1[4];
+	uint32_t base;
+	uint32_t unknown2[8];
+	uint32_t width;
+	uint32_t height;
+} ati_info;
+
+#define	DEFAULT_FB_MEM	1024*1024*16
+
+/* --------------------------------------------------------------------- */
+
+static int xenonfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			    unsigned blue, unsigned transp,
+			    struct fb_info *info)
+{
+	/*
+	 *  Set a single color register. The values supplied are
+	 *  already rounded down to the hardware's capabilities
+	 *  (according to the entries in the `var' structure). Return
+	 *  != 0 for invalid regno.
+	 */
+
+	if (regno >= info->cmap.len)
+		return 1;
+
+	if (regno < 16) {
+		red   >>= 8;
+		green >>= 8;
+		blue  >>= 8;
+		((u32 *)(info->pseudo_palette))[regno] =
+			(red   << info->var.red.offset)   |
+			(green << info->var.green.offset) |
+			(blue  << info->var.blue.offset);
+	}
+	return 0;
+}
+
+#define XENON_XY_TO_STD_PTR(x,y) ((int*)(((char*)p->screen_base)+y*p->fix.line_length+x*(p->var.bits_per_pixel/8)))
+#define XENON_XY_TO_XENON_PTR(x,y) xenon_convert(p, XENON_XY_TO_STD_PTR(x,y))
+
+inline void xenon_pset(struct fb_info *p, int x, int y, int color)
+{
+	fb_writel(color, XENON_XY_TO_XENON_PTR(x,y));
+}
+
+inline int xenon_pget(struct fb_info *p, int x, int y)
+{
+	return fb_readl(XENON_XY_TO_XENON_PTR(x,y));
+}
+
+void xenon_fillrect(struct fb_info *p, const struct fb_fillrect *rect)
+{
+
+	__u32 x, y;
+	for (y=0; y<rect->height; y++) {
+		for (x=0; x<rect->width; x++) {
+			xenon_pset(p, rect->dx+x, rect->dy+y, rect->color);
+
+		}
+	}
+}
+
+void xenon_copyarea(struct fb_info *p, const struct fb_copyarea *area)
+{
+
+	/* if the beginning of the target area might overlap with the end of
+	the source area, be have to copy the area reverse. */
+	if ((area->dy == area->sy && area->dx > area->sx) || (area->dy > area->sy)) {
+		__s32 x, y;
+		for (y=area->height-1; y>0; y--) {
+			for (x=area->width-1; x>0; x--) {
+				xenon_pset(p, area->dx+x, area->dy+y, xenon_pget(p, area->sx+x, area->sy+y));
+			}
+		}
+	} else {
+		__u32 x, y;
+		for (y=0; y<area->height; y++) {
+			for (x=0; x<area->width; x++) {
+				xenon_pset(p, area->dx+x, area->dy+y, xenon_pget(p, area->sx+x, area->sy+y));
+			}
+		}
+	}
+}
+
+static struct fb_ops xenonfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= xenonfb_setcolreg,
+	.fb_fillrect	= xenon_fillrect,
+	.fb_copyarea	= xenon_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+static int __init xenonfb_probe(struct platform_device *dev)
+{
+	struct fb_info *info;
+	int err;
+	unsigned int size_vmode;
+	unsigned int size_remap;
+	unsigned int size_total;
+
+	volatile int *gfx = ioremap(0x200ec806000ULL, 0x1000);
+
+	volatile ati_info *ai = ((void*)gfx) + 0x100;
+
+			/* setup native resolution, i.e. disable scaling */
+	int vxres = gfx[0x134/4];
+	int vyres = gfx[0x138/4];
+
+	int black_top = gfx[0x44/4];
+	int offset = gfx[0x580/4];
+	int offset_x = (offset >> 16) & 0xFFFF;
+	int offset_y = offset & 0xFFFF;
+
+	int nxres, nyres;
+	int scl_h = gfx[0x5b4/4], scl_v = gfx[0x5c4/4];
+
+	if (gfx[0x590/4] == 0)
+		scl_h = scl_v = 0x01000000;
+
+	nxres = (vxres - offset_x * 2) * 0x1000 / (scl_h/0x1000);
+	nyres = (vyres - offset_y * 2) * 0x1000 / (scl_v/0x1000) + black_top * 2;
+
+
+	printk("virtual resolution: %d x %d\n", vxres, vyres);
+	printk("offset: x=%d, y=%d\n", offset_x, offset_y);
+	printk("black: %d %d, %d %d\n",
+		gfx[0x44/4], gfx[0x48/4], gfx[0x4c/4], gfx[0x50/4]);
+
+	printk("native resolution: %d x %d\n", nxres, nyres);
+
+	screen_info.lfb_depth = 32;
+	screen_info.lfb_size = DEFAULT_FB_MEM / 0x10000;
+	screen_info.pages=1;
+	screen_info.blue_size = 8;
+	screen_info.blue_pos = 24;
+	screen_info.green_size = 8;
+	screen_info.green_pos = 16;
+	screen_info.red_size = 8;
+	screen_info.red_pos = 8;
+	screen_info.rsvd_size = 8;
+	screen_info.rsvd_pos = 0;
+
+	gfx[0x44/4] = 0; // disable black bar
+	gfx[0x48/4] = 0;
+	gfx[0x4c/4] = 0;
+	gfx[0x50/4] = 0;
+
+	gfx[0x590/4] = 0; // disable scaling
+	gfx[0x584/4] = (nxres << 16) | nyres;
+	gfx[0x580/4] = 0; // disable offset
+	gfx[0x5e8/4] = (nxres * 4) / 0x10 - 1; // fix pitch
+	gfx[0x134/4] = nxres;
+	gfx[0x138/4] = nyres;
+
+	ai->base &= ~0xFFFF; // page-align.
+
+	screen_info.lfb_base = ai->base;
+	screen_info.lfb_width = ai->width;
+	screen_info.lfb_height = ai->height;
+	screen_info.lfb_linelength = screen_info.lfb_width * screen_info.lfb_depth/4;
+
+	gfx[0x120/4] = screen_info.lfb_linelength / 8; /* fixup pitch, in case we switched resolution */
+
+	printk(KERN_INFO "xenonfb: detected %dx%d framebuffer @ 0x%08x\n", screen_info.lfb_width, screen_info.lfb_height, screen_info.lfb_base);
+
+	iounmap(gfx);
+
+	xenonfb_fix.smem_start = screen_info.lfb_base;
+	xenonfb_defined.bits_per_pixel = screen_info.lfb_depth;
+	xenonfb_defined.xres = screen_info.lfb_width;
+	xenonfb_defined.yres = screen_info.lfb_height;
+	xenonfb_defined.xoffset = 0;
+	xenonfb_defined.yoffset = 0;
+	xenonfb_fix.line_length = screen_info.lfb_linelength;
+
+	/*   size_vmode -- that is the amount of memory needed for the
+	 *                 used video mode, i.e. the minimum amount of
+	 *                 memory we need. */
+	size_vmode = xenonfb_defined.yres * xenonfb_fix.line_length;
+
+	/*   size_total -- all video memory we have. Used for
+	 *                 entries, ressource allocation and bounds
+	 *                 checking. */
+	size_total = screen_info.lfb_size * 65536;
+	if (size_total < size_vmode)
+		size_total = size_vmode;
+
+	/*   size_remap -- the amount of video memory we are going to
+	 *                 use for xenonfb.  With modern cards it is no
+	 *                 option to simply use size_total as that
+	 *                 wastes plenty of kernel address space. */
+	size_remap  = size_vmode * 2;
+	if (size_remap < size_vmode)
+		size_remap = size_vmode;
+	if (size_remap > size_total)
+		size_remap = size_total;
+	xenonfb_fix.smem_len = size_remap;
+
+	if (!request_mem_region(xenonfb_fix.smem_start, size_total, "xenonfb")) {
+		printk(KERN_WARNING
+		       "xenonfb: cannot reserve video memory at 0x%lx\n",
+			xenonfb_fix.smem_start);
+		/* We cannot make this fatal. Sometimes this comes from magic
+		   spaces our resource handlers simply don't know about */
+	}
+
+	info = framebuffer_alloc(sizeof(u32) * 16, &dev->dev);
+	if (!info) {
+		err = -ENOMEM;
+		goto err_release_mem;
+	}
+	info->pseudo_palette = info->par;
+	info->par = NULL;
+
+	info->screen_base = ioremap(xenonfb_fix.smem_start, xenonfb_fix.smem_len);
+	if (!info->screen_base) {
+		printk(KERN_ERR "xenonfb: abort, cannot ioremap video memory "
+				"0x%x @ 0x%lx\n",
+			xenonfb_fix.smem_len, xenonfb_fix.smem_start);
+		err = -EIO;
+		goto err_unmap;
+	}
+
+	printk(KERN_INFO "xenonfb: framebuffer at 0x%lx, mapped to 0x%p, "
+	       "using %dk, total %dk\n",
+	       xenonfb_fix.smem_start, info->screen_base,
+	       size_remap/1024, size_total/1024);
+	printk(KERN_INFO "xenonfb: mode is %dx%dx%d, linelength=%d, pages=%d\n",
+	       xenonfb_defined.xres, xenonfb_defined.yres,
+	       xenonfb_defined.bits_per_pixel, xenonfb_fix.line_length,
+	       screen_info.pages);
+
+	xenonfb_defined.xres_virtual = xenonfb_defined.xres;
+	xenonfb_defined.yres_virtual = xenonfb_fix.smem_len /
+					xenonfb_fix.line_length;
+	printk(KERN_INFO "xenonfb: scrolling: redraw\n");
+	xenonfb_defined.yres_virtual = xenonfb_defined.yres;
+
+	/* some dummy values for timing to make fbset happy */
+	xenonfb_defined.pixclock     = 10000000 / xenonfb_defined.xres *
+					1000 / xenonfb_defined.yres;
+	xenonfb_defined.left_margin  = (xenonfb_defined.xres / 8) & 0xf8;
+	xenonfb_defined.hsync_len    = (xenonfb_defined.xres / 8) & 0xf8;
+
+	printk(KERN_INFO "xenonfb: pixclk=%ld left=%02x hsync=%02x\n",
+		(unsigned long)xenonfb_defined.pixclock,
+		xenonfb_defined.left_margin,
+		xenonfb_defined.hsync_len);
+
+	xenonfb_defined.red.offset    = screen_info.red_pos;
+	xenonfb_defined.red.length    = screen_info.red_size;
+	xenonfb_defined.green.offset  = screen_info.green_pos;
+	xenonfb_defined.green.length  = screen_info.green_size;
+	xenonfb_defined.blue.offset   = screen_info.blue_pos;
+	xenonfb_defined.blue.length   = screen_info.blue_size;
+	xenonfb_defined.transp.offset = screen_info.rsvd_pos;
+	xenonfb_defined.transp.length = screen_info.rsvd_size;
+
+	printk(KERN_INFO "xenonfb: %s: "
+	       "size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",
+	       "Truecolor",
+	       screen_info.rsvd_size,
+	       screen_info.red_size,
+	       screen_info.green_size,
+	       screen_info.blue_size,
+	       screen_info.rsvd_pos,
+	       screen_info.red_pos,
+	       screen_info.green_pos,
+	       screen_info.blue_pos);
+
+	xenonfb_fix.ypanstep  = 0;
+	xenonfb_fix.ywrapstep = 0;
+
+	/* request failure does not faze us, as vgacon probably has this
+	 * region already (FIXME) */
+	request_region(0x3c0, 32, "xenonfb");
+
+	info->fbops = &xenonfb_ops;
+	info->var = xenonfb_defined;
+	info->fix = xenonfb_fix;
+	info->flags = FBINFO_FLAG_DEFAULT;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		err = -ENOMEM;
+		goto err_unmap;
+	}
+	if (register_framebuffer(info)<0) {
+		err = -EINVAL;
+		goto err_fb_dealoc;
+	}
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+	       info->node, info->fix.id);
+	return 0;
+
+err_fb_dealoc:
+	fb_dealloc_cmap(&info->cmap);
+err_unmap:
+	iounmap(info->screen_base);
+	framebuffer_release(info);
+err_release_mem:
+	release_mem_region(xenonfb_fix.smem_start, size_total);
+	return err;
+}
+
+static struct platform_driver xenonfb_driver = {
+	.probe	= xenonfb_probe,
+	.driver	= {
+		.name	= "xenonfb",
+	},
+};
+
+static struct platform_device xenonfb_device = {
+	.name	= "xenonfb",
+};
+
+static int __init xenonfb_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&xenonfb_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&xenonfb_device);
+		if (ret)
+			platform_driver_unregister(&xenonfb_driver);
+	}
+	return ret;
+}
+module_init(xenonfb_init);
+
+MODULE_LICENSE("GPL");
+
diff -NurpP --minimal linux-3.5.4/drivers/xenon/Makefile linux-3.5.4-xenon/drivers/xenon/Makefile
--- linux-3.5.4/drivers/xenon/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/xenon/Makefile	2012-10-08 18:39:07.949017856 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_PPC_XENON) += smc-core.o
diff -NurpP --minimal linux-3.5.4/drivers/xenon/smc-core.c linux-3.5.4-xenon/drivers/xenon/smc-core.c
--- linux-3.5.4/drivers/xenon/smc-core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/drivers/xenon/smc-core.c	2012-10-08 18:39:07.949017856 +0200
@@ -0,0 +1,330 @@
+/*
+ *  Xenon SMC core.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+
+#define DRV_NAME	"xenon_smc_core"
+#define DRV_VERSION	"0.1"
+
+struct xenon_smc
+{
+	void __iomem *base;
+	wait_queue_head_t wait_q;
+	spinlock_t fifo_lock;
+
+	void (*send)(void *msg);
+	void (*wait)(void *msg);
+	int (*reply)(void *msg);
+	int (*cached)(void *msg);
+
+	unsigned char cmd;
+};
+
+static struct xenon_smc smc;
+
+static unsigned char smc_reply[][16] = {
+	{ 0x01 },	/* power on type */
+	{ 0x04 },	/* rtc */
+	{ 0x07 },	/* temp */
+	{ 0x0a },	/* tray state */
+	{ 0x0f },	/* av pack */
+	{ 0x11 },	/* (h)ana */
+	{ 0x12 },	/* smc version */
+	{ 0x13 },	/* echo back */
+	{ 0x16 },	/* IR address */
+	{ 0x17 },	/* tilt state */
+	{ 0x1e },	/* 12b @83h */
+	{ 0x20 },	/* 12b @8fh */
+	{ 0x83 },	/* smc event */
+};
+
+
+static void _xenon_smc_send(void *msg)
+{
+	unsigned long flags;
+
+	print_hex_dump(KERN_DEBUG, "_xenon_smc_send: ",
+		DUMP_PREFIX_NONE, 16, 2, msg, 16, 0);
+
+	spin_lock_irqsave(&smc.fifo_lock, flags);
+	while (!(readl(smc.base + 0x84) & 4))
+		cpu_relax();
+
+	writel(4, smc.base + 0x84);
+	writesl(smc.base + 0x80, msg, 4);
+	writel(0, smc.base + 0x84);
+	spin_unlock_irqrestore(&smc.fifo_lock, flags);
+}
+
+static void _xenon_smc_wait(void *msg)
+{
+	/* do we expect a reply? */
+	if (*(unsigned char *)msg & 0x80)
+		return;
+
+#if 0
+	/* wait for reply, maybe a timeout? */
+	while (!(readl(smc.base + 0x94) & 4))
+		cpu_relax();
+#else
+	wait_event_interruptible(smc.wait_q,
+		smc.cmd == *(unsigned char *)msg);
+#endif
+}
+
+
+static int _xenon_smc_reply(void *msg)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&smc.fifo_lock, flags);
+	if (readl(smc.base + 0x94) & 4) {
+		writel(4, smc.base + 0x94);
+		readsl(smc.base + 0x90, msg, 4);
+		writel(0, smc.base + 0x94);
+		ret = 1;
+	} else {
+		memset(msg, 0, 16);
+	}
+	spin_unlock_irqrestore(&smc.fifo_lock, flags);
+	return ret;
+}
+
+static unsigned char * _xenon_smc_cache_lookup(unsigned char *msg) {
+	unsigned char *ptr = smc_reply[0];
+
+	while (ptr[0]) {
+		if (msg[0] == ptr[0])
+			return ptr;
+		ptr += 16;
+	}
+	return NULL;
+}
+
+static int _xenon_smc_cached_reply(void *msg)
+{
+	unsigned char *ptr = _xenon_smc_cache_lookup(msg);
+
+	if (ptr)
+		memcpy(msg + 1, ptr + 1, 15);
+	return (ptr != NULL);
+}
+
+
+static void _xenon_smc_cache(unsigned char *msg) {
+	unsigned char *ptr = _xenon_smc_cache_lookup(msg);
+
+	if (ptr)
+		memcpy(ptr + 1, msg + 1, 15);
+	else
+		printk("unknown smc reply %02x", msg[0]);
+
+	print_hex_dump(KERN_DEBUG, "_xenon_smc_cache: ",
+		DUMP_PREFIX_NONE, 16, 2, msg, 16, 0);
+	smc.cmd = msg[0];
+}
+
+
+int	xenon_smc_message(void *msg)
+{
+	int ret = 0;
+
+	if (smc.send)
+		smc.send(msg);
+
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(xenon_smc_message);
+
+int	xenon_smc_message_wait(void *msg)
+{
+	int ret = 0;
+
+	smc.cmd = 0;
+	if (smc.send)
+		smc.send(msg);
+	if (smc.wait)
+		smc.wait(msg);
+#if 0
+	if (smc.reply)
+		ret = smc.reply(msg);
+#else
+	if (smc.cached)
+		ret = smc.cached(msg);
+#endif
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(xenon_smc_message_wait);
+
+
+static void show_logo(void)
+{
+	unsigned char msg[16] = {0x99, 0x01, 0x63, 0};
+
+	xenon_smc_message(msg);
+}
+
+void xenon_smc_restart(char *cmd)
+{
+	unsigned char msg[16] = {0x82, 0x04, 0x30, 0};
+
+	xenon_smc_message(msg);
+}
+
+void xenon_smc_power_off(void)
+{
+	unsigned char msg[16] = {0x82, 0x01, 0x00, 0};
+
+	xenon_smc_message(msg);
+}
+
+void xenon_smc_halt(void)
+{
+	return;
+}
+
+static const struct pci_device_id xenon_smc_pci_tbl[] = {
+	{ PCI_VDEVICE(MICROSOFT, 0x580d), 0 },
+	{ }	/* terminate list */
+};
+
+static irqreturn_t xenon_smc_irq(int irq, void *dev_id)
+{
+	static unsigned char msg[16];
+	// struct pci_dev *pdev = dev_id;
+
+	unsigned int irqs = readl(smc.base + 0x50);
+
+	printk(KERN_DEBUG "xenon_smc_irq() = %08x,%08x\n",
+		irqs, readl(smc.base + 0x94));
+
+	if (irqs & 0x10000000) {
+		if (_xenon_smc_reply(msg)) {
+			_xenon_smc_cache(msg);
+			wake_up(&smc.wait_q);
+		}
+	}
+
+	writel(irqs, smc.base + 0x58);	// ack irq
+	return IRQ_HANDLED;
+}
+
+static int xenon_smc_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	// static int printed_version;
+	int rc;
+	int pci_dev_busy = 0;
+	unsigned long mmio_start;
+
+	dev_printk(KERN_INFO, &pdev->dev, "version " DRV_VERSION "\n");
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc) {
+		pci_dev_busy = 1;
+		goto err_out;
+	}
+
+	pci_intx(pdev, 1);
+
+	printk(KERN_INFO "attached to xenon SMC\n");
+
+	mmio_start = pci_resource_start(pdev, 0);
+	smc.base = ioremap(mmio_start, 0x100);
+	if (!smc.base)
+		goto err_out_regions;
+
+	init_waitqueue_head(&smc.wait_q);
+	spin_lock_init(&smc.fifo_lock);
+
+	if (request_irq(pdev->irq, xenon_smc_irq, IRQF_SHARED,
+		"xenon-smc", pdev)) {
+		printk(KERN_ERR "xenon-smc: request_irq failed\n");
+		goto err_out_ioremap;
+	}
+
+	smc.send = _xenon_smc_send;
+	smc.wait = _xenon_smc_wait;
+	smc.reply = _xenon_smc_reply;
+	smc.cached = _xenon_smc_cached_reply;
+
+	show_logo();
+	return 0;
+
+err_out_ioremap:
+	iounmap(smc.base);
+
+err_out_regions:
+	pci_release_regions(pdev);
+
+err_out:
+	if (!pci_dev_busy)
+		pci_disable_device(pdev);
+	return rc;
+}
+
+static void __devexit xenon_smc_remove(struct pci_dev *pdev)
+{
+	smc.send = NULL;
+	smc.reply = NULL;
+
+	iounmap(smc.base);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver xenon_smc_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= xenon_smc_pci_tbl,
+	.probe			= xenon_smc_init_one,
+	.remove     = __devexit_p(xenon_smc_remove)
+};
+
+
+static int __init xenon_smc_init(void)
+{
+	return pci_register_driver(&xenon_smc_pci_driver);
+}
+
+static void __exit xenon_smc_exit(void)
+{
+	pci_unregister_driver(&xenon_smc_pci_driver);
+}
+
+module_init(xenon_smc_init);
+module_exit(xenon_smc_exit);
+
+
+MODULE_DESCRIPTION("Driver for Xenon Southbridge SMC");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+MODULE_DEVICE_TABLE(pci, xenon_smc_pci_tbl);
+
diff -NurpP --minimal linux-3.5.4/include/linux/fb.h linux-3.5.4-xenon/include/linux/fb.h
--- linux-3.5.4/include/linux/fb.h	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/include/linux/fb.h	2012-10-08 18:39:07.949017856 +0200
@@ -1076,6 +1076,18 @@ static inline bool fb_be_math(struct fb_
 #endif /* CONFIG_FB_FOREIGN_ENDIAN */
 }
 
+static inline int *xenon_convert(struct fb_info *p, int *addr)
+{
+	int index = ((char*)addr) - ((char*)p->screen_base);
+	int y = index / (p->fix.line_length);
+	int x = index % (p->fix.line_length)/4;
+	unsigned int base = ((((y & ~31)*p->var.xres) + (x & ~31)*32 ) +
+	 (((x&3) + ((y&1)<<2) + ((x&28)<<1) + ((y&30)<<5)) ^ ((y&8)<<2))) * 4;
+
+	return (int*)(((char*)p->screen_base)+base);
+}
+
+
 /* drivers/video/fbsysfs.c */
 extern struct fb_info *framebuffer_alloc(size_t size, struct device *dev);
 extern void framebuffer_release(struct fb_info *info);
diff -NurpP --minimal linux-3.5.4/include/linux/irqdesc.h linux-3.5.4-xenon/include/linux/irqdesc.h
--- linux-3.5.4/include/linux/irqdesc.h	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/include/linux/irqdesc.h	2012-10-08 18:39:07.949017856 +0200
@@ -110,6 +110,10 @@ static inline struct msi_desc *irq_desc_
  */
 static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
 {
+	if (!desc) {
+		printk("generic_handle_irq_desc(%u,%p) ...\n", irq, desc);
+		return;
+	}
 	desc->handle_irq(irq, desc);
 }
 
diff -NurpP --minimal linux-3.5.4/include/linux/pci_ids.h linux-3.5.4-xenon/include/linux/pci_ids.h
--- linux-3.5.4/include/linux/pci_ids.h	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/include/linux/pci_ids.h	2012-10-08 18:39:07.949017856 +0200
@@ -2235,6 +2235,8 @@
 #define PCI_DEVICE_ID_ADDIDATA_APCIe7500       0x7012
 #define PCI_DEVICE_ID_ADDIDATA_APCIe7800       0x7013
 
+#define PCI_VENDOR_ID_MICROSOFT		0x1414
+
 #define PCI_VENDOR_ID_PDC		0x15e9
 
 #define PCI_VENDOR_ID_FARSITE           0x1619
diff -NurpP --minimal linux-3.5.4/include/linux/serial_core.h linux-3.5.4-xenon/include/linux/serial_core.h
--- linux-3.5.4/include/linux/serial_core.h	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/include/linux/serial_core.h	2012-10-08 18:39:07.949017856 +0200
@@ -213,6 +213,9 @@
 /* Energy Micro efm32 SoC */
 #define PORT_EFMUART   100
 
+/* Xenon XBOX 360 Southbridge */
+#define PORT_XENON	91
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
@@ -256,7 +259,7 @@ struct uart_ops {
 	/*
 	 * Return a string describing the type of the port
 	 */
-	const char *(*type)(struct uart_port *);
+	const char *	(*type)(struct uart_port *);
 
 	/*
 	 * Release IO and memory resources used by the port.
@@ -273,7 +276,7 @@ struct uart_ops {
 	int		(*verify_port)(struct uart_port *, struct serial_struct *);
 	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
 #ifdef CONFIG_CONSOLE_POLL
-	void	(*poll_put_char)(struct uart_port *, unsigned char);
+	void		(*poll_put_char)(struct uart_port *, unsigned char);
 	int		(*poll_get_char)(struct uart_port *);
 #endif
 };
diff -NurpP --minimal linux-3.5.4/kernel/printk.c linux-3.5.4-xenon/kernel/printk.c
--- linux-3.5.4/kernel/printk.c	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/kernel/printk.c	2012-10-08 18:39:07.949017856 +0200
@@ -713,9 +713,9 @@ static unsigned long long loops_per_msec
 
 static int __init boot_delay_setup(char *str)
 {
-	unsigned long lpj;
+	unsigned long lpj = loops_per_jiffy;
 
-	lpj = preset_lpj ? preset_lpj : 1000000;	/* some guess */
+//	lpj = preset_lpj ? preset_lpj : 1000000;	/* some guess */
 	loops_per_msec = (unsigned long long)lpj / 1000 * HZ;
 
 	get_option(&str, &boot_delay);
diff -NurpP --minimal linux-3.5.4/lib/Kconfig.debug linux-3.5.4-xenon/lib/Kconfig.debug
--- linux-3.5.4/lib/Kconfig.debug	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/lib/Kconfig.debug	2012-10-08 18:39:07.949017856 +0200
@@ -895,7 +895,7 @@ config FRAME_POINTER
 
 config BOOT_PRINTK_DELAY
 	bool "Delay each boot printk message by N milliseconds"
-	depends on DEBUG_KERNEL && PRINTK && GENERIC_CALIBRATE_DELAY
+	depends on DEBUG_KERNEL && PRINTK
 	help
 	  This build option allows you to read kernel boot messages
 	  by inserting a short delay after each one.  The delay is
diff -NurpP --minimal linux-3.5.4/Makefile linux-3.5.4-xenon/Makefile
--- linux-3.5.4/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/Makefile	2012-10-08 18:39:07.953017914 +0200
@@ -1,7 +1,7 @@
 VERSION = 3
 PATCHLEVEL = 5
 SUBLEVEL = 4
-EXTRAVERSION =
+EXTRAVERSION = -xbox0.11.1
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
diff -NurpP --minimal linux-3.5.4/scripts/dtc/dtc-lexer.lex.c linux-3.5.4-xenon/scripts/dtc/dtc-lexer.lex.c
--- linux-3.5.4/scripts/dtc/dtc-lexer.lex.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/scripts/dtc/dtc-lexer.lex.c	2012-10-08 18:39:07.953017914 +0200
@@ -0,0 +1,1976 @@
+
+#line 3 "scripts/dtc/dtc-lexer.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 17
+#define YY_END_OF_BUFFER 18
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[94] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       18,   16,   13,   13,   16,   16,   16,   16,   16,   16,
+       16,   10,   11,   11,    6,    6,   13,    0,    2,    0,
+        7,    0,    0,    0,    0,    0,    0,    0,    5,    0,
+        9,    9,   11,   11,    6,    0,    7,    0,    0,    0,
+        0,   15,    0,    0,    0,    0,    6,    0,   14,    0,
+        0,    0,    0,    0,    8,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    3,   12,
+        0,    0,    0,    0,    0,    0,    0,    0,    1,    0,
+        0,    4,    0
+
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    4,    5,    1,    1,    6,    1,    1,
+        1,    7,    5,    5,    8,    5,    9,   10,   11,   12,
+       12,   12,   12,   12,   12,   12,   12,   13,    1,    1,
+        1,    1,    5,    5,   14,   14,   14,   14,   14,   14,
+       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   15,   16,   15,   15,
+        1,   17,   18,    1,   15,    1,   14,   19,   20,   21,
+
+       22,   14,   15,   15,   23,   15,   15,   24,   25,   26,
+       15,   15,   15,   27,   28,   29,   30,   31,   15,   16,
+       15,   15,   32,    1,   33,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[34] =
+    {   0,
+        1,    1,    1,    1,    2,    1,    2,    2,    3,    4,
+        4,    4,    5,    6,    7,    7,    1,    1,    6,    6,
+        6,    6,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    8,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[106] =
+    {   0,
+        0,    0,  237,  236,   25,    0,   47,    0,   30,   71,
+      244,  247,   82,   84,   84,  211,   95,  229,  218,    0,
+      111,  247,    0,   84,   83,   95,  106,   86,  247,  237,
+        0,  230,  231,  234,  207,  209,  212,  220,  247,  206,
+      247,  218,    0,  106,  116,    0,    0,    0,  223,   89,
+      226,  219,  199,  206,  200,  204,    0,  190,  213,  212,
+      202,   91,  178,  161,  247,  172,  144,  150,  140,  130,
+      140,  124,  128,  120,  138,  137,  123,  122,  247,  247,
+      134,  114,  132,   86,  135,  125,   90,  136,  247,   97,
+       29,  247,  247,  153,  156,  161,  165,  170,  176,  180,
+
+      187,  195,  200,  205,  212
+    } ;
+
+static yyconst flex_int16_t yy_def[106] =
+    {   0,
+       93,    1,    1,    1,    1,    5,   93,    7,    1,    1,
+       93,   93,   93,   93,   94,   95,   93,   96,   17,   97,
+       96,   93,   98,   99,   93,   93,   93,   94,   93,   94,
+      100,   93,  101,  102,   93,   93,   93,   96,   93,   93,
+       93,   96,   98,   99,   93,  103,  100,  104,  101,  101,
+      102,   93,   93,   93,   93,   93,  103,  104,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,  105,   93,  105,   93,  105,
+       93,   93,    0,   93,   93,   93,   93,   93,   93,   93,
+
+       93,   93,   93,   93,   93
+    } ;
+
+static yyconst flex_int16_t yy_nxt[281] =
+    {   0,
+       12,   13,   14,   15,   12,   16,   12,   12,   17,   12,
+       12,   12,   12,   18,   18,   18,   12,   12,   18,   18,
+       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
+       18,   12,   12,   19,   20,   20,   20,   92,   21,   25,
+       26,   26,   22,   21,   21,   21,   21,   12,   13,   14,
+       15,   23,   16,   23,   23,   19,   23,   23,   23,   12,
+       24,   24,   24,   12,   12,   24,   24,   24,   24,   24,
+       24,   24,   24,   24,   24,   24,   24,   24,   12,   12,
+       25,   26,   26,   27,   27,   27,   27,   29,   43,   29,
+       43,   43,   45,   45,   45,   50,   39,   59,   46,   93,
+
+       30,   33,   30,   34,   45,   45,   45,   27,   27,   68,
+       43,   91,   43,   43,   69,   35,   87,   36,   39,   37,
+       42,   42,   42,   39,   42,   45,   45,   45,   89,   42,
+       42,   42,   42,   85,   85,   86,   85,   85,   86,   89,
+       84,   90,   83,   82,   81,   80,   79,   78,   77,   76,
+       75,   74,   90,   28,   28,   28,   28,   28,   28,   28,
+       28,   31,   31,   31,   38,   38,   38,   38,   41,   73,
+       41,   43,   72,   43,   71,   43,   43,   44,   33,   44,
+       44,   44,   44,   47,   69,   47,   47,   49,   49,   49,
+       49,   49,   49,   49,   49,   51,   51,   51,   51,   51,
+
+       51,   51,   51,   57,   70,   57,   58,   58,   58,   67,
+       58,   58,   88,   88,   88,   88,   88,   88,   88,   88,
+       34,   66,   65,   64,   63,   62,   61,   60,   52,   50,
+       39,   56,   39,   55,   54,   53,   52,   50,   48,   93,
+       40,   39,   32,   93,   19,   19,   11,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93
+    } ;
+
+static yyconst flex_int16_t yy_chk[281] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    5,    5,    5,    5,   91,    5,    9,
+        9,    9,    5,    5,    5,    5,    5,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+       10,   10,   10,   13,   13,   14,   14,   15,   24,   28,
+       24,   24,   25,   25,   25,   50,   24,   50,   25,   90,
+
+       15,   17,   28,   17,   26,   26,   26,   27,   27,   62,
+       44,   87,   44,   44,   62,   17,   84,   17,   44,   17,
+       21,   21,   21,   21,   21,   45,   45,   45,   86,   21,
+       21,   21,   21,   83,   83,   83,   85,   85,   85,   88,
+       82,   86,   81,   78,   77,   76,   75,   74,   73,   72,
+       71,   70,   88,   94,   94,   94,   94,   94,   94,   94,
+       94,   95,   95,   95,   96,   96,   96,   96,   97,   69,
+       97,   98,   68,   98,   67,   98,   98,   99,   66,   99,
+       99,   99,   99,  100,   64,  100,  100,  101,  101,  101,
+      101,  101,  101,  101,  101,  102,  102,  102,  102,  102,
+
+      102,  102,  102,  103,   63,  103,  104,  104,  104,   61,
+      104,  104,  105,  105,  105,  105,  105,  105,  105,  105,
+       60,   59,   58,   56,   55,   54,   53,   52,   51,   49,
+       42,   40,   38,   37,   36,   35,   34,   33,   32,   30,
+       19,   18,   16,   11,    4,    3,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93,
+       93,   93,   93,   93,   93,   93,   93,   93,   93,   93
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *                                                                   USA
+ */
+#define YY_NO_INPUT 1
+
+#include "dtc.h"
+#include "srcpos.h"
+#include "dtc-parser.tab.h"
+
+YYLTYPE yylloc;
+
+/* CAUTION: this will stop working if we ever use yyless() or yyunput() */
+#define	YY_USER_ACTION \
+	{ \
+		srcpos_update(&yylloc, yytext, yyleng); \
+	}
+
+/*#define LEXDEBUG	1*/
+
+#ifdef LEXDEBUG
+#define DPRINT(fmt, ...)	fprintf(stderr, fmt, ##__VA_ARGS__)
+#else
+#define DPRINT(fmt, ...)	do { } while (0)
+#endif
+
+static int dts_version = 1;
+
+#define BEGIN_DEFAULT()		DPRINT("<V1>\n"); \
+				BEGIN(V1); \
+
+static void push_input_file(const char *filename);
+static int pop_input_file(void);
+
+#define INITIAL 0
+#define INCLUDE 1
+#define BYTESTRING 2
+#define PROPNODENAME 3
+#define V1 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		unsigned n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 94 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 93 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+{
+			char *name = strchr(yytext, '\"') + 1;
+			yytext[yyleng-1] = '\0';
+			push_input_file(name);
+		}
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(INCLUDE):
+case YY_STATE_EOF(BYTESTRING):
+case YY_STATE_EOF(PROPNODENAME):
+case YY_STATE_EOF(V1):
+{
+			if (!pop_input_file()) {
+				yyterminate();
+			}
+		}
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+			DPRINT("String: %s\n", yytext);
+			yylval.data = data_copy_escape_string(yytext+1,
+					yyleng-2);
+			return DT_STRING;
+		}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+{
+			DPRINT("Keyword: /dts-v1/\n");
+			dts_version = 1;
+			BEGIN_DEFAULT();
+			return DT_V1;
+		}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+			DPRINT("Keyword: /memreserve/\n");
+			BEGIN_DEFAULT();
+			return DT_MEMRESERVE;
+		}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+			DPRINT("Label: %s\n", yytext);
+			yylval.labelref = xstrdup(yytext);
+			yylval.labelref[yyleng-1] = '\0';
+			return DT_LABEL;
+		}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+{
+			yylval.literal = xstrdup(yytext);
+			DPRINT("Literal: '%s'\n", yylval.literal);
+			return DT_LITERAL;
+		}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+{	/* label reference */
+			DPRINT("Ref: %s\n", yytext+1);
+			yylval.labelref = xstrdup(yytext+1);
+			return DT_REF;
+		}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+{	/* new-style path reference */
+			yytext[yyleng-1] = '\0';
+			DPRINT("Ref: %s\n", yytext+2);
+			yylval.labelref = xstrdup(yytext+2);
+			return DT_REF;
+		}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+{
+			yylval.byte = strtol(yytext, NULL, 16);
+			DPRINT("Byte: %02x\n", (int)yylval.byte);
+			return DT_BYTE;
+		}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+{
+			DPRINT("/BYTESTRING\n");
+			BEGIN_DEFAULT();
+			return ']';
+		}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+{
+			DPRINT("PropNodeName: %s\n", yytext);
+			yylval.propnodename = xstrdup(yytext);
+			BEGIN_DEFAULT();
+			return DT_PROPNODENAME;
+		}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+{
+			DPRINT("Binary Include\n");
+			return DT_INCBIN;
+		}
+	YY_BREAK
+case 13:
+/* rule 13 can match eol */
+YY_RULE_SETUP
+/* eat whitespace */
+	YY_BREAK
+case 14:
+/* rule 14 can match eol */
+YY_RULE_SETUP
+/* eat C-style comments */
+	YY_BREAK
+case 15:
+/* rule 15 can match eol */
+YY_RULE_SETUP
+/* eat C++-style comments */
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+			DPRINT("Char: %c (\\x%02x)\n", yytext[0],
+				(unsigned)yytext[0]);
+			if (yytext[0] == '[') {
+				DPRINT("<BYTESTRING>\n");
+				BEGIN(BYTESTRING);
+			}
+			if ((yytext[0] == '{')
+			    || (yytext[0] == ';')) {
+				DPRINT("<PROPNODENAME>\n");
+				BEGIN(PROPNODENAME);
+			}
+			return yytext[0];
+		}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+ECHO;
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 94 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 94 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 93);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+static void push_input_file(const char *filename)
+{
+	assert(filename);
+
+	srcfile_push(filename);
+
+	yyin = current_srcfile->f;
+
+	yypush_buffer_state(yy_create_buffer(yyin,YY_BUF_SIZE));
+}
+
+static int pop_input_file(void)
+{
+	if (srcfile_pop() == 0)
+		return 0;
+
+	yypop_buffer_state();
+	yyin = current_srcfile->f;
+
+	return 1;
+}
+
diff -NurpP --minimal linux-3.5.4/scripts/dtc/dtc-parser.tab.c linux-3.5.4-xenon/scripts/dtc/dtc-parser.tab.c
--- linux-3.5.4/scripts/dtc/dtc-parser.tab.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/scripts/dtc/dtc-parser.tab.c	2012-10-08 18:39:07.953017914 +0200
@@ -0,0 +1,1946 @@
+/* A Bison parser, made by GNU Bison 2.4.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+
+#include <stdio.h>
+
+#include "dtc.h"
+#include "srcpos.h"
+
+YYLTYPE yylloc;
+
+extern int yylex(void);
+extern void print_error(char const *fmt, ...);
+extern void yyerror(char const *s);
+
+extern struct boot_info *the_boot_info;
+extern int treesource_error;
+
+static unsigned long long eval_literal(const char *s, int base, int bits);
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     DT_V1 = 258,
+     DT_MEMRESERVE = 259,
+     DT_PROPNODENAME = 260,
+     DT_LITERAL = 261,
+     DT_BASE = 262,
+     DT_BYTE = 263,
+     DT_STRING = 264,
+     DT_LABEL = 265,
+     DT_REF = 266,
+     DT_INCBIN = 267
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *propnodename;
+	char *literal;
+	char *labelref;
+	unsigned int cbase;
+	uint8_t byte;
+	struct data data;
+
+	uint64_t addr;
+	cell_t cell;
+	struct property *prop;
+	struct property *proplist;
+	struct node *node;
+	struct node *nodelist;
+	struct reserve_info *re;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  4
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   56
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  25
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  16
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  39
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  67
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   267
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      22,    24,     2,     2,    23,     2,     2,    14,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    13,
+      18,    17,    19,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    20,     2,    21,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    15,     2,    16,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     8,     9,    12,    17,    20,    22,    25,
+      29,    33,    39,    40,    43,    48,    51,    54,    57,    62,
+      67,    70,    80,    86,    89,    90,    93,    96,    97,   100,
+     103,   106,   108,   109,   112,   115,   116,   119,   122,   125
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      26,     0,    -1,     3,    13,    27,    30,    -1,    -1,    28,
+      27,    -1,     4,    29,    29,    13,    -1,    10,    28,    -1,
+       6,    -1,    14,    31,    -1,    30,    14,    31,    -1,    30,
+      11,    31,    -1,    15,    32,    39,    16,    13,    -1,    -1,
+      32,    33,    -1,     5,    17,    34,    13,    -1,     5,    13,
+      -1,    10,    33,    -1,    35,     9,    -1,    35,    18,    36,
+      19,    -1,    35,    20,    38,    21,    -1,    35,    11,    -1,
+      35,    12,    22,     9,    23,    29,    23,    29,    24,    -1,
+      35,    12,    22,     9,    24,    -1,    34,    10,    -1,    -1,
+      34,    23,    -1,    35,    10,    -1,    -1,    36,    37,    -1,
+      36,    11,    -1,    36,    10,    -1,     6,    -1,    -1,    38,
+       8,    -1,    38,    10,    -1,    -1,    40,    39,    -1,    40,
+      33,    -1,     5,    31,    -1,    10,    40,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,    86,    86,    95,    98,   105,   109,   117,   124,   128,
+     132,   145,   153,   156,   163,   167,   171,   179,   183,   187,
+     191,   195,   212,   222,   230,   233,   237,   245,   248,   252,
+     257,   264,   272,   275,   279,   287,   290,   294,   302,   306
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "DT_V1", "DT_MEMRESERVE",
+  "DT_PROPNODENAME", "DT_LITERAL", "DT_BASE", "DT_BYTE", "DT_STRING",
+  "DT_LABEL", "DT_REF", "DT_INCBIN", "';'", "'/'", "'{'", "'}'", "'='",
+  "'<'", "'>'", "'['", "']'", "'('", "','", "')'", "$accept", "sourcefile",
+  "memreserves", "memreserve", "addr", "devicetree", "nodedef", "proplist",
+  "propdef", "propdata", "propdataprefix", "celllist", "cellval",
+  "bytestring", "subnodes", "subnode", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,    59,    47,   123,   125,    61,    60,    62,
+      91,    93,    40,    44,    41
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    25,    26,    27,    27,    28,    28,    29,    30,    30,
+      30,    31,    32,    32,    33,    33,    33,    34,    34,    34,
+      34,    34,    34,    34,    35,    35,    35,    36,    36,    36,
+      36,    37,    38,    38,    38,    39,    39,    39,    40,    40
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     4,     0,     2,     4,     2,     1,     2,     3,
+       3,     5,     0,     2,     4,     2,     2,     2,     4,     4,
+       2,     9,     5,     2,     0,     2,     2,     0,     2,     2,
+       2,     1,     0,     2,     2,     0,     2,     2,     2,     2
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     0,     3,     1,     0,     0,     0,     3,     7,
+       0,     6,     0,     2,     4,     0,    12,     8,     0,     0,
+       5,    35,    10,     9,     0,     0,    13,     0,    35,    15,
+      24,    38,    16,    39,     0,    37,    36,     0,     0,    11,
+      23,    14,    25,    17,    26,    20,     0,    27,    32,     0,
+       0,     0,     0,    31,    30,    29,    18,    28,    33,    34,
+      19,     0,    22,     0,     0,     0,    21
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     2,     7,     8,    10,    13,    17,    21,    26,    37,
+      38,    50,    57,    51,    27,    28
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -12
+static const yytype_int8 yypact[] =
+{
+      10,   -11,    18,    -1,   -12,    22,    -1,    15,    -1,   -12,
+      22,   -12,    20,     1,   -12,    17,   -12,   -12,    20,    20,
+     -12,     6,   -12,   -12,    21,     6,   -12,    23,     6,   -12,
+     -12,   -12,   -12,   -12,    28,   -12,   -12,    -6,    13,   -12,
+     -12,   -12,   -12,   -12,   -12,   -12,    24,   -12,   -12,    33,
+      -5,     0,    -4,   -12,   -12,   -12,   -12,   -12,   -12,   -12,
+     -12,    22,   -12,    25,    22,    19,   -12
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -12,   -12,    36,    39,   -10,   -12,     8,   -12,    12,   -12,
+     -12,   -12,   -12,   -12,    27,    31
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      15,    53,     3,     5,    40,    54,    55,    41,    58,     6,
+      59,    24,    18,     1,    56,    19,    25,    42,     4,    61,
+      62,    60,    43,    44,    45,    46,    22,    23,     9,    12,
+      20,    47,    31,    48,    29,    16,    16,    32,    30,    34,
+      35,    39,    52,    66,    14,    11,    49,     0,    64,     0,
+       0,    63,     0,     0,    65,    36,    33
+};
+
+static const yytype_int8 yycheck[] =
+{
+      10,     6,    13,     4,    10,    10,    11,    13,     8,    10,
+      10,     5,    11,     3,    19,    14,    10,    23,     0,    23,
+      24,    21,     9,    10,    11,    12,    18,    19,     6,    14,
+      13,    18,    24,    20,    13,    15,    15,    25,    17,    16,
+      28,    13,     9,    24,     8,     6,    22,    -1,    23,    -1,
+      -1,    61,    -1,    -1,    64,    28,    25
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    26,    13,     0,     4,    10,    27,    28,     6,
+      29,    28,    14,    30,    27,    29,    15,    31,    11,    14,
+      13,    32,    31,    31,     5,    10,    33,    39,    40,    13,
+      17,    31,    33,    40,    16,    33,    39,    34,    35,    13,
+      10,    13,    23,     9,    10,    11,    12,    18,    20,    22,
+      36,    38,     9,     6,    10,    11,    19,    37,     8,    10,
+      21,    23,    24,    29,    23,    29,    24
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+
+    {
+			the_boot_info = build_boot_info((yyvsp[(3) - (4)].re), (yyvsp[(4) - (4)].node),
+							guess_boot_cpuid((yyvsp[(4) - (4)].node)));
+		;}
+    break;
+
+  case 3:
+
+    {
+			(yyval.re) = NULL;
+		;}
+    break;
+
+  case 4:
+
+    {
+			(yyval.re) = chain_reserve_entry((yyvsp[(1) - (2)].re), (yyvsp[(2) - (2)].re));
+		;}
+    break;
+
+  case 5:
+
+    {
+			(yyval.re) = build_reserve_entry((yyvsp[(2) - (4)].addr), (yyvsp[(3) - (4)].addr));
+		;}
+    break;
+
+  case 6:
+
+    {
+			add_label(&(yyvsp[(2) - (2)].re)->labels, (yyvsp[(1) - (2)].labelref));
+			(yyval.re) = (yyvsp[(2) - (2)].re);
+		;}
+    break;
+
+  case 7:
+
+    {
+			(yyval.addr) = eval_literal((yyvsp[(1) - (1)].literal), 0, 64);
+		;}
+    break;
+
+  case 8:
+
+    {
+			(yyval.node) = name_node((yyvsp[(2) - (2)].node), "");
+		;}
+    break;
+
+  case 9:
+
+    {
+			(yyval.node) = merge_nodes((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
+		;}
+    break;
+
+  case 10:
+
+    {
+			struct node *target = get_node_by_ref((yyvsp[(1) - (3)].node), (yyvsp[(2) - (3)].labelref));
+
+			if (target)
+				merge_nodes(target, (yyvsp[(3) - (3)].node));
+			else
+				print_error("label or path, '%s', not found", (yyvsp[(2) - (3)].labelref));
+			(yyval.node) = (yyvsp[(1) - (3)].node);
+		;}
+    break;
+
+  case 11:
+
+    {
+			(yyval.node) = build_node((yyvsp[(2) - (5)].proplist), (yyvsp[(3) - (5)].nodelist));
+		;}
+    break;
+
+  case 12:
+
+    {
+			(yyval.proplist) = NULL;
+		;}
+    break;
+
+  case 13:
+
+    {
+			(yyval.proplist) = chain_property((yyvsp[(2) - (2)].prop), (yyvsp[(1) - (2)].proplist));
+		;}
+    break;
+
+  case 14:
+
+    {
+			(yyval.prop) = build_property((yyvsp[(1) - (4)].propnodename), (yyvsp[(3) - (4)].data));
+		;}
+    break;
+
+  case 15:
+
+    {
+			(yyval.prop) = build_property((yyvsp[(1) - (2)].propnodename), empty_data);
+		;}
+    break;
+
+  case 16:
+
+    {
+			add_label(&(yyvsp[(2) - (2)].prop)->labels, (yyvsp[(1) - (2)].labelref));
+			(yyval.prop) = (yyvsp[(2) - (2)].prop);
+		;}
+    break;
+
+  case 17:
+
+    {
+			(yyval.data) = data_merge((yyvsp[(1) - (2)].data), (yyvsp[(2) - (2)].data));
+		;}
+    break;
+
+  case 18:
+
+    {
+			(yyval.data) = data_merge((yyvsp[(1) - (4)].data), (yyvsp[(3) - (4)].data));
+		;}
+    break;
+
+  case 19:
+
+    {
+			(yyval.data) = data_merge((yyvsp[(1) - (4)].data), (yyvsp[(3) - (4)].data));
+		;}
+    break;
+
+  case 20:
+
+    {
+			(yyval.data) = data_add_marker((yyvsp[(1) - (2)].data), REF_PATH, (yyvsp[(2) - (2)].labelref));
+		;}
+    break;
+
+  case 21:
+
+    {
+			FILE *f = srcfile_relative_open((yyvsp[(4) - (9)].data).val, NULL);
+			struct data d;
+
+			if ((yyvsp[(6) - (9)].addr) != 0)
+				if (fseek(f, (yyvsp[(6) - (9)].addr), SEEK_SET) != 0)
+					print_error("Couldn't seek to offset %llu in \"%s\": %s",
+						     (unsigned long long)(yyvsp[(6) - (9)].addr),
+						     (yyvsp[(4) - (9)].data).val,
+						     strerror(errno));
+
+			d = data_copy_file(f, (yyvsp[(8) - (9)].addr));
+
+			(yyval.data) = data_merge((yyvsp[(1) - (9)].data), d);
+			fclose(f);
+		;}
+    break;
+
+  case 22:
+
+    {
+			FILE *f = srcfile_relative_open((yyvsp[(4) - (5)].data).val, NULL);
+			struct data d = empty_data;
+
+			d = data_copy_file(f, -1);
+
+			(yyval.data) = data_merge((yyvsp[(1) - (5)].data), d);
+			fclose(f);
+		;}
+    break;
+
+  case 23:
+
+    {
+			(yyval.data) = data_add_marker((yyvsp[(1) - (2)].data), LABEL, (yyvsp[(2) - (2)].labelref));
+		;}
+    break;
+
+  case 24:
+
+    {
+			(yyval.data) = empty_data;
+		;}
+    break;
+
+  case 25:
+
+    {
+			(yyval.data) = (yyvsp[(1) - (2)].data);
+		;}
+    break;
+
+  case 26:
+
+    {
+			(yyval.data) = data_add_marker((yyvsp[(1) - (2)].data), LABEL, (yyvsp[(2) - (2)].labelref));
+		;}
+    break;
+
+  case 27:
+
+    {
+			(yyval.data) = empty_data;
+		;}
+    break;
+
+  case 28:
+
+    {
+			(yyval.data) = data_append_cell((yyvsp[(1) - (2)].data), (yyvsp[(2) - (2)].cell));
+		;}
+    break;
+
+  case 29:
+
+    {
+			(yyval.data) = data_append_cell(data_add_marker((yyvsp[(1) - (2)].data), REF_PHANDLE,
+							      (yyvsp[(2) - (2)].labelref)), -1);
+		;}
+    break;
+
+  case 30:
+
+    {
+			(yyval.data) = data_add_marker((yyvsp[(1) - (2)].data), LABEL, (yyvsp[(2) - (2)].labelref));
+		;}
+    break;
+
+  case 31:
+
+    {
+			(yyval.cell) = eval_literal((yyvsp[(1) - (1)].literal), 0, 32);
+		;}
+    break;
+
+  case 32:
+
+    {
+			(yyval.data) = empty_data;
+		;}
+    break;
+
+  case 33:
+
+    {
+			(yyval.data) = data_append_byte((yyvsp[(1) - (2)].data), (yyvsp[(2) - (2)].byte));
+		;}
+    break;
+
+  case 34:
+
+    {
+			(yyval.data) = data_add_marker((yyvsp[(1) - (2)].data), LABEL, (yyvsp[(2) - (2)].labelref));
+		;}
+    break;
+
+  case 35:
+
+    {
+			(yyval.nodelist) = NULL;
+		;}
+    break;
+
+  case 36:
+
+    {
+			(yyval.nodelist) = chain_node((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].nodelist));
+		;}
+    break;
+
+  case 37:
+
+    {
+			print_error("syntax error: properties must precede subnodes");
+			YYERROR;
+		;}
+    break;
+
+  case 38:
+
+    {
+			(yyval.node) = name_node((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].propnodename));
+		;}
+    break;
+
+  case 39:
+
+    {
+			add_label(&(yyvsp[(2) - (2)].node)->labels, (yyvsp[(1) - (2)].labelref));
+			(yyval.node) = (yyvsp[(2) - (2)].node);
+		;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void print_error(char const *fmt, ...)
+{
+	va_list va;
+
+	va_start(va, fmt);
+	srcpos_verror(&yylloc, fmt, va);
+	va_end(va);
+
+	treesource_error = 1;
+}
+
+void yyerror(char const *s) {
+	print_error("%s", s);
+}
+
+static unsigned long long eval_literal(const char *s, int base, int bits)
+{
+	unsigned long long val;
+	char *e;
+
+	errno = 0;
+	val = strtoull(s, &e, base);
+	if (*e)
+		print_error("bad characters in literal");
+	else if ((errno == ERANGE)
+		 || ((bits < 64) && (val >= (1ULL << bits))))
+		print_error("literal out of range");
+	else if (errno != 0)
+		print_error("bad literal");
+	return val;
+}
+
diff -NurpP --minimal linux-3.5.4/scripts/dtc/dtc-parser.tab.h linux-3.5.4-xenon/scripts/dtc/dtc-parser.tab.h
--- linux-3.5.4/scripts/dtc/dtc-parser.tab.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/scripts/dtc/dtc-parser.tab.h	2012-10-08 18:39:07.953017914 +0200
@@ -0,0 +1,86 @@
+/* A Bison parser, made by GNU Bison 2.4.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     DT_V1 = 258,
+     DT_MEMRESERVE = 259,
+     DT_PROPNODENAME = 260,
+     DT_LITERAL = 261,
+     DT_BASE = 262,
+     DT_BYTE = 263,
+     DT_STRING = 264,
+     DT_LABEL = 265,
+     DT_REF = 266,
+     DT_INCBIN = 267
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *propnodename;
+	char *literal;
+	char *labelref;
+	unsigned int cbase;
+	uint8_t byte;
+	struct data data;
+
+	uint64_t addr;
+	cell_t cell;
+	struct property *prop;
+	struct property *proplist;
+	struct node *node;
+	struct node *nodelist;
+	struct reserve_info *re;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
diff -NurpP --minimal linux-3.5.4/sound/pci/Kconfig linux-3.5.4-xenon/sound/pci/Kconfig
--- linux-3.5.4/sound/pci/Kconfig	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/sound/pci/Kconfig	2012-10-08 18:39:07.953017914 +0200
@@ -869,4 +869,13 @@ config SND_YMFPCI
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-ymfpci.
 
+config SND_XENON
+	tristate "Xenon XBOX 360 Sound"
+	select SND_PCM
+	help
+	  Say Y here to include support for the Xenon XBOX 360 soundcard.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-xenon.
+
 endif	# SND_PCI
diff -NurpP --minimal linux-3.5.4/sound/pci/Makefile linux-3.5.4-xenon/sound/pci/Makefile
--- linux-3.5.4/sound/pci/Makefile	2012-09-15 00:28:08.000000000 +0200
+++ linux-3.5.4-xenon/sound/pci/Makefile	2012-10-08 18:39:07.953017914 +0200
@@ -53,6 +53,7 @@ obj-$(CONFIG_SND_SIS7019) += snd-sis7019
 obj-$(CONFIG_SND_SONICVIBES) += snd-sonicvibes.o
 obj-$(CONFIG_SND_VIA82XX) += snd-via82xx.o
 obj-$(CONFIG_SND_VIA82XX_MODEM) += snd-via82xx-modem.o
+obj-$(CONFIG_SND_XENON) += snd-xenon.o
 
 obj-$(CONFIG_SND) += \
 	ac97/ \
diff -NurpP --minimal linux-3.5.4/sound/pci/snd-xenon.c linux-3.5.4-xenon/sound/pci/snd-xenon.c
--- linux-3.5.4/sound/pci/snd-xenon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.5.4-xenon/sound/pci/snd-xenon.c	2012-10-08 18:39:07.953017914 +0200
@@ -0,0 +1,687 @@
+/*
+ *  xenon_snd.c - driver for XBOX 360 soundcard.
+ *  Copyright (C) 2009 by jc4360@gmail.com
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+// #include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm-indirect.h>
+#include <sound/asoundef.h>
+
+#define DESCRIPTOR_BUFFER_SIZE (32 * sizeof(u32) * 2)
+#define CACHELINE_SIZE 128
+
+#define IRQ_DISABLE             0
+#define IRQ_ENABLE              1
+
+static struct pci_device_id snd_xenon_ids[] = {
+	{ 0x1414, 0x580c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_xenon_ids);
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+
+struct playback_device {
+	struct snd_pcm_substream *playback_substream;
+
+	int state;
+	void *dma_base_virt;
+	dma_addr_t descr_base_phys;
+	u32 *descr_base_virt;
+
+	int buffer_bytes;
+	int period_bytes;
+	int descr_bytes;
+	int gap;
+	int wptr;
+};
+
+struct snd_xenon {
+	unsigned long iobase_phys;
+	void *iobase_virt;
+
+	spinlock_t lock;
+	struct snd_card *card;
+	struct pci_dev *pci;
+
+	int irq;
+
+	dma_addr_t descr_base_phys;
+	void *descr_base_virt;
+
+	struct snd_pcm *pcm[2];
+	struct playback_device devices[2];
+
+	unsigned int dig_status;
+	unsigned int dig_pcm_status;
+
+	struct timer_list timer;
+	int timer_in_use;
+};
+
+static void cache_flush(void *addr, int size)
+{
+    void *p = addr;
+    while (size) {
+	__asm__ __volatile__ ("dcbst 0,%0" :: "r" (p));
+	p += 128;
+	size -= 128;
+    }
+    __asm__ __volatile__ ("sync" ::: "memory");
+}
+
+static inline u32 bswap32(u32 t)
+{
+	return ((t & 0xFF) << 24) | ((t & 0xFF00) << 8) | ((t & 0xFF0000) >> 8) | ((t & 0xFF000000) >> 24);
+}
+
+void xenon_smc_send_message(unsigned char *msg)
+{
+
+	void *base = ioremap_nocache(0x200ea001000, 0x1000);
+
+	while (!(readl(base + 0x84) & 4));
+	writel(4, base + 0x84);
+	writel(bswap32(*(u32 *)(msg + 0)), base + 0x80);
+	writel(bswap32(*(u32 *)(msg + 4)), base + 0x80);
+	writel(bswap32(*(u32 *)(msg + 8)), base + 0x80);
+	writel(bswap32(*(u32 *)(msg + 12)), base + 0x80);
+	writel(0, base + 0x84);
+	iounmap(base);
+}
+
+static inline void snd_xenon_set_irq_flag(struct snd_xenon *chip, int cmd)
+{
+	// enable/disable irq
+	return;
+}
+
+static irqreturn_t snd_xenon_interrupt(int irq, void *dev_id)
+{
+	printk("xenon_snd: give me an interrupt, please!\n");
+	return IRQ_HANDLED;
+}
+
+static void snd_xenon_timer_fn(unsigned long data)
+{
+	struct snd_xenon *chip = (struct snd_xenon *)data;
+	u32 reg;
+	int rptr_descr, wptr_descr, cur_len, size;
+
+	struct playback_device *device = NULL;
+	int dev_id = 0;
+
+	for (dev_id = 0; dev_id < 2; dev_id++) {
+
+		device = &chip->devices[dev_id];
+
+		spin_lock(&chip->lock);
+
+		if (device->state != 3) {
+			spin_unlock(&chip->lock);
+			continue;
+		}
+
+		reg = readl(chip->iobase_virt + 0x04 + dev_id * 0x10);
+		rptr_descr = reg & 0x1f;
+		wptr_descr = (reg & 0x1f00) >> 8;
+		cur_len = (reg >> 16) & 0xFFFF;
+
+		size = wptr_descr - rptr_descr;
+		if (size < 0) size += 32;
+		size *= device->descr_bytes;
+		size += cur_len;
+		if (wptr_descr < rptr_descr) size -= device->gap;
+		size = device->buffer_bytes - size;
+
+		if (size >= device->period_bytes) {
+			spin_unlock(&chip->lock);
+			snd_pcm_period_elapsed(device->playback_substream);
+		} else
+			spin_unlock(&chip->lock);
+	}
+
+	if (chip->timer_in_use) {
+		mod_timer(&chip->timer, jiffies + usecs_to_jiffies(200));
+	}
+
+}
+
+static struct snd_pcm_hardware snd_xenon_ana_playback_hw =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =              SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =                SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	64 * 1024,
+	.period_bytes_min =	64,
+	.period_bytes_max =	64 * 1024,
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =            0,
+};
+
+static struct snd_pcm_hardware snd_xenon_spdif_playback_hw =
+{
+	.info =                 (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =              SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =                SNDRV_PCM_RATE_48000,
+	.rate_min =             48000,
+	.rate_max =             48000,
+	.channels_min =         2,
+	.channels_max =         2,
+	.buffer_bytes_max =     64 * 1024,
+	.period_bytes_min =     64,
+	.period_bytes_max =     64 * 1024,
+	.periods_min =          1,
+	.periods_max =          1024,
+	.fifo_size =            0,
+};
+
+static int snd_xenon_playback_open(struct snd_pcm_substream *substream, int dev_id, struct snd_pcm_hardware *playback_hw)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct playback_device *device = &chip->devices[dev_id];
+
+	runtime->hw = *playback_hw;
+
+	spin_lock_irq(&chip->lock);
+
+	memset(device, 0, sizeof(struct playback_device));
+	device->playback_substream = substream;
+
+	writel(0x2000000, chip->iobase_virt + 0x08 + dev_id * 0x10);
+	device->descr_base_phys =
+		chip->descr_base_phys +  dev_id * 0x100;
+	device->descr_base_virt =
+		(u32 *)(chip->descr_base_virt + dev_id * 0x100);
+	device->state = 1;
+
+	spin_unlock_irq(&chip->lock);
+
+	return 0;
+}
+
+static int snd_xenon_ana_playback_open(struct snd_pcm_substream *substream)
+{
+	return snd_xenon_playback_open(substream, 0, &snd_xenon_ana_playback_hw);
+}
+
+static int snd_xenon_spdif_playback_open(struct snd_pcm_substream *substream)
+{
+	return snd_xenon_playback_open(substream, 1, &snd_xenon_spdif_playback_hw);
+}
+static int snd_xenon_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct playback_device *device = &chip->devices[0];
+
+	if (device->playback_substream != substream)
+		device = &chip->devices[1];
+
+	spin_lock_irq(&chip->lock);
+	device->state = 0;
+	spin_unlock_irq(&chip->lock);
+
+	if (device->dma_base_virt != NULL)
+	   iounmap(device->dma_base_virt);
+
+	device->playback_substream = NULL;
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_xenon_pcm_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *hw_params)
+{
+	int bytes = params_buffer_bytes(hw_params);
+	return snd_pcm_lib_malloc_pages(substream, bytes);
+}
+
+static int snd_xenon_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_xenon_playback_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct playback_device *device = &chip->devices[0];
+	int i , dev_id = 0;
+
+	if (device->playback_substream != substream) {
+		dev_id = 1;
+		device = &chip->devices[1];
+	}
+
+	spin_lock_irq(&chip->lock);
+
+	device->dma_base_virt =
+		ioremap_nocache(runtime->dma_addr, runtime->dma_bytes);
+
+	memset(device->dma_base_virt, 0, runtime->dma_bytes);
+	cache_flush(device->dma_base_virt, runtime->dma_bytes);
+
+	device->state = 2;
+	device->period_bytes = snd_pcm_lib_period_bytes(substream);
+	device->buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	device->descr_bytes = (device->buffer_bytes + 31 ) / 32;
+	device->gap = (device->descr_bytes << 5) -
+			    device->buffer_bytes;
+	device->wptr = -1;
+
+
+	for (i=0; i < 32; i++) {
+		device->descr_base_virt[i*2] =
+			bswap32(runtime->dma_addr + device->descr_bytes * i);
+		device->descr_base_virt[i*2 + 1] =
+			bswap32(0x80000000 | (device->descr_bytes - 1));
+	}
+	device->descr_base_virt[31*2 + 1] =
+		bswap32(0x80000000 | (device->descr_bytes - 1 - device->gap));
+	cache_flush(device->descr_base_virt, DESCRIPTOR_BUFFER_SIZE);
+
+	writel(device->descr_base_phys, chip->iobase_virt + 0x00 + dev_id * 0x10);
+	writel(0x1c08001c, chip->iobase_virt + 0x08 + dev_id * 0x10);
+	writel((dev_id==0)?0x1c:0x02009902, chip->iobase_virt + 0x0c + dev_id * 0x10);
+
+	spin_unlock_irq(&chip->lock);
+	return 0;
+}
+
+static int snd_xenon_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct playback_device *device = &chip->devices[0];
+	int dev_id = 0, ret = 0;
+	u32 reg;
+
+	if (device->playback_substream != substream) {
+		dev_id = 1;
+		device = &chip->devices[1];
+	}
+
+	spin_lock(&chip->lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		device->state = 3;
+
+		reg = readl(chip->iobase_virt + 0x08 + dev_id * 0x10);
+		writel(reg | 0x1000000, chip->iobase_virt + 0x08 + dev_id * 0x10);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		device->state = 4;
+		reg = readl(chip->iobase_virt + 0x08 + dev_id * 0x10);
+		writel(reg & ~0x1000000, chip->iobase_virt + 0x08 + dev_id * 0x10);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+	spin_unlock(&chip->lock);
+
+	return ret;
+}
+
+static snd_pcm_uframes_t snd_xenon_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct playback_device *device = &chip->devices[0];
+
+	int dev_id = 0;
+	int app_ptr, app_descr, bytes;
+	u32 reg;
+
+	if (device->playback_substream != substream) {
+		dev_id = 1;
+		device = &chip->devices[1];
+	}
+
+	spin_lock(&chip->lock);
+
+	app_ptr = frames_to_bytes(runtime, runtime->control->appl_ptr) %
+		      device->buffer_bytes;
+
+	if (app_ptr != device->wptr)
+		cache_flush(device->dma_base_virt, runtime->dma_bytes);
+
+	app_descr = app_ptr / device->descr_bytes;
+	reg = readl(chip->iobase_virt + 0x04 + dev_id * 0x10);
+	if (app_descr == (( reg & 0x1f00) >> 8))
+	    app_descr -= 1;
+	if (app_descr < 0) app_descr += 32;
+
+	device->wptr = app_ptr;
+
+	writel(app_descr << 8, chip->iobase_virt + 0x04 + dev_id * 0x10);
+
+	spin_unlock(&chip->lock);
+
+	bytes = (reg & 0x1f) * (device->descr_bytes);
+	return bytes_to_frames(substream->runtime, bytes);
+}
+
+static struct snd_pcm_ops snd_xenon_ana_playback_ops = {
+	.open =		snd_xenon_ana_playback_open,
+	.close =	snd_xenon_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_xenon_pcm_hw_params,
+	.hw_free =	snd_xenon_pcm_hw_free,
+	.prepare =	snd_xenon_playback_prepare,
+	.trigger =	snd_xenon_trigger,
+	.pointer =	snd_xenon_pointer,
+};
+
+static struct snd_pcm_ops snd_xenon_spdif_playback_ops = {
+	.open =         snd_xenon_spdif_playback_open,
+	.close =        snd_xenon_playback_close,
+	.ioctl =        snd_pcm_lib_ioctl,
+	.hw_params =    snd_xenon_pcm_hw_params,
+	.hw_free =      snd_xenon_pcm_hw_free,
+	.prepare =      snd_xenon_playback_prepare,
+	.trigger =      snd_xenon_trigger,
+	.pointer =      snd_xenon_pointer,
+};
+
+static int __devinit snd_xenon_new_pcm(struct snd_xenon *chip)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(chip->card, "Xenon Audio", 0, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = chip;
+	strcpy(pcm->name, "Analog");
+	chip->pcm[0] = pcm;
+
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_xenon_ana_playback_ops);
+
+	/* pre-allocation of buffers */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
+
+	err = snd_pcm_new(chip->card, "Xenon Audio", 1, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = chip;
+	strcpy(pcm->name, "Digital");
+	chip->pcm[1] = pcm;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_xenon_spdif_playback_ops);
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
+
+	return 0;
+}
+
+static void snd_xenon_init(struct snd_xenon *chip)
+{
+	unsigned long flags;
+	static unsigned char smc_snd[32] = {0x8d, 1, 1};
+	xenon_smc_send_message(smc_snd);
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	chip->descr_base_virt = pci_alloc_consistent(chip->pci,
+			 DESCRIPTOR_BUFFER_SIZE * 2, &chip->descr_base_phys);
+	chip->descr_base_phys &= 0x1fffffff;
+	printk("snd_xenon: descr_base_virt=0x%llx, descr_base_phys=0x%llx\n",
+		(unsigned long long)chip->descr_base_virt,
+		(unsigned long long)chip->descr_base_phys);
+
+	writel(0, chip->iobase_virt + 0x08);
+	writel(0x2000000, chip->iobase_virt + 0x08);
+	writel(chip->descr_base_phys, chip->iobase_virt + 0x00);
+
+	writel(0, chip->iobase_virt + 0x18);
+	writel(0x2000000, chip->iobase_virt + 0x18);
+	writel(chip->descr_base_phys + DESCRIPTOR_BUFFER_SIZE,
+		chip->iobase_virt + 0x10);
+
+	/* Enable IRQ output */
+	snd_xenon_set_irq_flag(chip, IRQ_ENABLE);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int snd_xenon_dev_free(struct snd_device *device);
+static int snd_xenon_free(struct snd_xenon *chip);
+
+static int __devinit snd_xenon_create(struct snd_card *card,
+				       struct pci_dev *pci,
+				       struct snd_xenon **rchip)
+{
+	struct snd_xenon *chip;
+	int err;
+
+	static struct snd_device_ops ops = {
+		.dev_free = snd_xenon_dev_free,
+	};
+	*rchip = NULL;
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	pci_set_master(pci);
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	chip->dig_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
+	chip->dig_pcm_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
+	spin_lock_init(&chip->lock);
+
+	if (!( pci_resource_flags (pci, 0) & IORESOURCE_MEM)) {
+		dev_err(&pci->dev,
+			"region #0 not an MMIO resource, aborting\n");
+		return -ENODEV;
+	}
+
+	if ((err = pci_request_regions(pci, "Xenon AudioPCI")) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+
+	chip->iobase_phys = pci_resource_start(pci, 0);
+	chip->iobase_virt = ioremap_nocache(chip->iobase_phys,
+				      pci_resource_len(pci, 0));
+
+	printk("snd_xenon: iobase_phys=0x%lx iobase_virt=0x%llx\n", chip->iobase_phys, (unsigned long long)chip->iobase_virt);
+
+	if (request_irq(pci->irq, snd_xenon_interrupt, IRQF_SHARED,
+			card->shortname, chip)) {
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		snd_xenon_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+	pci_intx(pci, IRQ_ENABLE);
+	printk("snd_xenon: irq=%x\n", chip->irq);
+
+	snd_xenon_init(chip);
+
+	if ((err = snd_xenon_new_pcm(chip)) < 0) {
+		snd_printk(KERN_WARNING "Could not to create PCM\n");
+		snd_xenon_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+						chip, &ops)) < 0) {
+		snd_xenon_free(chip);
+		return err;
+	}
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rchip = chip;
+
+	init_timer(&chip->timer);
+	chip->timer.function = snd_xenon_timer_fn;
+	chip->timer.data = (unsigned long)chip;
+	chip->timer_in_use = 1;
+	add_timer(&chip->timer);
+
+	printk("snd_xenon: driver initialized\n");
+
+	return 0;
+}
+
+static int snd_xenon_dev_free(struct snd_device *device)
+{
+	struct snd_xenon *chip = device->device_data;
+	return snd_xenon_free(chip);
+}
+
+static int snd_xenon_free(struct snd_xenon *chip)
+{
+	snd_xenon_set_irq_flag(chip, IRQ_DISABLE);
+
+	spin_lock_irq(&chip->lock);
+	chip->timer_in_use = 0;
+	spin_unlock_irq(&chip->lock);
+	del_timer_sync(&chip->timer);
+
+	if (chip->irq >= 0)
+		free_irq(chip->irq, chip);
+	if (chip->descr_base_virt)
+		pci_free_consistent(chip->pci, DESCRIPTOR_BUFFER_SIZE * 2, chip->descr_base_virt, chip->descr_base_phys);
+	if (chip->iobase_virt)
+		  iounmap(chip->iobase_virt);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	return 0;
+}
+
+static int __devinit snd_xenon_probe(struct pci_dev *pci,
+			     const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct snd_card *card;
+	struct snd_xenon *chip;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return -ENOMEM;
+
+	if ((err = snd_xenon_create(card, pci, &chip)) < 0) {
+		snd_card_free(card);
+		snd_xenon_free(chip);
+		return err;
+	}
+	card->private_data = chip;
+
+	strcpy(card->driver, "snd-xenon");
+	sprintf(card->shortname, "Xenon AudioPCI");
+	sprintf(card->longname, "%s at 0x%lx irq %i",
+				card->shortname, chip->iobase_phys, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		snd_xenon_free(chip);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+
+	return 0;
+}
+
+static void __devexit snd_xenon_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "snd-xenon",
+	.id_table = snd_xenon_ids,
+	.probe = snd_xenon_probe,
+	.remove = __devexit_p(snd_xenon_remove),
+};
+
+static int __init alsa_card_xenon_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit alsa_card_xenon_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_xenon_init)
+module_exit(alsa_card_xenon_exit)
+
+MODULE_AUTHOR("jc4360@gmail.com");
+MODULE_DESCRIPTION("Xenon Audio Driver");
+MODULE_LICENSE("GPL");
