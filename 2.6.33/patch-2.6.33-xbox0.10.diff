diff -NurpP --minimal linux-2.6.33/arch/powerpc/boot/Makefile linux-2.6.33-xbox0.10/arch/powerpc/boot/Makefile
--- linux-2.6.33/arch/powerpc/boot/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/boot/Makefile	2010-03-28 00:33:59.000000000 +0100
@@ -172,6 +172,7 @@ image-$(CONFIG_PPC_PSERIES)		+= zImage.p
 image-$(CONFIG_PPC_MAPLE)		+= zImage.pseries
 image-$(CONFIG_PPC_IBM_CELL_BLADE)	+= zImage.pseries
 image-$(CONFIG_PPC_PS3)			+= dtbImage.ps3
+image-$(CONFIG_PPC_XENON)		+= zImage.xenon
 image-$(CONFIG_PPC_CELLEB)		+= zImage.pseries
 image-$(CONFIG_PPC_CELL_QPACE)		+= zImage.pseries
 image-$(CONFIG_PPC_CHRP)		+= zImage.chrp
@@ -301,6 +302,11 @@ $(obj)/dtbImage.%: vmlinux $(wrapperbits
 $(obj)/vmlinux.strip: vmlinux
 	$(STRIP) -s -R .comment $< -o $@
 
+$(obj)/zImage.xenon: $(obj)/vmlinux.strip
+	$(OBJCOPY) -O elf32-powerpc $< $@
+	@ test -e /mnt/nfsroot/tftpboot && \
+		cp -f $@ /mnt/nfsroot/tftpboot/zImage_2.6.33.xenon || true
+
 # The iseries hypervisor won't take an ET_DYN executable, so this
 # changes the type (byte 17) in the file to ET_EXEC (2).
 $(obj)/zImage.iseries: vmlinux
diff -NurpP --minimal linux-2.6.33/arch/powerpc/include/asm/cputable.h linux-2.6.33-xbox0.10/arch/powerpc/include/asm/cputable.h
--- linux-2.6.33/arch/powerpc/include/asm/cputable.h	2010-03-21 15:30:38.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/include/asm/cputable.h	2010-03-19 23:49:22.000000000 +0100
@@ -416,6 +416,11 @@ extern const char *powerpc_base_platform
 	    CPU_FTR_PAUSE_ZERO | CPU_FTR_CI_LARGE_PAGE | \
 	    CPU_FTR_CELL_TB_BUG | CPU_FTR_CP_USE_DCBTZ | \
 	    CPU_FTR_UNALIGNED_LD_STD)
+#define CPU_FTRS_XENON (CPU_FTR_USE_TB | CPU_FTR_LWSYNC | \
+	    CPU_FTR_PPCAS_ARCH_V2 | CPU_FTR_CTRL | \
+	    CPU_FTR_MMCRA | CPU_FTR_SMT | \
+	    CPU_FTR_CI_LARGE_PAGE | \
+	    CPU_FTR_CELL_TB_BUG )
 #define CPU_FTRS_PA6T (CPU_FTR_USE_TB | CPU_FTR_LWSYNC | \
 	    CPU_FTR_PPCAS_ARCH_V2 | \
 	    CPU_FTR_ALTIVEC_COMP | CPU_FTR_CI_LARGE_PAGE | \
@@ -499,6 +504,7 @@ enum {
 #ifdef CONFIG_E500
 	    CPU_FTRS_E500 & CPU_FTRS_E500_2 & CPU_FTRS_E500MC &
 #endif
+	    CPU_FTRS_XENON &
 	    CPU_FTRS_POSSIBLE,
 };
 #endif /* __powerpc64__ */
diff -NurpP --minimal linux-2.6.33/arch/powerpc/Kconfig linux-2.6.33-xbox0.10/arch/powerpc/Kconfig
--- linux-2.6.33/arch/powerpc/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/Kconfig	2010-03-20 05:38:32.000000000 +0100
@@ -26,6 +26,15 @@ config MMU
 	bool
 	default y
 
+config PPC_XENON
+	bool "Xenon"
+	depends on PPC64
+	select PPC_NATIVE
+	default y
+	help
+	  This option enables support for the Xbox 360 game console
+	  without a hypervisor.
+
 config GENERIC_CMOS_UPDATE
 	def_bool y
 
@@ -986,3 +995,4 @@ config PPC_LIB_RHEAP
 	bool
 
 source "arch/powerpc/kvm/Kconfig"
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/cputable.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/cputable.c
--- linux-2.6.33/arch/powerpc/kernel/cputable.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/cputable.c	2010-03-19 23:11:02.000000000 +0100
@@ -480,6 +480,17 @@ static struct cpu_spec __initdata cpu_sp
 		.machine_check		= machine_check_generic,
 		.platform		= "ppc-cell-be",
 	},
+	{	/* Xenon */
+		.pvr_mask		= 0xffff0000,
+		.pvr_value		= 0x00710000,
+		.cpu_name		= "Xenon",
+		.cpu_features		= CPU_FTRS_XENON,
+		.cpu_user_features	= COMMON_USER_PPC64 |
+			PPC_FEATURE_SMT,
+		.icache_bsize		= 128,
+		.dcache_bsize		= 128,
+		.platform		= "xenon",
+	},
 	{	/* PA Semi PA6T */
 		.pvr_mask		= 0x7fff0000,
 		.pvr_value		= 0x00900000,
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/crash.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/crash.c
--- linux-2.6.33/arch/powerpc/kernel/crash.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/crash.c	2010-03-21 04:41:46.000000000 +0100
@@ -299,7 +299,7 @@ static inline void crash_kexec_stop_spus
  */
 int crash_shutdown_register(crash_shutdown_t handler)
 {
-	unsigned int i, rc;
+	unsigned int i, rc = 0;
 
 	spin_lock(&crash_handlers_lock);
 	for (i = 0 ; i < CRASH_HANDLER_MAX; i++)
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/head_64.S linux-2.6.33-xbox0.10/arch/powerpc/kernel/head_64.S
--- linux-2.6.33/arch/powerpc/kernel/head_64.S	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/head_64.S	2010-03-22 03:53:04.000000000 +0100
@@ -565,8 +565,11 @@ _GLOBAL(pmac_secondary_start)
 	.section ".text";
 	.align 2 ;
 
+/*
 	.globl	__secondary_start
 __secondary_start:
+*/
+_INIT_GLOBAL(__secondary_start)
 	/* Set thread priority to MEDIUM */
 	HMT_MEDIUM
 
@@ -609,7 +612,7 @@ END_FW_FTR_SECTION_IFCLR(FW_FEATURE_ISER
  * zero the stack back-chain pointer and get the TOC virtual address
  * before going into C code.
  */
-_GLOBAL(start_secondary_prolog)
+_INIT_GLOBAL(start_secondary_prolog)
 	ld	r2,PACATOC(r13)
 	li	r3,0
 	std	r3,0(r1)		/* Zero the stack frame pointer	*/
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/misc_64.S linux-2.6.33-xbox0.10/arch/powerpc/kernel/misc_64.S
--- linux-2.6.33/arch/powerpc/kernel/misc_64.S	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/misc_64.S	2010-03-19 22:53:41.000000000 +0100
@@ -235,7 +235,7 @@ _GLOBAL(__flush_dcache_icache)
 	blr
 
 
-#if defined(CONFIG_PPC_PMAC) || defined(CONFIG_PPC_MAPLE)
+#if defined(CONFIG_PPC_PMAC) || defined(CONFIG_PPC_MAPLE) || defined(CONFIG_PPC_XENON)
 /*
  * Do an IO access in real mode
  */
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/pci_64.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/pci_64.c
--- linux-2.6.33/arch/powerpc/kernel/pci_64.c	2010-03-21 15:30:39.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/pci_64.c	2010-03-21 16:21:56.000000000 +0100
@@ -146,7 +146,7 @@ int __devinit pcibios_map_io_space(struc
 	if (bus->self) {
 		pr_debug("IO mapping for PCI-PCI bridge %s\n",
 			 pci_name(bus->self));
-		pr_debug("  virt=0x%016llx...0x%016llx\n",
+		pr_debug("  virt=0x%016lx...0x%016lx\n",
 			 bus->resource[0]->start + _IO_BASE,
 			 bus->resource[0]->end + _IO_BASE);
 		return 0;
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/process.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/process.c
--- linux-2.6.33/arch/powerpc/kernel/process.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/process.c	2010-03-29 18:25:14.000000000 +0200
@@ -1189,3 +1189,8 @@ unsigned long randomize_et_dyn(unsigned 
 
 	return ret;
 }
+
+void arch_trigger_all_cpu_backtrace(void)
+{
+	panic("arch_trigger_all_cpu_backtrace() not implemented yet\n");
+}
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/prom.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/prom.c
--- linux-2.6.33/arch/powerpc/kernel/prom.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/prom.c	2010-03-27 20:11:29.000000000 +0100
@@ -14,6 +14,7 @@
  */
 
 #undef DEBUG
+#define DEBUG
 
 #include <stdarg.h>
 #include <linux/kernel.h>
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/setup_64.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/setup_64.c
--- linux-2.6.33/arch/powerpc/kernel/setup_64.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/setup_64.c	2010-03-22 03:49:29.000000000 +0100
@@ -222,7 +222,7 @@ void __init early_setup(unsigned long dt
 }
 
 #ifdef CONFIG_SMP
-void early_setup_secondary(void)
+void __cpuinit early_setup_secondary(void)
 {
 	/* Mark interrupts enabled in PACA */
 	get_paca()->soft_enabled = 0;
diff -NurpP --minimal linux-2.6.33/arch/powerpc/kernel/udbg.c linux-2.6.33-xbox0.10/arch/powerpc/kernel/udbg.c
--- linux-2.6.33/arch/powerpc/kernel/udbg.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/kernel/udbg.c	2010-03-19 22:58:04.000000000 +0100
@@ -62,6 +62,8 @@ void __init udbg_early_init(void)
 	udbg_init_cpm();
 #elif defined(CONFIG_PPC_EARLY_DEBUG_USBGECKO)
 	udbg_init_usbgecko();
+#elif defined(CONFIG_PPC_EARLY_DEBUG_XENON)
+//	udbg_init_xenon();
 #endif
 
 #ifdef CONFIG_PPC_EARLY_DEBUG
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/Makefile linux-2.6.33-xbox0.10/arch/powerpc/platforms/Makefile
--- linux-2.6.33/arch/powerpc/platforms/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/Makefile	2010-03-19 22:58:35.000000000 +0100
@@ -20,5 +20,6 @@ obj-$(CONFIG_PPC_MAPLE)		+= maple/
 obj-$(CONFIG_PPC_PASEMI)	+= pasemi/
 obj-$(CONFIG_PPC_CELL)		+= cell/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
+obj-$(CONFIG_PPC_XENON)		+= xenon/
 obj-$(CONFIG_EMBEDDED6xx)	+= embedded6xx/
 obj-$(CONFIG_AMIGAONE)		+= amigaone/
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/hardware.c linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/hardware.c
--- linux-2.6.33/arch/powerpc/platforms/xenon/hardware.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/hardware.c	2010-03-29 00:29:53.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *  Xenon hardware related routines.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+
+static int __init xenon_hwmon_init(void)
+{
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("xenon-hwmon", -1, NULL, 0);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
+
+module_init(xenon_hwmon_init);
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/interrupt.c linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/interrupt.c
--- linux-2.6.33/arch/powerpc/platforms/xenon/interrupt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/interrupt.c	2010-03-29 19:40:51.000000000 +0200
@@ -0,0 +1,320 @@
+/*
+ * Xenon interrupt controller,
+ *
+ * Maintained by: Felix Domke <tmbinc@elitedvb.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License v2
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/percpu.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/prom.h>
+#include <asm/ptrace.h>
+#include <asm/machdep.h>
+
+#include "interrupt.h"
+
+static void *iic_base,
+	*bridge_base, // ea000000
+	*biu,         // e1000000
+	*graphics;    // ec800000
+static struct irq_host *host;
+
+#define XENON_NR_IRQS 128
+
+#define PRIO_IPI_4       0x08
+#define PRIO_IPI_3       0x10
+#define PRIO_SMM         0x14
+#define PRIO_SFCX        0x18
+#define PRIO_SATA_HDD    0x20
+#define PRIO_SATA_CDROM  0x24
+#define PRIO_OHCI_0      0x2c
+#define PRIO_EHCI_0      0x30
+#define PRIO_OHCI_1      0x34
+#define PRIO_EHCI_1      0x38
+#define PRIO_XMA         0x40
+#define PRIO_AUDIO       0x44
+#define PRIO_ENET        0x4C
+#define PRIO_XPS         0x54
+#define PRIO_GRAPHICS    0x58
+#define PRIO_PROFILER    0x60
+#define PRIO_BIU         0x64
+#define PRIO_IOC         0x68
+#define PRIO_FSB         0x6c
+#define PRIO_IPI_2       0x70
+#define PRIO_CLOCK       0x74
+#define PRIO_IPI_1       0x78
+
+/* bridge (PCI) IRQ -> CPU IRQ */
+static int xenon_pci_irq_map[] = {
+		PRIO_CLOCK, PRIO_SATA_CDROM, PRIO_SATA_HDD, PRIO_SMM,
+		PRIO_OHCI_0, PRIO_EHCI_0, PRIO_OHCI_1, PRIO_EHCI_1,
+		-1, -1, PRIO_ENET, PRIO_XMA,
+		PRIO_AUDIO, PRIO_SFCX, -1, -1};
+
+static void disconnect_pci_irq(int prio)
+{
+	int i;
+
+	for (i=0; i<0x10; ++i)
+		if (xenon_pci_irq_map[i] == prio)
+			writel(0, bridge_base + 0x10 + i * 4);
+}
+
+	/* connects an PCI IRQ to CPU #0 */
+static void connect_pci_irq(int prio)
+{
+	int i;
+
+	for (i=0; i<0x10; ++i)
+		if (xenon_pci_irq_map[i] == prio)
+			writel(0x0800180 | (xenon_pci_irq_map[i]/4), bridge_base + 0x10 + i * 4);
+}
+
+static void iic_mask(unsigned int irq)
+{
+	disconnect_pci_irq(irq);
+}
+
+static void iic_unmask(unsigned int irq)
+{
+	int i;
+	connect_pci_irq(irq);
+	for (i=0; i<6; ++i)
+		out_be64(iic_base + i * 0x1000 + 0x68, 0);
+}
+
+void xenon_init_irq_on_cpu(int cpu)
+{
+		/* init that cpu's interrupt controller */
+	out_be64(iic_base + cpu * 0x1000 + 0x70, 0x7c);
+	out_be64(iic_base + cpu * 0x1000 + 0x8, 0);      /* irql */
+	out_be64(iic_base + cpu * 0x1000, 1<<cpu);       /* "who am i" */
+
+		/* ack all outstanding interrupts */
+	while (in_be64(iic_base + cpu * 0x1000 + 0x50) != 0x7C);
+	out_be64(iic_base + cpu * 0x1000 + 0x68, 0);
+}
+
+static void iic_eoi(unsigned int irq)
+{
+	int cpu = hard_smp_processor_id();
+	void *my_iic_base = iic_base + cpu * 0x1000;
+	out_be64(my_iic_base + 0x68, 0);
+	mb();
+	in_be64(my_iic_base + 0x8);
+}
+
+static struct irq_chip xenon_pic = {
+	.typename = " XENON-PIC ",
+	.mask = iic_mask,
+	.unmask = iic_unmask,
+	.eoi = iic_eoi,
+};
+
+// struct irq_desc irq_desc[XENON_NR_IRQS];
+
+/* Get an IRQ number from the pending state register of the IIC */
+static unsigned int iic_get_irq(void)
+{
+	int cpu = hard_smp_processor_id();
+	void *my_iic_base;
+	int index;
+
+	my_iic_base = iic_base + cpu * 0x1000;
+
+	index = in_be64(my_iic_base + 0x50) & 0x7F; /* read destructive pending interrupt */
+
+	out_be64(my_iic_base + 0x08, 0x7c); /* current task priority */
+	mb();
+	in_be64(my_iic_base + 0x8);
+
+		/* HACK: we will handle some (otherwise unhandled) interrupts here
+		   to prevent them flooding. */
+	switch (index) {
+	case PRIO_GRAPHICS:
+		writel(0, graphics + 0xed0);
+		writel(0, graphics + 0x6540);
+		break;
+	case PRIO_IOC:
+		writel(0, biu + 0x4002c);
+		break;
+	case PRIO_CLOCK:
+		writel(0, bridge_base + 0x106C);
+		break;
+	default:
+		break;
+	}
+
+#if 0
+	/* should be handled */
+	if (index == PRIO_IPI_1)
+		return index;
+	if (index == PRIO_IPI_2)
+		return index;
+	if (index == PRIO_IPI_3)
+		return index;
+	if (index == PRIO_IPI_4)
+		return index;
+#endif
+
+	/* HACK: we need to ACK unhandled interrupts here */
+	if (!irq_desc[index].action) {
+		printk(KERN_WARNING "IRQ 0x%02x unhandled, doing local EOI\n", index);
+		out_be64(my_iic_base + 0x60, 0);
+		iic_eoi(index);
+		return NO_IRQ;
+	}
+
+	if (index == 0x7C)
+		return NO_IRQ;
+	else
+		return index;
+}
+
+static int xenon_irq_host_map(struct irq_host *h, unsigned int virq,
+				irq_hw_number_t hw)
+{
+	set_irq_chip_and_handler(virq, &xenon_pic, handle_percpu_irq);
+	return 0;
+}
+
+static int xenon_irq_host_match(struct irq_host *h, struct device_node *node)
+{
+	return h->host_data != NULL && node == h->host_data;
+}
+
+static struct irq_host_ops xenon_irq_host_ops = {
+	.map = xenon_irq_host_map,
+	.match = xenon_irq_host_match,
+};
+
+void __init xenon_iic_init_IRQ(void)
+{
+	int i;
+	struct device_node *dn;
+	struct resource res;
+
+			/* search for our interrupt controller inside the device tree */
+	for (dn = NULL;
+	     (dn = of_find_node_by_name(dn, "interrupt-controller")) != NULL;) {
+		if (!of_device_is_compatible(dn, "xenon"))
+			continue;
+
+		if (of_address_to_resource(dn, 0, &res))
+		{
+			printk(KERN_WARNING "xenon IIC: Can't resolve addresses\n");
+			of_node_put(dn);
+			return;
+		}
+
+		irq_set_virq_count(0x80);
+		iic_base = ioremap_nocache(res.start, 0x10000);
+
+		host = irq_alloc_host(NULL, IRQ_HOST_MAP_NOMAP, 0, &xenon_irq_host_ops, 0);
+		host->host_data = of_node_get(dn);
+		BUG_ON(host == NULL);
+		irq_set_default_host(host);
+	}
+
+	ppc_md.get_irq = iic_get_irq;
+
+	bridge_base = ioremap_nocache(0xea000000, 0x10000);
+	biu = ioremap_nocache(0xe1000000, 0x2000000);
+	graphics = ioremap_nocache(0xec800000, 0x10000);
+
+		/* initialize interrupts */
+	writel(0, bridge_base);
+	writel(0x40000000, bridge_base + 4);
+
+	writel(0x40000000, biu + 0x40074);
+	writel(0xea000050, biu + 0x40078);
+
+	writel(0, bridge_base + 0xc);
+	writel(0x3, bridge_base);
+
+		/* disconnect all PCI IRQs until they are requested */
+	for (i=0; i<0x10; ++i)
+		writel(0, bridge_base + 0x10 + i * 4);
+
+	xenon_init_irq_on_cpu(0);
+}
+
+#ifdef CONFIG_SMP
+
+static int ipi_to_prio(int ipi)
+{
+	switch (ipi) {
+	case PPC_MSG_CALL_FUNCTION:
+		return PRIO_IPI_1;
+		break;
+	case PPC_MSG_CALL_FUNC_SINGLE:
+		return PRIO_IPI_2;
+		break;
+	case PPC_MSG_RESCHEDULE:
+		return PRIO_IPI_3;
+		break;
+	case PPC_MSG_DEBUGGER_BREAK:
+		return PRIO_IPI_4;
+		break;
+	default:
+		printk("unhandled ipi %d\n", ipi);
+		BUG();
+	}
+	return 0;
+}
+
+void xenon_cause_IPI(int target, int msg)
+{
+	int ipi_prio;
+
+	ipi_prio = ipi_to_prio(msg);
+
+	out_be64(iic_base + 0x10 + hard_smp_processor_id() * 0x1000, (0x10000<<target) | ipi_prio);
+}
+
+static irqreturn_t xenon_ipi_action(int irq, void *dev_id)
+{
+	int ipi = (int)(long)dev_id;
+	smp_message_recv(ipi);
+	return IRQ_HANDLED;
+}
+
+static void xenon_request_ipi(int ipi, const char *name)
+{
+	int prio = ipi_to_prio(ipi), virq;
+
+	virq = irq_create_mapping(host, prio);
+	if (virq == NO_IRQ)
+	{
+		printk(KERN_ERR
+				"xenon_request_ipi: failed to map IPI%d (%s)\n", prio, name);
+		return;
+	}
+
+	if (request_irq(prio, xenon_ipi_action, IRQF_DISABLED,
+			name, (void *)(long)ipi))
+		printk(KERN_ERR "request irq for ipi failed!\n");
+}
+
+void xenon_request_IPIs(void)
+{
+	xenon_request_ipi(PPC_MSG_CALL_FUNCTION, "IPI-call");
+	xenon_request_ipi(PPC_MSG_RESCHEDULE, "IPI-resched");
+	xenon_request_ipi(PPC_MSG_CALL_FUNC_SINGLE, "IPI-call-single");
+#ifdef CONFIG_DEBUGGER
+	xenon_request_ipi(PPC_MSG_DEBUGGER_BREAK, "IPI-debug");
+#endif /* CONFIG_DEBUGGER */
+}
+
+#endif
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/interrupt.h linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/interrupt.h
--- linux-2.6.33/arch/powerpc/platforms/xenon/interrupt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/interrupt.h	2010-03-19 22:53:41.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef XENON_INTERRUPT_H
+#define XENON_INTERRUPT_H
+
+extern void xenon_init_irq_on_cpu(int cpu);
+extern void __init xenon_iic_init_IRQ(void);
+extern void xenon_cause_IPI(int target, int msg);
+extern void xenon_request_IPIs(void);
+
+#endif /* ASM_XENON_PIC_H */
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/Makefile linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/Makefile
--- linux-2.6.33/arch/powerpc/platforms/xenon/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/Makefile	2010-03-29 00:28:58.000000000 +0200
@@ -0,0 +1,3 @@
+obj-y += setup.o interrupt.o pci.o time.o hardware.o
+
+obj-$(CONFIG_SMP) += smp.o
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/pci.c linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/pci.c
--- linux-2.6.33/arch/powerpc/platforms/xenon/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/pci.c	2010-03-30 04:25:15.000000000 +0200
@@ -0,0 +1,315 @@
+/*
+ * Xenon PCI support
+ * Maintained by: Felix Domke <tmbinc@elitedvb.net>
+ * Minor modification by: wolie <wolie@telia.com>
+ * based on:
+ * Copyright (C) 2004 Benjamin Herrenschmuidt (benh@kernel.crashing.org),
+ *		      IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+// #define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+
+#include <asm/sections.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/machdep.h>
+#include <asm/iommu.h>
+#include <asm/ppc-pci.h>
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+#define OFFSET(bus, slot, func)	\
+	((((bus) << 8) + PCI_DEVFN(slot, func)) << 12)
+
+static int xenon_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+			      int offset, int len, u32 *val)
+{
+	struct pci_controller *hose;
+	unsigned int slot = PCI_SLOT(devfn);
+	unsigned int func = PCI_FUNC(devfn);
+	void* addr;
+
+	hose = pci_bus_to_host(bus);
+	if (hose == NULL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	DBG("xenon_pci_read_config, slot %d, func %d\n", slot, func);
+
+#if 0
+	if (PCI_SLOT(devfn) >= 32)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_SLOT(devfn) == 3)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_SLOT(devfn) == 6)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_SLOT(devfn) == 0xB)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (PCI_FUNC(devfn) >= 2)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+#endif
+	DBG("xenon_pci_read_config, %p, devfn=%d, offset=%d, len=%d\n", bus, devfn, offset, len);
+
+	addr = ((void*)hose->cfg_addr) + offset;
+
+	/* map GPU to slot 0x0f */
+	if (slot == 0x0f)
+		addr += OFFSET(0, 0x02, func);
+	else
+		addr += OFFSET(1, slot, func);
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		*val = in_8((u8 *)addr);
+		break;
+	case 2:
+		*val = in_le16((u16 *)addr);
+		break;
+	default:
+		*val = in_le32((u32 *)addr);
+		break;
+	}
+	DBG("->%08x\n", (int)*val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int xenon_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+			       int offset, int len, u32 val)
+{
+	struct pci_controller *hose;
+	unsigned int slot = PCI_SLOT(devfn);
+	unsigned int func = PCI_FUNC(devfn);
+	void *addr;
+
+	hose = pci_bus_to_host(bus);
+	if (hose == NULL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	DBG("xenon_pci_write_config, slot %d, func %d\n", slot, func);
+
+	if (PCI_SLOT(devfn) >= 32)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+#if 0
+	if (PCI_SLOT(devfn) == 3)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+#endif
+	DBG("xenon_pci_write_config, %p, devfn=%d, offset=%x, len=%d, val=%08x\n", bus, devfn, offset, len, val);
+
+	addr = ((void*)hose->cfg_addr) + offset;
+
+	/* map GPU to slot 0x0f */
+	if (slot == 0x0f)
+		addr += OFFSET(0, 0x02, func);
+	else
+		addr += OFFSET(1, slot, func);
+
+	if (len == 4)
+		DBG("was: %08x\n", readl(addr));
+	if (len == 2)
+		DBG("was: %04x\n", readw(addr));
+	if (len == 1)
+		DBG("was: %02x\n", readb(addr));
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		writeb(val, addr);
+		break;
+	case 2:
+		writew(val, addr);
+		break;
+	default:
+		writel(val, addr);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops xenon_pci_ops =
+{
+	.read	= xenon_pci_read_config,
+	.write	= xenon_pci_write_config,
+};
+
+
+#if 1
+void __init xenon_pci_init(void)
+{
+	struct pci_controller *hose;
+	struct device_node *np, *root;
+	struct device_node *dev = NULL;
+
+	root = of_find_node_by_path("/");
+	if (root == NULL) {
+		printk(KERN_CRIT "xenon_pci_init: can't find root of device tree\n");
+		return;
+	}
+	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;) {
+		if (np->name == NULL)
+			continue;
+		// printk("found node %p %s\n", np, np->name);
+		if (strcmp(np->name, "pci") == 0) {
+			of_node_get(np);
+			dev = np;
+		}
+	}
+	of_node_put(root);
+
+	if (!dev)
+	{
+		printk("couldn't find PCI node!\n");
+		return;
+	}
+
+	hose = pcibios_alloc_controller(dev);
+	if (hose == NULL)
+	{
+		printk("pcibios_alloc_controller failed!\n");
+		return;
+	}
+
+	hose->first_busno = 0;
+	hose->last_busno = 1;
+
+	hose->ops = &xenon_pci_ops;
+	hose->cfg_addr = ioremap(0xd0000000, 0x1000000);
+
+	pci_process_bridge_OF_ranges(hose, dev, 1);
+
+	/* Setup the linkage between OF nodes and PHBs */
+	pci_devs_phb_init();
+
+//	of_rescan_bus(root, ci_bus *bus)
+
+	/* Tell pci.c to not change any resource allocations.  */
+	pci_probe_only = 1;
+
+	of_node_put(dev);
+	DBG("PCI initialized\n");
+
+	pci_io_base = 0;
+
+	// pcibios_scan_phb(hose, dev);
+
+	ppc_md.pci_dma_dev_setup = NULL;
+	ppc_md.pci_dma_bus_setup = NULL;
+	set_pci_dma_ops(&dma_direct_ops);
+}
+
+#else
+
+
+static int __init xenon_add_bridge(struct device_node *dev)
+{
+	int len;
+	struct pci_controller *hose;
+	struct resource rsrc;
+	char *disp_name;
+	const int *bus_range;
+	int primary = 1, has_address = 0;
+
+	printk(KERN_DEBUG "Adding PCI host bridge %s\n", dev->full_name);
+
+	/* Fetch host bridge registers address */
+	has_address = (of_address_to_resource(dev, 0, &rsrc) == 0);
+
+	/* Get bus range if any */
+	bus_range = of_get_property(dev, "bus-range", &len);
+	if (bus_range == NULL || len < 2 * sizeof(int)) {
+		printk(KERN_WARNING "Can't get bus-range for %s, assume"
+		       " bus 0\n", dev->full_name);
+	}
+
+	hose = pcibios_alloc_controller(dev);
+	if (!hose)
+		return -ENOMEM;
+	hose->first_busno = bus_range ? bus_range[0] : 0;
+	hose->last_busno = bus_range ? bus_range[1] : 0xff;
+
+	hose->ops = &xenon_pci_ops;
+
+	/* FIXME: should come from config */
+	hose->cfg_addr = ioremap(0xd0000000, 0x1000000);
+
+	disp_name = NULL;
+
+	printk(KERN_INFO "Found %s PCI host bridge at 0x%016llx. "
+	       "Firmware bus number: %d->%d\n",
+		disp_name, (unsigned long long)rsrc.start, hose->first_busno,
+		hose->last_busno);
+
+	printk(KERN_DEBUG " ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",
+		hose, hose->cfg_addr, hose->cfg_data);
+
+	/* Interpret the "ranges" property */
+	/* This also maps the I/O region and sets isa_io/mem_base */
+	pci_process_bridge_OF_ranges(hose, dev, primary);
+
+	/* Fixup "bus-range" OF property */
+	// fixup_bus_range(dev);
+
+	return 0;
+}
+
+void __init xenon_pci_init(void)
+{
+	struct device_node *np, *root;
+
+	ppc_pci_set_flags(PPC_PCI_CAN_SKIP_ISA_ALIGN);
+
+	root = of_find_node_by_path("/");
+	if (root == NULL) {
+		printk(KERN_CRIT "xenon_pci_init: can't find root "
+		       "of device tree\n");
+		return;
+	}
+	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;) {
+		if (np->name == NULL)
+			continue;
+		if (strcmp(np->name, "pci") == 0) {
+			if (xenon_add_bridge(np) == 0)
+				of_node_get(np);
+		}
+	}
+	of_node_put(root);
+
+	/* Setup the linkage between OF nodes and PHBs */
+	pci_devs_phb_init();
+
+
+	/* We can allocate missing resources if any */
+	pci_probe_only = 0;
+	pci_probe_only = 1;
+
+	/* do we need that? */
+	pci_io_base = 0;
+
+	/* do we need that? */
+	ppc_md.pci_dma_dev_setup = NULL;
+	ppc_md.pci_dma_bus_setup = NULL;
+	set_pci_dma_ops(&dma_direct_ops);
+}
+
+#endif
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/pci.h linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/pci.h
--- linux-2.6.33/arch/powerpc/platforms/xenon/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/pci.h	2010-03-19 22:53:41.000000000 +0100
@@ -0,0 +1,7 @@
+#ifndef XENON_PCI_H
+#define XENON_PCI_H
+
+extern void __init xenon_pci_init(void);
+
+#endif
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/setup.c linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/setup.c
--- linux-2.6.33/arch/powerpc/platforms/xenon/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/setup.c	2010-03-25 07:24:27.000000000 +0100
@@ -0,0 +1,151 @@
+/*
+ *  linux/arch/powerpc/platforms/xenon/xenon_setup.c
+ *
+ *  Maintained by: Felix Domke <tmbinc@elitedvb.net>
+ *  Minor modification by: wolie <wolie@telia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+// #define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/root_dev.h>
+#include <linux/console.h>
+#include <linux/kexec.h>
+
+#include <asm/mmu-hash64.h>
+
+#include <asm/mmu.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/ppc-pci.h>
+#include "interrupt.h"
+#include "pci.h"
+#include "smp.h"
+
+static void xenon_show_cpuinfo(struct seq_file *m)
+{
+	struct device_node *root;
+	const char *model = "";
+
+	root = of_find_node_by_path("/");
+	if (root)
+		model = of_get_property(root, "model", NULL);
+	seq_printf(m, "machine\t\t: %s\n", model);
+	of_node_put(root);
+}
+
+static void __init xenon_init_irq(void)
+{
+	xenon_iic_init_IRQ();
+}
+
+static void __init xenon_setup_arch(void)
+{
+#ifdef CONFIG_SMP
+	smp_init_xenon();
+#endif
+		/* init to some ~sane value until calibrate_delay() runs */
+	loops_per_jiffy = 50000000;
+
+	if (ROOT_DEV == 0)
+		ROOT_DEV = Root_SDA1;
+
+	xenon_pci_init();
+#ifdef CONFIG_DUMMY_CONSOLE
+	conswitchp = &dummy_con;
+#endif
+}
+
+static int __init xenon_probe(void)
+{
+	unsigned long root = of_get_flat_dt_root();
+
+	if (!of_flat_dt_is_compatible(root, "XENON"))
+		return 0;
+
+	hpte_init_native();
+
+	return 1;
+}
+
+static void xenon_panic(char *str)
+{
+	smp_send_stop();
+	printk("\n");
+	printk("   System does not reboot automatically.\n");
+	printk("   Please press POWER button.\n");
+	printk("\n");
+
+	local_irq_disable();
+	while (1) ;
+}
+
+void xenon_smc_restart(char *cmd);
+
+static void xenon_restart(char *cmd)
+{
+	printk("   System restart ... \n");
+
+	smp_send_stop();
+	xenon_smc_restart(cmd);
+
+	local_irq_disable();
+	while (1) ;
+}
+
+void xenon_smc_power_off(void);
+
+static void xenon_power_off(void)
+{
+	printk("   System power off ... \n");
+
+	smp_send_stop();
+	xenon_smc_power_off();
+
+	local_irq_disable();
+	while (1) ;
+}
+
+void xenon_smc_halt(void);
+
+static void xenon_halt(void)
+{
+	printk("   System halt ... \n");
+
+	smp_send_stop();
+	xenon_smc_halt();
+
+	local_irq_disable();
+	while (1) ;
+}
+
+#if 0
+static int xenon_check_legacy_ioport(unsigned int baseport)
+{
+	return -ENODEV;
+}
+#endif
+
+define_machine(xenon) {
+	.name			= "Xenon",
+	.probe			= xenon_probe,
+	.setup_arch		= xenon_setup_arch,
+	.show_cpuinfo		= xenon_show_cpuinfo,
+	.calibrate_decr		= generic_calibrate_decr,
+	.init_IRQ       	= xenon_init_irq,
+	.panic			= xenon_panic,
+	.restart		= xenon_restart,
+	.power_off		= xenon_power_off,
+	.halt			= xenon_halt,
+#if defined(CONFIG_KEXEC)
+	.machine_kexec		= default_machine_kexec,
+	.machine_kexec_prepare	= default_machine_kexec_prepare,
+	.machine_crash_shutdown	= default_machine_crash_shutdown,
+#endif
+};
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/smp.c linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/smp.c
--- linux-2.6.33/arch/powerpc/platforms/xenon/smp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/smp.c	2010-03-19 22:53:41.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * SMP support for Xenon machines.
+ *
+ * Based on CBE's smp.c.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+// #define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/cpu.h>
+#include <linux/module.h>
+#include <asm/machdep.h>
+#include "interrupt.h"
+
+static int __init smp_xenon_probe(void)
+{
+	xenon_request_IPIs();
+
+	return cpus_weight(cpu_possible_map);
+}
+
+static void __devinit smp_xenon_setup_cpu(int cpu)
+{
+	if (cpu != boot_cpuid)
+		xenon_init_irq_on_cpu(cpu);
+}
+
+static void __devinit smp_xenon_kick_cpu(int nr)
+{
+	BUG_ON(nr < 0 || nr >= NR_CPUS);
+
+	pr_debug("smp_xenon_kick_cpu %d\n", nr);
+
+	/*
+	 * The processor is currently spinning, waiting for the
+	 * cpu_start field to become non-zero After we set cpu_start,
+	 * the processor will continue on to secondary_start
+	 */
+	paca[nr].cpu_start = 1;
+}
+
+static int smp_xenon_cpu_bootable(unsigned int nr)
+{
+	/* Special case - we inhibit secondary thread startup
+	 * during boot if the user requests it.  Odd-numbered
+	 * cpus are assumed to be secondary threads.
+	 */
+	if (system_state < SYSTEM_RUNNING &&
+	    cpu_has_feature(CPU_FTR_SMT) &&
+	    !smt_enabled_at_boot && nr % 2 != 0)
+		return 0;
+
+	return 1;
+}
+
+extern void xenon_cause_IPI(int target, int msg);
+
+static void smp_xenon_message_pass(int target, int msg)
+{
+	unsigned int i;
+
+	if (target < NR_CPUS) {
+		xenon_cause_IPI(target, msg);
+	} else {
+		for_each_online_cpu(i) {
+			if (target == MSG_ALL_BUT_SELF
+			    && i == smp_processor_id())
+				continue;
+			xenon_cause_IPI(i, msg);
+		}
+	}
+}
+
+static struct smp_ops_t xenon_smp_ops = {
+	.message_pass	= smp_xenon_message_pass,
+	.probe		= smp_xenon_probe,
+	.kick_cpu	= smp_xenon_kick_cpu,
+	.setup_cpu	= smp_xenon_setup_cpu,
+	.cpu_bootable	= smp_xenon_cpu_bootable,
+};
+
+/* This is called very early */
+void __init smp_init_xenon(void)
+{
+	pr_debug(" -> smp_init_xenon()\n");
+
+	smp_ops = &xenon_smp_ops;
+
+	pr_debug(" <- smp_init_xenon()\n");
+}
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/smp.h linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/smp.h
--- linux-2.6.33/arch/powerpc/platforms/xenon/smp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/smp.h	2010-03-19 22:53:41.000000000 +0100
@@ -0,0 +1,9 @@
+#ifndef XENON_SMP_H
+#define XENON_SMP_H
+
+#ifdef CONFIG_SMP
+extern void smp_init_xenon(void);
+#endif
+
+#endif
+
diff -NurpP --minimal linux-2.6.33/arch/powerpc/platforms/xenon/time.c linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/time.c
--- linux-2.6.33/arch/powerpc/platforms/xenon/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/arch/powerpc/platforms/xenon/time.c	2010-03-28 04:28:07.000000000 +0200
@@ -0,0 +1,37 @@
+/*
+ *  Xenon time and rtc routines.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <asm/rtc.h>
+
+static int __init xenon_rtc_init(void)
+{
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("rtc-xenon", -1, NULL, 0);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
+
+module_init(xenon_rtc_init);
+
diff -NurpP --minimal linux-2.6.33/drivers/ata/Kconfig linux-2.6.33-xbox0.10/drivers/ata/Kconfig
--- linux-2.6.33/drivers/ata/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/ata/Kconfig	2010-03-19 22:53:41.000000000 +0100
@@ -189,6 +189,14 @@ config SATA_SIS
 	  enable the PATA_SIS driver in the config.
 	  If unsure, say N.
 
+config SATA_XENON
+	tristate "Xenon SATA support"
+	depends on PCI
+	help
+	  This option enables support for Xenon southbridge.
+
+	  If unsure, say N.
+
 config SATA_ULI
 	tristate "ULi Electronics SATA support"
 	depends on PCI
diff -NurpP --minimal linux-2.6.33/drivers/ata/libata-core.c linux-2.6.33-xbox0.10/drivers/ata/libata-core.c
--- linux-2.6.33/drivers/ata/libata-core.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/ata/libata-core.c	2010-03-19 22:53:41.000000000 +0100
@@ -2130,7 +2130,7 @@ retry:
 	/* Device presence detection is unreliable on some
 	 * controllers.  Always poll IDENTIFY if available.
 	 */
-	tf.flags |= ATA_TFLAG_POLLING;
+//	tf.flags |= ATA_TFLAG_POLLING;
 
 	if (ap->ops->read_id)
 		err_mask = ap->ops->read_id(dev, &tf, id);
diff -NurpP --minimal linux-2.6.33/drivers/ata/Makefile linux-2.6.33-xbox0.10/drivers/ata/Makefile
--- linux-2.6.33/drivers/ata/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/ata/Makefile	2010-03-19 22:53:41.000000000 +0100
@@ -11,6 +11,7 @@ obj-$(CONFIG_SATA_SIL24)	+= sata_sil24.o
 obj-$(CONFIG_SATA_VIA)		+= sata_via.o
 obj-$(CONFIG_SATA_VITESSE)	+= sata_vsc.o
 obj-$(CONFIG_SATA_SIS)		+= sata_sis.o
+obj-$(CONFIG_SATA_XENON)	+= sata_xenon.o
 obj-$(CONFIG_SATA_SX4)		+= sata_sx4.o
 obj-$(CONFIG_SATA_NV)		+= sata_nv.o
 obj-$(CONFIG_SATA_ULI)		+= sata_uli.o
@@ -69,6 +70,7 @@ obj-$(CONFIG_PATA_VIA)		+= pata_via.o
 obj-$(CONFIG_PATA_WINBOND)	+= pata_sl82c105.o
 obj-$(CONFIG_PATA_WINBOND_VLB)	+= pata_winbond.o
 obj-$(CONFIG_PATA_SIS)		+= pata_sis.o
+obj-$(CONFIG_SATA_XENON)	+= sata_xenon.o
 obj-$(CONFIG_PATA_TRIFLEX)	+= pata_triflex.o
 obj-$(CONFIG_PATA_IXP4XX_CF)	+= pata_ixp4xx_cf.o
 obj-$(CONFIG_PATA_SCC)		+= pata_scc.o
@@ -90,3 +92,4 @@ libata-objs	:= libata-core.o libata-scsi
 libata-$(CONFIG_ATA_SFF)	+= libata-sff.o
 libata-$(CONFIG_SATA_PMP)	+= libata-pmp.o
 libata-$(CONFIG_ATA_ACPI)	+= libata-acpi.o
+
diff -NurpP --minimal linux-2.6.33/drivers/ata/sata_xenon.c linux-2.6.33-xbox0.10/drivers/ata/sata_xenon.c
--- linux-2.6.33/drivers/ata/sata_xenon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/ata/sata_xenon.c	2010-03-20 05:17:18.000000000 +0100
@@ -0,0 +1,256 @@
+/*
+ *  sata_xenon.c - SATA support for xenon southbridge
+ *
+ *  based on sata_sis.c, modifications by Felix Domke <tmbinc@elitedvb.net>
+ *  minor modification by: wolie <wolie@telia.com>
+ *
+ *  		    Please ALWAYS copy linux-ide@vger.kernel.org
+ *		    on emails.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+
+#define DRV_NAME	"sata_xenon"
+#define DRV_VERSION	"0.1.1"
+
+	/* small note: it's completely unknown whether the xenon southbridge sata
+	   is really based on SiS technology.
+	   Most of SATA is standardized anyway.
+
+
+	   So, we have these two pci devices, one for each port.
+
+	   They have two BARs, one for the IDE registers (0..7,
+	   altstatus/devctl is +0xA), and one for the BMDMA.
+
+	   SCR seem to be sis-like in pci config space, but that should
+	   be verified!
+
+	   Note on the DVD-ROM part:
+
+	   The drives usually require some tweaks to be usable under linux.
+
+	   You either need to hack the scsi layer, or, in case of the GDR3120L,
+	   set 'modeB' in the bootloader.
+	*/
+
+enum {
+	/* PCI configuration registers */
+	SIS_SCR_BASE		= 0xc0, /* sata0 phy SCR registers */
+};
+
+static int xenon_init_one (struct pci_dev *pdev, const struct pci_device_id *ent);
+static int xenon_scr_read (struct ata_link *link, unsigned int sc_reg, u32 *val);
+static int xenon_scr_write (struct ata_link *link, unsigned int sc_reg, u32 val);//void
+static void xenon_bmdma_error_handler(struct ata_port *ap);
+
+static const struct pci_device_id xenon_pci_tbl[] = {
+	{ PCI_VDEVICE(MICROSOFT, 0x5803), 0 },
+	{ PCI_VDEVICE(MICROSOFT, 0x5802), 0 },
+
+	{ }	/* terminate list */
+};
+
+static struct pci_driver xenon_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= xenon_pci_tbl,
+	.probe			= xenon_init_one,
+	.remove			= ata_pci_remove_one,
+};
+
+static struct scsi_host_template xenon_sht = {
+	ATA_BMDMA_SHT(DRV_NAME),
+};
+
+static struct ata_port_operations xenon_ops = {
+	.inherits		= &ata_bmdma_port_ops,
+// 	.lost_interrupt		= ATA_OP_NULL,
+	.error_handler		= xenon_bmdma_error_handler,
+	.scr_read		= xenon_scr_read,
+	.scr_write		= xenon_scr_write,
+};
+
+static const struct ata_port_info xenon_port_info = {
+	.flags		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY,
+	.pio_mask	= ATA_PIO4,
+	.mwdma_mask	= ATA_MWDMA2,
+	.udma_mask	= ATA_UDMA6, //0x7F
+	.port_ops	= &xenon_ops,
+//	.irq_handler	= ata_interrupt,
+//	.private_data   = NULL
+};
+
+
+
+MODULE_DESCRIPTION("low-level driver for Xenon Southbridge SATA controller");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, xenon_pci_tbl);
+MODULE_VERSION(DRV_VERSION);
+
+static unsigned int get_scr_cfg_addr(unsigned int sc_reg)
+{
+	if ((sc_reg > SCR_CONTROL) || (sc_reg == SCR_ERROR)) /* doesn't exist in PCI cfg space */
+		return -1;
+
+	return SIS_SCR_BASE + (4 * sc_reg);
+
+}
+
+static int xenon_scr_read (struct ata_link *link, unsigned int sc_reg, u32 *val) //u32
+{
+	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
+	unsigned int cfg_addr;
+	u32 val2;
+
+	cfg_addr = get_scr_cfg_addr(sc_reg);
+
+	if (cfg_addr == -1)
+		return 0; /* assume no error */
+
+	pci_read_config_dword(pdev, cfg_addr, &val2);
+
+	*val = val2;
+	return 0;
+}
+
+static int xenon_scr_write (struct ata_link *link, unsigned int sc_reg, u32 val) //void
+{
+	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
+	unsigned int cfg_addr;
+
+	cfg_addr = get_scr_cfg_addr(sc_reg);
+
+	if (cfg_addr == -1)
+		return -EINVAL;
+
+	pci_write_config_dword(pdev, cfg_addr, val);
+	return 0;
+}
+
+static int xenon_softreset(struct ata_link *link, unsigned int *classes, unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
+		/* Host 0 (used for DVD-ROM) has a quirk when used with
+		   an Toshiba/Samsung drive: It can hang after a device reset.
+
+		   While the exact reason is unclear (anyone with a SATA port
+		   analyzer?), this workaround will not let the reset happen, and
+		   emulate the detection of an ATAPI device.
+
+		   When the workaround is enabled, only ATAPI devices are supported
+		   on host 0, but on this hardware, nothing else is possible anyway. */
+	if (pdev->device == 0x5802)
+	{
+		classes[0] = ATA_DEV_ATAPI;
+		classes[1] = ATA_DEV_NONE;
+		return 0;
+	} else
+		return ata_sff_softreset(link, classes, 150);
+}
+
+static void xenon_bmdma_error_handler(struct ata_port *ap)
+{
+	ata_do_eh(ap, ata_std_prereset, xenon_softreset, sata_std_hardreset, ata_std_postreset);
+}
+
+
+static int xenon_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	static int printed_version;
+	struct ata_host *host;
+	struct ata_ioports *ioaddr;
+	struct ata_port_info pi = xenon_port_info;
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	int rc;
+	int pci_dev_busy = 0;
+
+	if (!printed_version++)
+		dev_printk(KERN_INFO, &pdev->dev, "version " DRV_VERSION "\n");
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc) {
+		pci_dev_busy = 1;
+		goto err_out;
+	}
+
+	rc = pci_set_dma_mask(pdev, ATA_DMA_MASK);
+	if (rc)
+		goto err_out_regions;
+
+	rc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);
+	if (rc)
+		goto err_out_regions;
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 1);
+	if (!host)
+		return -ENOMEM;
+
+	ioaddr = &host->ports[0]->ioaddr;
+	ioaddr->cmd_addr = ioremap(pci_resource_start(pdev, 0), PAGE_SIZE);
+	ioaddr->altstatus_addr = ioaddr->cmd_addr + 0xa;
+	ioaddr->ctl_addr = ioaddr->cmd_addr + 0xa;
+	ioaddr->bmdma_addr = ioremap(pci_resource_start(pdev, 1), PAGE_SIZE);
+
+	ata_sff_std_ports(ioaddr);
+
+	pci_set_master(pdev);
+	pci_intx(pdev, 1);
+
+	return ata_host_activate(host, pdev->irq, ata_sff_interrupt,
+				 IRQF_SHARED, &xenon_sht);
+
+err_out_regions:
+	pci_release_regions(pdev);
+
+err_out:
+	if (!pci_dev_busy)
+		pci_disable_device(pdev);
+	return rc;
+}
+
+static int __init xenon_init(void)
+{
+	return pci_register_driver(&xenon_pci_driver);
+}
+
+static void __exit xenon_exit(void)
+{
+	pci_unregister_driver(&xenon_pci_driver);
+}
+
+module_init(xenon_init);
+module_exit(xenon_exit);
+
diff -NurpP --minimal linux-2.6.33/drivers/char/Kconfig linux-2.6.33-xbox0.10/drivers/char/Kconfig
--- linux-2.6.33/drivers/char/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/char/Kconfig	2010-03-28 00:07:48.000000000 +0100
@@ -348,6 +348,26 @@ config STALDRV
 	  in this case.  If you have never heard about all this, it's safe to
 	  say N.
 
+config XENON_SMC
+	tristate "Xenon System Management Controller (SMC)"
+	depends on PPC_XENON
+	help
+	  Character interface to the System Management controller in the
+	  Xbox 360. Allows to send arbitrary SMC commands and receive
+	  SMC replies.
+
+config XENON_ANA
+	tristate "Xenon (H)ana Character Device"
+	depends on PPC_XENON
+	help
+	  Character interface to the (H)ana chip on the Xbox 360.
+
+config XENON_PROBE
+	tristate "Xenon Memory Probe Device"
+	depends on PPC_XENON && EXPERIMENTAL
+	help
+	  Character interface to do memory probing on the Xbox 360.
+
 config STALLION
 	tristate "Stallion EasyIO or EC8/32 support"
 	depends on STALDRV && (ISA || EISA || PCI)
diff -NurpP --minimal linux-2.6.33/drivers/char/Makefile linux-2.6.33-xbox0.10/drivers/char/Makefile
--- linux-2.6.33/drivers/char/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/char/Makefile	2010-03-28 00:08:28.000000000 +0100
@@ -64,6 +64,9 @@ obj-$(CONFIG_IBM_BSR)		+= bsr.o
 obj-$(CONFIG_SGI_MBCS)		+= mbcs.o
 obj-$(CONFIG_BRIQ_PANEL)	+= briq_panel.o
 obj-$(CONFIG_BFIN_OTP)		+= bfin-otp.o
+obj-$(CONFIG_XENON_SMC)  	+= xenon_smc.o
+obj-$(CONFIG_XENON_ANA)  	+= xenon_ana.o
+obj-$(CONFIG_XENON_PROBE)  	+= xenon_probe.o
 
 obj-$(CONFIG_PRINTER)		+= lp.o
 
diff -NurpP --minimal linux-2.6.33/drivers/char/xenon_ana.c linux-2.6.33-xbox0.10/drivers/char/xenon_ana.c
--- linux-2.6.33/drivers/char/xenon_ana.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/char/xenon_ana.c	2010-03-28 03:54:50.000000000 +0200
@@ -0,0 +1,210 @@
+/*
+ *  Xenon (H)ana via SMC character driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+#define DRV_NAME	"xenon_ana"
+#define DRV_VERSION	"0.2"
+
+
+int xenon_smc_message_wait(void *msg);
+
+static uint32_t ana_read_reg(uint8_t addr)
+{
+	unsigned char msg[16] = { 0x11,
+		0x10, 0x05, 0x80 | 0x70, 0x00, 0xF0, addr };
+
+	xenon_smc_message_wait(msg);
+	return msg[4] | (msg[5] << 8) | (msg[6] << 16) | (msg[7] << 24);
+}
+
+static int ana_write_reg(uint8_t addr, uint32_t val)
+{
+	unsigned char msg[16] = { 0x11,
+		0x60, 0x00, 0x80 | 0x70, 0x00, 0x00,
+		addr, 0x00, val & 0xFF, (val >> 8) & 0xFF,
+		(val >> 16) & 0xFF, (val >> 24) & 0xFF };
+
+	xenon_smc_message_wait(msg);
+	return msg[1];
+}
+
+static loff_t ana_llseek(struct file *file, loff_t offset, int origin)
+{
+	switch (origin) {
+	case 1:
+		offset += file->f_pos;
+		break;
+	case 2:
+		offset += 0x400;
+		break;
+	}
+	if (offset < 0)
+		return -EINVAL;
+
+	file->f_pos = offset;
+	return file->f_pos;
+}
+
+typedef union {
+	uint32_t val;
+	uint8_t p[4];
+} 	ana_reg_t;
+
+static ssize_t ana_read(struct file *file, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= 0x400UL)
+		return -EINVAL;
+
+	while (count) {
+		/* optimize reads in same reg */
+		int addr = ppa/4;
+		int shift = ppa % 4;
+		ana_reg_t r = { .val = ana_read_reg(addr) };
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, &r.p[shift], len))
+			return -EFAULT;
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= 0x400)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static ssize_t ana_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= 0x400UL)
+		return -EINVAL;
+
+	while (count) {
+		/* coalesce writes to same reg */
+		int addr = ppa/4;
+		int shift = ppa % 4;
+		ana_reg_t r;
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+
+		/* handle partial write */
+		if (len != 4)
+			r.val = ana_read_reg(addr);
+
+		if (copy_from_user(&r.p[shift], buf, len))
+			return -EFAULT;
+
+		/* FIXME: handle return code */
+		ana_write_reg(addr, r.val);
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= 0x400)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static int ana_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int ana_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int ana_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+const struct file_operations ana_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= ana_llseek,
+	.read		= ana_read,
+	.write		= ana_write,
+	.ioctl		= ana_ioctl,
+	.open		= ana_open,
+	.release	= ana_release,
+};
+
+static struct miscdevice ana_dev = {
+	.minor =  MISC_DYNAMIC_MINOR,
+	"ana",
+	&ana_fops
+};
+
+int __init ana_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Xenon (H)ana char driver version " DRV_VERSION "\n");
+
+	ret = misc_register(&ana_dev);
+	return ret;
+}
+
+void __exit ana_exit(void)
+{
+	misc_deregister(&ana_dev);
+}
+
+module_init(ana_init);
+module_exit(ana_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Character Interface for Xenon (H)ana");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
diff -NurpP --minimal linux-2.6.33/drivers/char/xenon_probe.c linux-2.6.33-xbox0.10/drivers/char/xenon_probe.c
--- linux-2.6.33/drivers/char/xenon_probe.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/char/xenon_probe.c	2010-03-30 08:11:25.000000000 +0200
@@ -0,0 +1,229 @@
+/*
+ *  Xenon Memory Probe character driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#define DRV_NAME	"xenon_probe"
+#define DRV_VERSION	"0.1"
+
+static unsigned long base = 0xc8000000;
+static unsigned long size = 0x10000;
+static bool little_endian = 0;
+
+module_param(base, ulong, 0);
+MODULE_PARM_DESC(base, "Probe Memory Base");
+
+module_param(size, ulong, 0);
+MODULE_PARM_DESC(size, "Probe Memory Size");
+
+module_param(little_endian, bool, 0);
+MODULE_PARM_DESC(little_endian, "Probe Memory Endianess");
+
+static void __iomem *mapped = NULL;
+
+
+static uint32_t probe_map(uint32_t val)
+{
+	if (little_endian)
+		return le32_to_cpu(val);
+	else
+		return be32_to_cpu(val);
+}
+
+static uint32_t probe_rmap(uint32_t val)
+{
+	if (little_endian)
+		return cpu_to_le32(val);
+	else
+		return cpu_to_be32(val);
+}
+
+
+static loff_t probe_llseek(struct file *file, loff_t offset, int origin)
+{
+	switch (origin) {
+	case 1:
+		offset += file->f_pos;
+		break;
+	case 2:
+		offset += size;
+		break;
+	}
+	if ((offset < 0) || (offset >= size))
+		return -EINVAL;
+
+	file->f_pos = offset;
+	return file->f_pos;
+}
+
+typedef union {
+	uint32_t val;
+	uint8_t p[4];
+} 	probe_mem_t;
+
+static ssize_t probe_read(struct file *file, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= size)
+		return -EINVAL;
+
+	printk("probe_read(%x,%zx)\n", ppa, count);
+	while (count) {
+		/* optimize reads in same longword */
+		unsigned long addr = ppa & ~3;
+		int shift = ppa % 4;
+		probe_mem_t r = { .val = probe_map(readl(mapped + addr)) };
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, &r.p[shift], len))
+			return -EFAULT;
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= size)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static ssize_t probe_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	uint32_t ppa = *ppos;
+
+	if (*ppos >= size)
+		return -EINVAL;
+
+	printk("probe_write(%x,%zx)\n", ppa, count);
+	while (count) {
+		/* coalesce writes to same reg */
+		unsigned long addr = ppa & ~3;
+		int shift = ppa % 4;
+		probe_mem_t r;
+
+		int len = 4 - shift;
+
+		if (len > count)
+			len = count;
+
+		/* handle partial write */
+		if (len != 4)
+			r.val = probe_map(readl(mapped + addr));
+
+		if (copy_from_user(&r.p[shift], buf, len))
+			return -EFAULT;
+
+		writel(probe_rmap(r.val), mapped + addr);
+
+		count -= len;
+		buf += len;
+		ppa += len;
+
+		/* end of register space? */
+		if (ppa >= size)
+			break;
+	}
+
+	/* how much data was actually transferred? */
+	count = ppa - *ppos;
+	*ppos = ppa;
+	return count;
+}
+
+static int probe_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int probe_open(struct inode *inode, struct file *file)
+{
+	return generic_file_open(inode, file);
+}
+
+static int probe_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+const struct file_operations probe_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= probe_llseek,
+	.read		= probe_read,
+	.write		= probe_write,
+	.ioctl		= probe_ioctl,
+	.open		= probe_open,
+	.release	= probe_release,
+};
+
+static struct miscdevice probe_dev = {
+	.minor =  MISC_DYNAMIC_MINOR,
+	"probe",
+	&probe_fops
+};
+
+int __init probe_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Xenon Memory Probe driver version " DRV_VERSION "\n");
+
+	mapped = ioremap(base, size);
+	if (!mapped)
+		return -EINVAL;
+
+	printk(KERN_INFO "XMP mapped 0x%04lx bytes @0x%08lx\n",
+		size, base);
+
+	ret = misc_register(&probe_dev);
+	return ret;
+}
+
+void __exit probe_exit(void)
+{
+	misc_deregister(&probe_dev);
+}
+
+module_init(probe_init);
+module_exit(probe_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Xenon Memory Probe Interface");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
diff -NurpP --minimal linux-2.6.33/drivers/char/xenon_smc.c linux-2.6.33-xbox0.10/drivers/char/xenon_smc.c
--- linux-2.6.33/drivers/char/xenon_smc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/char/xenon_smc.c	2010-03-28 03:55:27.000000000 +0200
@@ -0,0 +1,124 @@
+/*
+ *  Xenon SMC character driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+#define DRV_NAME	"xenon_smc"
+#define DRV_VERSION	"0.2"
+
+
+/* single access for now */
+
+static unsigned long is_active;
+static unsigned char msg[16];
+
+
+
+static ssize_t smc_read(struct file *file, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	if ((count != 16) || *ppos)
+		return -EINVAL;
+	if (copy_to_user(buf, msg, 0x10))
+		return -EFAULT;
+
+	return 16;
+}
+
+int xenon_smc_message_wait(void *msg);
+
+static ssize_t smc_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	if ((count != 16) || *ppos)
+		return -EINVAL;
+
+	if (copy_from_user(msg, buf, 16))
+		return -EFAULT;
+
+	xenon_smc_message_wait(msg);
+
+	return 16;
+}
+
+static int smc_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int smc_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &is_active))
+		return -EBUSY;
+
+	return nonseekable_open(inode, file);
+}
+
+static int smc_release(struct inode *inode, struct file *file)
+{
+	clear_bit(0, &is_active);
+	return 0;
+}
+
+
+const struct file_operations smc_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= smc_read,
+	.write		= smc_write,
+	.ioctl		= smc_ioctl,
+	.open		= smc_open,
+	.release	= smc_release,
+};
+
+static struct miscdevice smc_dev = {
+	.minor =  MISC_DYNAMIC_MINOR,
+	"smc",
+	&smc_fops
+};
+
+int __init smc_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Xenon SMC char driver version " DRV_VERSION "\n");
+
+	ret = misc_register(&smc_dev);
+	return ret;
+}
+
+void __exit smc_exit(void)
+{
+	misc_deregister(&smc_dev);
+}
+
+module_init(smc_init);
+module_exit(smc_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Character Interface for Xenon Southbridge SMC");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
diff -NurpP --minimal linux-2.6.33/drivers/hwmon/Kconfig linux-2.6.33-xbox0.10/drivers/hwmon/Kconfig
--- linux-2.6.33/drivers/hwmon/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/hwmon/Kconfig	2010-03-28 21:41:40.000000000 +0200
@@ -1076,6 +1076,13 @@ config SENSORS_MC13783_ADC
         help
           Support for the A/D converter on MC13783 PMIC.
 
+config SENSORS_XENON
+	tristate "Xenon SMC"
+	depends on PPC_XENON
+	help
+	  This driver provides support for the Xenon SMC sensors and
+	  fan control.
+
 if ACPI
 
 comment "ACPI drivers"
diff -NurpP --minimal linux-2.6.33/drivers/hwmon/Makefile linux-2.6.33-xbox0.10/drivers/hwmon/Makefile
--- linux-2.6.33/drivers/hwmon/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/hwmon/Makefile	2010-03-28 21:37:49.000000000 +0200
@@ -99,6 +99,7 @@ obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l7
 obj-$(CONFIG_SENSORS_W83L786NG)	+= w83l786ng.o
 obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
+obj-$(CONFIG_SENSORS_XENON)	+= xenon-hwmon.o
 
 ifeq ($(CONFIG_HWMON_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
diff -NurpP --minimal linux-2.6.33/drivers/hwmon/xenon-hwmon.c linux-2.6.33-xbox0.10/drivers/hwmon/xenon-hwmon.c
--- linux-2.6.33/drivers/hwmon/xenon-hwmon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/hwmon/xenon-hwmon.c	2010-03-29 03:03:53.000000000 +0200
@@ -0,0 +1,200 @@
+/*
+ *  Xenon HW Monitor via SMC driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#define DRV_NAME	"xenon-hwmon"
+#define DRV_VERSION	"0.1"
+
+#if 0
+struct hwmon {
+	spinlock_t	lock;
+
+	struct device	*xenon_hwmon_dev;
+};
+#endif
+static unsigned int fan_speed[2];
+
+int xenon_smc_message_wait(void *msg);
+
+static unsigned long xenon_get_temp(unsigned nr)
+{
+	unsigned char msg[16] = { 0x07 };
+	static unsigned int temp[4] = { 0 };
+
+	/* FIXME: only every N jiffies */
+	xenon_smc_message_wait(msg);
+	temp[0] = (msg[1] | (msg[2] << 8)) * 1000 / 256;
+	temp[1] = (msg[3] | (msg[4] << 8)) * 1000 / 256;
+	temp[2] = (msg[5] | (msg[6] << 8)) * 1000 / 256;
+	temp[3] = (msg[7] | (msg[8] << 8)) * 1000 / 256;
+
+	return temp[nr & 3];
+}
+
+void xenon_smc_message(void *msg);
+
+static int xenon_set_cpu_fan_speed(unsigned val)
+{
+	unsigned char msg[16] = { 0x94, (val & 0x7F) | 0x80 };
+
+	xenon_smc_message(msg);
+	return 0;
+}
+
+static int xenon_set_gpu_fan_speed(unsigned val)
+{
+	unsigned char msg[16] = { 0x89, (val & 0x7F) | 0x80 };
+
+	xenon_smc_message(msg);
+	return 0;
+}
+
+
+static ssize_t show_fan_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int fan_nr = to_sensor_dev_attr(attr)->index;
+	// void *p = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", fan_speed[fan_nr]);
+}
+
+static ssize_t set_fan_speed(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int fan_nr = to_sensor_dev_attr(attr)->index;
+	unsigned int val = simple_strtol(buf, NULL, 10);
+	// void *p = dev_get_drvdata(dev);
+
+	fan_speed[fan_nr] = val & 0xFF;
+
+	if (fan_nr == 0)
+		xenon_set_cpu_fan_speed(val);
+	if (fan_nr == 1)
+		xenon_set_gpu_fan_speed(val);
+
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR(cpu_fan_speed, S_IRUGO | S_IWUSR,
+		show_fan_speed, set_fan_speed, 0);
+static SENSOR_DEVICE_ATTR(gpu_fan_speed, S_IRUGO | S_IWUSR,
+		show_fan_speed, set_fan_speed, 1);
+
+static ssize_t show_temp(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int temp_nr = to_sensor_dev_attr(attr)->index;
+	// struct dev *p = dev_get_drvdata(pdev);
+	unsigned temp = xenon_get_temp(temp_nr);
+
+	return sprintf(buf, "%d\n", temp);
+}
+
+static SENSOR_DEVICE_ATTR(cpu_temp, S_IRUGO, show_temp, NULL, 0);
+static SENSOR_DEVICE_ATTR(gpu_temp, S_IRUGO, show_temp, NULL, 1);
+static SENSOR_DEVICE_ATTR(edram_temp, S_IRUGO, show_temp, NULL, 2);
+static SENSOR_DEVICE_ATTR(motherboard_temp, S_IRUGO, show_temp, NULL, 3);
+
+static ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "xenon\n");
+}
+
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);
+
+static struct attribute *xenon_hwmon_attributes[] = {
+	&sensor_dev_attr_cpu_fan_speed.dev_attr.attr,
+	&sensor_dev_attr_gpu_fan_speed.dev_attr.attr,
+	&sensor_dev_attr_cpu_temp.dev_attr.attr,
+	&sensor_dev_attr_gpu_temp.dev_attr.attr,
+	&sensor_dev_attr_edram_temp.dev_attr.attr,
+	&sensor_dev_attr_motherboard_temp.dev_attr.attr,
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group xenon_hwmon_group = {
+	.attrs = xenon_hwmon_attributes,
+};
+
+static int __init xenon_hwmon_probe(struct platform_device *pdev)
+{
+	struct device *dev;
+	int err;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &xenon_hwmon_group);
+	if (err)
+		goto out;
+
+	dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(dev)) {
+		err = PTR_ERR(dev);
+		goto out_sysfs_remove_group;
+	}
+
+	platform_set_drvdata(pdev, dev);
+	return 0;
+
+out_sysfs_remove_group:
+	sysfs_remove_group(&pdev->dev.kobj, &xenon_hwmon_group);
+out:
+	return err;
+}
+
+static int __exit xenon_hwmon_remove(struct platform_device *pdev)
+{
+	hwmon_device_unregister(&pdev->dev);
+	sysfs_remove_group(&pdev->dev.kobj, &xenon_hwmon_group);
+	return 0;
+}
+
+
+static struct platform_driver xenon_hwmon_driver = {
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(xenon_hwmon_remove),
+};
+
+static int __init xenon_hwmon_init(void)
+{
+	int ret = platform_driver_probe(&xenon_hwmon_driver, xenon_hwmon_probe);
+
+	printk("xenon_hwmon_init() = %d\n", ret);
+	return ret;
+}
+
+static void __exit xenon_hwmon_exit(void)
+{
+	platform_driver_unregister(&xenon_hwmon_driver);
+}
+
+module_init(xenon_hwmon_init);
+module_exit(xenon_hwmon_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Character Interface for Xenon (H)ana");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff -NurpP --minimal linux-2.6.33/drivers/input/joystick/xpad.c linux-2.6.33-xbox0.10/drivers/input/joystick/xpad.c
--- linux-2.6.33/drivers/input/joystick/xpad.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/input/joystick/xpad.c	2010-03-25 02:11:31.000000000 +0100
@@ -1,5 +1,8 @@
 /*
- * X-Box gamepad driver
+ * Xbox gamepad driver with Xbox 360 wired/wireless support
+ *
+ * Last Modified:	2 March 2009
+ *			Mike Murphy <mamurph@cs.clemson.edu>
  *
  * Copyright (c) 2002 Marko Friedemann <mfr@bmx-chemnitz.de>
  *               2004 Oliver Schwartz <Oliver.Schwartz@gmx.de>,
@@ -9,6 +12,8 @@
  *               2005 Dominic Cerquetti <binary1230@yahoo.com>
  *               2006 Adam Buchbinder <adam.buchbinder@gmail.com>
  *               2007 Jan Kratochvil <honza@jikos.cz>
+ *               2009 Clemson University
+ *		      (contact: Mike Murphy <mamurph@cs.clemson.edu>)
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -24,132 +29,124 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
- *
- * This driver is based on:
- *  - information from     http://euc.jp/periphs/xbox-controller.ja.html
- *  - the iForce driver    drivers/char/joystick/iforce.c
- *  - the skeleton-driver  drivers/usb/usb-skeleton.c
- *  - Xbox 360 information http://www.free60.org/wiki/Gamepad
- *
- * Thanks to:
- *  - ITO Takayuki for providing essential xpad information on his website
- *  - Vojtech Pavlik     - iforce driver / input subsystem
- *  - Greg Kroah-Hartman - usb-skeleton driver
- *  - XBOX Linux project - extra USB id's
- *
- * TODO:
- *  - fine tune axes (especially trigger axes)
- *  - fix "analog" buttons (reported as digital now)
- *  - get rumble working
- *  - need USB IDs for other dance pads
- *
- * History:
- *
- * 2002-06-27 - 0.0.1 : first version, just said "XBOX HID controller"
- *
- * 2002-07-02 - 0.0.2 : basic working version
- *  - all axes and 9 of the 10 buttons work (german InterAct device)
- *  - the black button does not work
- *
- * 2002-07-14 - 0.0.3 : rework by Vojtech Pavlik
- *  - indentation fixes
- *  - usb + input init sequence fixes
- *
- * 2002-07-16 - 0.0.4 : minor changes, merge with Vojtech's v0.0.3
- *  - verified the lack of HID and report descriptors
- *  - verified that ALL buttons WORK
- *  - fixed d-pad to axes mapping
- *
- * 2002-07-17 - 0.0.5 : simplified d-pad handling
- *
- * 2004-10-02 - 0.0.6 : DDR pad support
- *  - borrowed from the XBOX linux kernel
- *  - USB id's for commonly used dance pads are present
- *  - dance pads will map D-PAD to buttons, not axes
- *  - pass the module paramater 'dpad_to_buttons' to force
- *    the D-PAD to map to buttons if your pad is not detected
- *
- * Later changes can be tracked in SCM.
+ * Please see xbox.h for the ChangeLog.
  */
 
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/stat.h>
-#include <linux/module.h>
-#include <linux/usb/input.h>
-
-#define DRIVER_AUTHOR "Marko Friedemann <mfr@bmx-chemnitz.de>"
-#define DRIVER_DESC "X-Box pad driver"
-
-#define XPAD_PKT_LEN 32
-
-/* xbox d-pads should map to buttons, as is required for DDR pads
-   but we map them to axes when possible to simplify things */
-#define MAP_DPAD_TO_BUTTONS    0
-#define MAP_DPAD_TO_AXES       1
-#define MAP_DPAD_UNKNOWN       2
+#include "xpad.h"
 
-#define XTYPE_XBOX        0
-#define XTYPE_XBOX360     1
-#define XTYPE_XBOX360W    2
-#define XTYPE_UNKNOWN     3
+/* This module parameter is something of a relic, but it remains for
+ * compatibility. Importantly, the option to map the D-PAD buttons applies
+ * only to controller *interfaces* (i.e. vendor and product codes) not
+ * explicitly present in xpad_device[]. */
 
 static int dpad_to_buttons;
 module_param(dpad_to_buttons, bool, S_IRUGO);
-MODULE_PARM_DESC(dpad_to_buttons, "Map D-PAD to buttons rather than axes for unknown pads");
+MODULE_PARM_DESC(dpad_to_buttons,
+	"Map D-PAD to buttons rather than axes for unknown pads");
+
 
+/* Table of various device interfaces recognized by this driver. Each supported
+ * device has a directional pad mapping, interface type, and controller type.
+ * Note that wireless 360 devices have XCONTROLLER_TYPE_NONE, as the actual
+ * type of the gaming controller is not known until the controller binds
+ * wirelessly with the receiver
+ */
 static const struct xpad_device {
 	u16 idVendor;
 	u16 idProduct;
 	char *name;
 	u8 dpad_mapping;
 	u8 xtype;
+	u8 controller_type;
 } xpad_device[] = {
-	{ 0x045e, 0x0202, "Microsoft X-Box pad v1 (US)", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x045e, 0x0289, "Microsoft X-Box pad v2 (US)", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x045e, 0x0285, "Microsoft X-Box pad (Japan)", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x045e, 0x0287, "Microsoft Xbox Controller S", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x045e, 0x0719, "Xbox 360 Wireless Receiver", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
-	{ 0x0c12, 0x8809, "RedOctane Xbox Dance Pad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
-	{ 0x044f, 0x0f07, "Thrustmaster, Inc. Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x046d, 0xc242, "Logitech Chillstream Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x046d, 0xca84, "Logitech Xbox Cordless Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x046d, 0xca88, "Logitech Compact Controller for Xbox", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x05fd, 0x1007, "Mad Catz Controller (unverified)", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x05fd, 0x107a, "InterAct 'PowerPad Pro' X-Box pad (Germany)", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0738, 0x4516, "Mad Catz Control Pad", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0738, 0x4522, "Mad Catz LumiCON", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0738, 0x4526, "Mad Catz Control Pad Pro", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0738, 0x4536, "Mad Catz MicroCON", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0738, 0x4540, "Mad Catz Beat Pad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
-	{ 0x0738, 0x4556, "Mad Catz Lynx Wireless Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0738, 0x4716, "Mad Catz Wired Xbox 360 Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x0738, 0x4738, "Mad Catz Wired Xbox 360 Controller (SFIV)", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x0738, 0x6040, "Mad Catz Beat Pad Pro", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
-	{ 0x0c12, 0x8802, "Zeroplus Xbox Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0c12, 0x880a, "Pelican Eclipse PL-2023", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0c12, 0x8810, "Zeroplus Xbox Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0c12, 0x9902, "HAMA VibraX - *FAULTY HARDWARE*", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0e4c, 0x1097, "Radica Gamester Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0e4c, 0x2390, "Radica Games Jtech Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0e6f, 0x0003, "Logic3 Freebird wireless Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0e6f, 0x0005, "Eclipse wireless Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0e6f, 0x0006, "Edge wireless Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0e6f, 0x0006, "Pelican 'TSZ' Wired Xbox 360 Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x0e8f, 0x0201, "SmartJoy Frag Xpad/PS2 adaptor", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0f30, 0x0202, "Joytech Advanced Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0f30, 0x8888, "BigBen XBMiniPad Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x102c, 0xff0c, "Joytech Wireless Advanced Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x12ab, 0x8809, "Xbox DDR dancepad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
-	{ 0x1430, 0x4748, "RedOctane Guitar Hero X-plorer", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x1430, 0x8888, "TX6500+ Dance Pad (first generation)", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
-	{ 0x146b, 0x0601, "BigBen Interactive XBOX 360 Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x045e, 0x028e, "Microsoft X-Box 360 pad", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0x1bad, 0x0003, "Harmonix Rock Band Drumkit", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },
-	{ 0x0f0d, 0x0016, "Hori Real Arcade Pro.EX", MAP_DPAD_TO_AXES, XTYPE_XBOX360 },
-	{ 0xffff, 0xffff, "Chinese-made Xbox Controller", MAP_DPAD_TO_AXES, XTYPE_XBOX },
-	{ 0x0000, 0x0000, "Generic X-Box pad", MAP_DPAD_UNKNOWN, XTYPE_UNKNOWN }
+	{ 0x045e, 0x0202, "Microsoft X-Box pad v1 (US)", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x045e, 0x0289, "Microsoft X-Box pad v2 (US)", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x045e, 0x0285, "Microsoft X-Box pad (Japan)", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x045e, 0x0287, "Microsoft Xbox Controller S", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x045e, 0x028e, "Microsoft X-Box 360 pad", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX360, XCONTROLLER_TYPE_PAD },
+	{ 0x045e, 0x0719, "Xbox 360 Wireless Receiver", MAP_DPAD_TO_BUTTONS,
+		XTYPE_XBOX360W, XCONTROLLER_TYPE_NONE },
+	{ 0x0c12, 0x8809, "RedOctane Xbox Dance Pad", MAP_DPAD_TO_BUTTONS,
+		XTYPE_XBOX, XCONTROLLER_TYPE_DANCE_PAD },
+	{ 0x044f, 0x0f07, "Thrustmaster, Inc. Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x046d, 0xc242, "Logitech Chillstream Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX360, XCONTROLLER_TYPE_PAD },
+	{ 0x046d, 0xca84, "Logitech Xbox Cordless Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x046d, 0xca88, "Logitech Compact Controller for Xbox",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x05fd, 0x1007, "Mad Catz Controller (unverified)", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x05fd, 0x107a, "InterAct 'PowerPad Pro' X-Box pad (Germany)",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4516, "Mad Catz Control Pad", MAP_DPAD_TO_AXES, XTYPE_XBOX,
+		XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4522, "Mad Catz LumiCON", MAP_DPAD_TO_AXES, XTYPE_XBOX,
+		XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4526, "Mad Catz Control Pad Pro", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4536, "Mad Catz MicroCON", MAP_DPAD_TO_AXES, XTYPE_XBOX,
+		XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4540, "Mad Catz Beat Pad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX,
+		XCONTROLLER_TYPE_DANCE_PAD },
+	{ 0x0738, 0x4556, "Mad Catz Lynx Wireless Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4716, "Mad Catz Wired Xbox 360 Controller",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX360, XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x4738, "Mad Catz Wired Xbox 360 Controller (SFIV)",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX360, XCONTROLLER_TYPE_PAD },
+	{ 0x0738, 0x6040, "Mad Catz Beat Pad Pro", MAP_DPAD_TO_BUTTONS,
+		XTYPE_XBOX, XCONTROLLER_TYPE_DANCE_PAD },
+	{ 0x0c12, 0x8802, "Zeroplus Xbox Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0c12, 0x880a, "Pelican Eclipse PL-2023", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0c12, 0x8810, "Zeroplus Xbox Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0c12, 0x9902, "HAMA VibraX - *FAULTY HARDWARE*", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0e4c, 0x1097, "Radica Gamester Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0e4c, 0x2390, "Radica Games Jtech Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0e6f, 0x0003, "Logic3 Freebird wireless Controller",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0e6f, 0x0005, "Eclipse wireless Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0e6f, 0x0006, "Edge wireless Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0e6f, 0x0006, "Pelican 'TSZ' Wired Xbox 360 Controller",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX360, XCONTROLLER_TYPE_PAD },
+	{ 0x0e8f, 0x0201, "SmartJoy Frag Xpad/PS2 adaptor", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0f30, 0x0202, "Joytech Advanced Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0f30, 0x8888, "BigBen XBMiniPad Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0f0d, 0x0016, "Hori Real Arcade Pro.EX", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x102c, 0xff0c, "Joytech Wireless Advanced Controller",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x12ab, 0x8809, "Xbox DDR dancepad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX,
+		XCONTROLLER_TYPE_DANCE_PAD },
+	{ 0x1430, 0x4748, "RedOctane Guitar Hero X-plorer", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX360, XCONTROLLER_TYPE_GUITAR },
+	{ 0x1430, 0x8888, "TX6500+ Dance Pad (first generation)",
+		MAP_DPAD_TO_BUTTONS, XTYPE_XBOX, XCONTROLLER_TYPE_DANCE_PAD },
+	{ 0x146b, 0x0601, "BigBen Interactive XBOX 360 Controller",
+		MAP_DPAD_TO_AXES, XTYPE_XBOX360, XCONTROLLER_TYPE_PAD },
+	{ 0x1bad, 0x0003, "Harmonix Rock Band Drumkit",
+		MAP_DPAD_TO_BUTTONS, XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0xffff, 0xffff, "Chinese-made Xbox Controller", MAP_DPAD_TO_AXES,
+		XTYPE_XBOX, XCONTROLLER_TYPE_PAD },
+	{ 0x0000, 0x0000, "Generic X-Box pad", MAP_DPAD_UNKNOWN, XTYPE_UNKNOWN,
+		XCONTROLLER_TYPE_PAD }
 };
 
 /* buttons shared with xbox and xbox360 */
@@ -172,12 +169,14 @@ static const signed short xpad_btn_pad[]
 	-1				/* terminating entry */
 };
 
-static const signed short xpad360_btn[] = {  /* buttons for x360 controller */
+/* buttons for x360 controller */
+static const signed short xpad360_btn[] = {
 	BTN_TL, BTN_TR,		/* Button LB/RB */
 	BTN_MODE,		/* The big X button */
 	-1
 };
 
+/* sticks and triggers common to all devices */
 static const signed short xpad_abs[] = {
 	ABS_X, ABS_Y,		/* left stick */
 	ABS_RX, ABS_RY,		/* right stick */
@@ -191,64 +190,351 @@ static const signed short xpad_abs_pad[]
 	-1			/* terminating entry */
 };
 
-/* Xbox 360 has a vendor-specific class, so we cannot match it with only
- * USB_INTERFACE_INFO (also specifically refused by USB subsystem), so we
- * match against vendor id as well. Wired Xbox 360 devices have protocol 1,
- * wireless controllers have protocol 129. */
-#define XPAD_XBOX360_VENDOR_PROTOCOL(vend,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_INT_INFO, \
-	.idVendor = (vend), \
-	.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \
-	.bInterfaceSubClass = 93, \
-	.bInterfaceProtocol = (pr)
-#define XPAD_XBOX360_VENDOR(vend) \
-	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend,1) }, \
-	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend,129) }
 
-static struct usb_device_id xpad_table [] = {
-	{ USB_INTERFACE_INFO('X', 'B', 0) },	/* X-Box USB-IF not approved class */
-	XPAD_XBOX360_VENDOR(0x045e),		/* Microsoft X-Box 360 controllers */
-	XPAD_XBOX360_VENDOR(0x046d),		/* Logitech X-Box 360 style controllers */
-	XPAD_XBOX360_VENDOR(0x0738),		/* Mad Catz X-Box 360 controllers */
-	XPAD_XBOX360_VENDOR(0x0e6f),		/* 0x0e6f X-Box 360 controllers */
-	XPAD_XBOX360_VENDOR(0x1430),		/* RedOctane X-Box 360 controllers */
-	XPAD_XBOX360_VENDOR(0x146b),		/* BigBen Interactive Controllers */
-	XPAD_XBOX360_VENDOR(0x1bad),		/* Rock Band Drums */
-	XPAD_XBOX360_VENDOR(0x0f0d),            /* Hori Controllers */
-	{ }
+static struct usb_device_id xpad_table[] = {
+		/* X-Box USB-IF not approved class */
+	{ USB_INTERFACE_INFO('X', 'B', 0) },
+	XPAD_XBOX360_VENDOR(0x045e),	/* Microsoft X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x046d),	/* Logitech 360 style controllers */
+	XPAD_XBOX360_VENDOR(0x0738),	/* Mad Catz X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x0e6f),	/* 0x0e6f X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x0f0d),	/* Hori Controllers */
+	XPAD_XBOX360_VENDOR(0x1430),	/* RedOctane X-Box 360 controllers */
+	XPAD_XBOX360_VENDOR(0x146b),	/* BigBen Interactive Controllers */
+	XPAD_XBOX360_VENDOR(0x1bad),	/* Rock Band Drums */
+	{ }
 };
 
-MODULE_DEVICE_TABLE (usb, xpad_table);
+MODULE_DEVICE_TABLE(usb, xpad_table);
 
-struct usb_xpad {
-	struct input_dev *dev;		/* input device interface */
-	struct usb_device *udev;	/* usb device */
+static struct usb_driver xpad_driver = {
+	.name		= "xpad",
+	.probe		= xpad_probe,
+	.disconnect	= xpad_disconnect,
+	.id_table	= xpad_table,
+};
 
-	int pad_present;
+/* Wireless 360 device identification.
+ *
+ * When a wireless controller connects, the 2nd packet it sends SEEMS to
+ * be some kind of unique controller identification message. Using usbmon
+ * (see Documentation/usb/usbmon.txt), I tried 4 gamepads and a guitar, and
+ * I collected the following 5 ID packets from the 5 devices:
+ *
+ * 000f00f0 00ccfd27 0060e226 63700010 13e3201d 30034001 5001ffff ff
+ * 000f00f0 f0ccfd27 0060d8c4 e9600009 13e7201d 30034001 5001ffff ff
+ * 000f00f0 00ccfd27 0060578b 82f00010 13e3201d 30034001 5001ffff ff
+ * 000f00f0 f0ccfd27 0060da1c b1500009 13e7201d 30034001 5001ffff ff
+ * 000f00f0 f0ccfd27 006002d1 71d10000 13e3201d 30034430 5107ffff ff
+ *
+ * From this trace data, I concocted the following (potentially incorrect)
+ * scheme for detecting type and unique ID:
+ *
+ * ******** xx****xx xxxxxxxx xxxx**xx **xx**** ****tttt tttt**** **
+ *                |  unique id |                    |  type |
+ *
+ * It appears that some of the bytes in the first half of the message, noted
+ * above as "unique id" are some sort of serial number, though I cannot work
+ * out any correspondence between these bytes and the serial number printed
+ * under the battery pack. Many of the bytes in this possibly unique field
+ * are not unique across my controllers, and may not in fact be part of the
+ * controller's unique identification, but I figured it was better to have
+ * extra bytes on either end of the unique byte string instead of the
+ * alternative. In addition, the packet appears to indicate the type of
+ * the controller toward the end: the pads all send 4001 5001, while the
+ * guitar sends 4430 5107.
+ *
+ * Further testing over a wider variety of devices is probably needed to
+ * determine if changes need to be made to this scheme.
+ */
+static const struct w360_id {
+	unsigned char id_bytes[4];
+	u8 controller_type;
+} w360_id[] = {
+	{ {0x40, 0x01, 0x50, 0x01}, XCONTROLLER_TYPE_PAD },
+	{ {0x44, 0x30, 0x51, 0x07}, XCONTROLLER_TYPE_GUITAR },
+	{ {0x00, 0x00, 0x00, 0x00}, XCONTROLLER_TYPE_NONE }
+};
 
-	struct urb *irq_in;		/* urb for interrupt in report */
-	unsigned char *idata;		/* input data */
-	dma_addr_t idata_dma;
+/* The dead zone and stick limit both affect the behavior of the corresponding
+ * analog stick, since the output values reported for the stick inputs will
+ * be scaled onto [0,32767]. It is thus necessary to ensure that the dead zone
+ * is never larger than the stick limit. In fact, a minimal amount of stick
+ * travel space (1024) is maintained between the two values. In practice,
+ * however, the stick limit should always be much greater than the dead zone.
+ */
 
-	struct urb *bulk_out;
-	unsigned char *bdata;
+static void set_dead_zone(unsigned int new_size, unsigned int *dz,
+		unsigned int stick_limit)
+{
+	*dz = min(new_size, stick_limit - 1024);
+}
 
-#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
-	struct urb *irq_out;		/* urb for interrupt out report */
-	unsigned char *odata;		/* output data */
-	dma_addr_t odata_dma;
-	struct mutex odata_mutex;
-#endif
+static void set_stick_limit(unsigned int new_size, unsigned int *sl,
+		unsigned int dead_zone)
+{
+	*sl = min(max(new_size, dead_zone + 1024), 32767u);
+}
 
-#if defined(CONFIG_JOYSTICK_XPAD_LEDS)
-	struct xpad_led *led;
-#endif
 
-	char phys[64];			/* physical device path */
+/****************************************************************************/
+/*
+ * SysFs interface functions
+ *
+ * We use common functions, where possible, to implement the show/store
+ * routines. This design saves on code and reduces the burden of adding to or
+ * changing the interface.
+ */
+
+
+static ssize_t xpad_show_uint(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct usb_xpad *xpad = to_xpad(dev);
+	unsigned int value;
+	if (attr == &dev_attr_left_dead_zone)
+		value = xpad->left_dead_zone;
+	else if (attr == &dev_attr_right_dead_zone)
+		value = xpad->right_dead_zone;
+	else if (attr == &dev_attr_left_stick_limit)
+		value = xpad->left_stick_limit;
+	else if (attr == &dev_attr_right_stick_limit)
+		value = xpad->right_stick_limit;
+	else
+		return -EIO;
+	return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+
+static ssize_t xpad_store_uint(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct usb_xpad *xpad = to_xpad(dev);
+	unsigned int new_value;
+	if (sscanf(buf, "%u", &new_value) != 1)
+		return -EIO;
+
+	if (attr == &dev_attr_left_dead_zone)
+		set_dead_zone(new_value, &xpad->left_dead_zone,
+				xpad->left_stick_limit);
+	else if (attr == &dev_attr_right_dead_zone)
+		set_dead_zone(new_value, &xpad->right_dead_zone,
+				xpad->right_stick_limit);
+	else if (attr == &dev_attr_left_stick_limit)
+		set_stick_limit(new_value, &xpad->left_stick_limit,
+				xpad->left_dead_zone);
+	else if (attr == &dev_attr_right_stick_limit)
+		set_stick_limit(new_value, &xpad->right_stick_limit,
+				xpad->right_dead_zone);
+	else
+		return -EIO;
+	return strnlen(buf, PAGE_SIZE);
+}
+
+
+static ssize_t xpad_store_bool(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct usb_xpad *xpad = to_xpad(dev);
+	int newvalue;
+	if (sscanf(buf, "%d", &newvalue) != 1)
+		return -EIO;
+
+	if (attr == &dev_attr_rumble_enable)
+		xpad->rumble_enable = (newvalue) ? 1 : 0;
+	else if (attr == &dev_attr_left_trigger_full_axis)
+		xpad->left_trigger_full_axis = (newvalue) ? 1 : 0;
+	else if (attr == &dev_attr_right_trigger_full_axis)
+		xpad->right_trigger_full_axis = (newvalue) ? 1 : 0;
+	return strnlen(buf, PAGE_SIZE);
+}
+
+
+/* read-only attributes share a common store function that returns an error */
+static ssize_t xpad_store_ro(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	return -EIO;
+}
+
+
+static ssize_t xpad_show_int(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct usb_xpad *xpad = to_xpad(dev);
+	int value;
+	if (attr == &dev_attr_rumble_enable)
+		value = xpad->rumble_enable;
+	else if (attr == &dev_attr_controller_number)
+		value = xpad->controller_number;
+	else if (attr == &dev_attr_controller_present)
+		value = xpad->controller_present;
+	else if (attr == &dev_attr_controller_type)
+		value = xpad->controller_type;
+	else if (attr == &dev_attr_left_trigger_full_axis)
+		value = xpad->left_trigger_full_axis;
+	else if (attr == &dev_attr_right_trigger_full_axis)
+		value = xpad->right_trigger_full_axis;
+	else
+		return -EIO;
+	return snprintf(buf, PAGE_SIZE, "%d\n", value);
+}
+
+
+static ssize_t xpad_show_id(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct usb_xpad *xpad = to_xpad(dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n", xpad->controller_unique_id);
+}
+
+
+/* end of sysfs interface */
+/*****************************************************************************/
+
+/* Input section */
+
+/*	xpad_init_controller
+ *
+ *	Performs controller setup based on controller type.
+ *
+ *	NOTE: xpad->controller_data->controller_type needs to be set BEFORE
+ *	calling this function!
+ */
+
+static void xpad_init_controller(struct usb_xpad *xpad)
+{
+	set_stick_limit(XSTICK_LIMIT_DEFAULT, &xpad->left_stick_limit,
+			xpad->left_dead_zone);
+	set_stick_limit(XSTICK_LIMIT_DEFAULT, &xpad->right_stick_limit,
+			xpad->right_dead_zone);
+	set_dead_zone(XDEAD_ZONE_DEFAULT, &xpad->left_dead_zone,
+			xpad->left_stick_limit);
+	set_dead_zone(XDEAD_ZONE_DEFAULT, &xpad->right_dead_zone,
+			xpad->right_stick_limit);
+	xpad->left_trigger_full_axis = XFULL_TRIGGER_AXIS_DEFAULT;
+	xpad->right_trigger_full_axis = XFULL_TRIGGER_AXIS_DEFAULT;
+
+	if (xpad->controller_type == XCONTROLLER_TYPE_GUITAR)
+		xpad->rumble_enable = 0;
+	else if (xpad->controller_type == XCONTROLLER_TYPE_DANCE_PAD)
+		xpad->rumble_enable = 0;
+	else
+		xpad->rumble_enable = 1;
+}
+
+
+/*
+ *	xpad_process_sticks
+ *
+ *	Handles stick input, accounting for dead zones and square axes. Based
+ *	on the original handlers for the Xbox and Xbox 360 in
+ *	xpad_process_packet and xpad360_process_packet, but unified to avoid
+ *	duplication.
+ *
+ *	Whenever a dead zone is used, each axis is scaled so that moving the
+ *	stick slightly out of the dead zone range results in a low axis
+ *	value in jstest(1), while moving the stick to the maximum position
+ *	along any axis still results in 32767.
+ *
+ *	In order to provide the ability to map inputs to a square axis (used
+ *	by older games), the left_stick_limit and right_stick_limit can be
+ *	set. These limits specify at what point in the raw input coordinates
+ *	an axis is reported to be at maximum value (32767 or -32767).
+ *
+ *	Both the dead zone and stick limit algorithms are implemented
+ *	together as a coordinate transformation from "effective coordinates"
+ *	onto the output coordinates (which have absolute values from 0 to
+ *	32767 and are positive or negative based on direction). Effective
+ *	coordinates are defined as those input values that are greater than
+ *	the dead zone but less than the stick limit on the axis in question.
+ *
+ *	DANGER: All denominator values in division operations MUST be checked
+ *	for non-zero condition. Dividing by zero inside the kernel can cause
+ *	a system deadlock.
+ */
+
+static void xpad_process_sticks(struct usb_xpad *xpad, __le16 *data)
+{
+	struct input_dev *dev = xpad->dev;
+	s16 coords[4];    /* x, y, rx, ry */
+	int c;
+	int range;
+	int abs_magnitude, adjusted_magnitude, difference, scale_fraction;
+	int dead_zone[2], stick_limit[2];
+
+	dead_zone[0] = xpad->left_dead_zone;
+	dead_zone[1] = xpad->right_dead_zone;
+	stick_limit[0] = xpad->left_stick_limit;
+	stick_limit[1] = xpad->right_stick_limit;
+
+	/* Stick input data starts at byte 12 (16-bit word 6) for the regular
+	 * Xbox controller, byte 6 (16-bit word 3) for the 360 controllers */
+	data += (xpad->xtype == XTYPE_XBOX) ? 6 : 3;
+
+	coords[0] = le16_to_cpup(data);
+	coords[1] = ~le16_to_cpup(data + 1);
+	coords[2] = le16_to_cpup(data + 2);
+	coords[3] = ~le16_to_cpup(data + 3);
+
+	/* Adjustment for dead zone and square axis */
+	for (c = 0; c < 4; c++) {
+		abs_magnitude = abs(coords[c]);
+		adjusted_magnitude = abs_magnitude;
+
+		range = (stick_limit[c/2] - dead_zone[c/2]);
+
+		if (abs_magnitude >= stick_limit[c/2]) {
+			adjusted_magnitude = 32767;
+		} else if (abs_magnitude <= dead_zone[c/2]) {
+			adjusted_magnitude = 0;
+		} else if (range > 0) {
+			difference = 32767 - range;
+			if (difference) {
+				/* DIVISION: difference non-zero */
+				scale_fraction = range / difference;
+				adjusted_magnitude =
+					abs_magnitude - dead_zone[c/2];
+
+				/* Approximate floating-point division with a
+				 * "catch-up" scaling algorithm that adds back
+				 * to the adjusted_magnitude based on distance
+				 * from the origin (0 in adjusted coordinates).
+				 * If the range / difference is at least 1,
+				 * then 1 needs to be added to the adjusted
+				 * magnitude for every scale_fraction units
+				 * from the origin. If the range / difference
+				 * is less than 1 (0 in integer division),
+				 * then divide the difference by the range to
+				 * obtain the number of units to add per unit
+				 * from the adjusted origin.
+				 */
+				if (scale_fraction) {
+					/* DIVISION: scale_fraction non-zero */
+					adjusted_magnitude +=
+						adjusted_magnitude
+						/ scale_fraction;
+				} else {
+					/* DIVISION: range non-zero */
+					scale_fraction = difference / range;
+					adjusted_magnitude +=
+						adjusted_magnitude
+						* scale_fraction;
+				}
+				if (adjusted_magnitude > 32767)
+					adjusted_magnitude = 32767;
+			}
+		}
+		coords[c] = (coords[c] < 0) ?
+				-adjusted_magnitude : adjusted_magnitude;
+	}
+
+	input_report_abs(dev, ABS_X, coords[0]);
+	input_report_abs(dev, ABS_Y, coords[1]);
+	input_report_abs(dev, ABS_RX, coords[2]);
+	input_report_abs(dev, ABS_RY, coords[3]);
+}
 
-	int dpad_mapping;		/* map d-pad to buttons or to axes */
-	int xtype;			/* type of xbox device */
-};
 
 /*
  *	xpad_process_packet
@@ -260,21 +546,13 @@ struct usb_xpad {
  *	 http://euc.jp/periphs/xbox-controller.ja.html
  */
 
-static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
+static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd,
+		unsigned char *data)
 {
 	struct input_dev *dev = xpad->dev;
 
-	/* left stick */
-	input_report_abs(dev, ABS_X,
-			 (__s16) le16_to_cpup((__le16 *)(data + 12)));
-	input_report_abs(dev, ABS_Y,
-			 ~(__s16) le16_to_cpup((__le16 *)(data + 14)));
-
-	/* right stick */
-	input_report_abs(dev, ABS_RX,
-			 (__s16) le16_to_cpup((__le16 *)(data + 16)));
-	input_report_abs(dev, ABS_RY,
-			 ~(__s16) le16_to_cpup((__le16 *)(data + 18)));
+	/* left and right sticks */
+	xpad_process_sticks(xpad, (__le16 *) data);
 
 	/* triggers left/right */
 	input_report_abs(dev, ABS_Z, data[10]);
@@ -312,6 +590,7 @@ static void xpad_process_packet(struct u
 	input_sync(dev);
 }
 
+
 /*
  *	xpad360_process_packet
  *
@@ -322,10 +601,11 @@ static void xpad_process_packet(struct u
  *		http://www.free60.org/wiki/Gamepad
  */
 
-static void xpad360_process_packet(struct usb_xpad *xpad,
-				   u16 cmd, unsigned char *data)
+static void xpad360_process_packet(struct usb_xpad *xpad, u16 cmd,
+		unsigned char *data)
 {
 	struct input_dev *dev = xpad->dev;
+	int trigger;
 
 	/* digital pad */
 	if (xpad->dpad_mapping == MAP_DPAD_TO_AXES) {
@@ -358,25 +638,80 @@ static void xpad360_process_packet(struc
 	input_report_key(dev, BTN_TR,	data[3] & 0x02);
 	input_report_key(dev, BTN_MODE,	data[3] & 0x04);
 
-	/* left stick */
-	input_report_abs(dev, ABS_X,
-			 (__s16) le16_to_cpup((__le16 *)(data + 6)));
-	input_report_abs(dev, ABS_Y,
-			 ~(__s16) le16_to_cpup((__le16 *)(data + 8)));
-
-	/* right stick */
-	input_report_abs(dev, ABS_RX,
-			 (__s16) le16_to_cpup((__le16 *)(data + 10)));
-	input_report_abs(dev, ABS_RY,
-			 ~(__s16) le16_to_cpup((__le16 *)(data + 12)));
+	/* left and right sticks */
+	xpad_process_sticks(xpad, (__le16 *) data);
 
-	/* triggers left/right */
-	input_report_abs(dev, ABS_Z, data[4]);
-	input_report_abs(dev, ABS_RZ, data[5]);
+	/* triggers left/right: when full_axis is not enabled, report the
+	 * absolute data value (0-255), which will be mapped onto [0,32767].
+	 * If full axis is enabled, map the data value onto [-255:255], so
+	 * that the input subsystem maps it onto [-32767:32767]. */
+	trigger = data[4];
+	if (xpad->left_trigger_full_axis)
+		trigger = (2 * trigger) - 255;
+	input_report_abs(dev, ABS_Z, trigger);
+	trigger = data[5];
+	if (xpad->right_trigger_full_axis)
+		trigger = (2 * trigger) - 255;
+	input_report_abs(dev, ABS_RZ, trigger);
 
 	input_sync(dev);
 }
 
+
+static void xpad360w_identify_controller(struct usb_xpad *xpad)
+{
+	int i;
+	unsigned char *data = xpad->id_packet;
+
+	if (!data)
+		return;
+
+	snprintf(xpad->controller_unique_id, 17,
+		"%02x%02x%02x%02x%02x%02x%02x%02x",
+		data[8], data[9], data[10], data[11], data[12], data[13],
+		data[14], data[15]);
+
+	/* Identify controller type */
+	xpad->controller_type = XCONTROLLER_TYPE_OTHER;
+	for (i = 0; w360_id[i].id_bytes; i++) {
+		if (!memcmp(data + 22, &w360_id[i].id_bytes, 4)) {
+			xpad->controller_type =
+				w360_id[i].controller_type;
+			break;
+		}
+	}
+
+	if (xpad->controller_type == XCONTROLLER_TYPE_OTHER)
+		printk(KERN_INFO "xpad: unknown wireless controller: "
+			"%02x%02x %02x%02x\n", data[22], data[23], data[24],
+			data[25]);
+}
+
+
+/*
+ *	xpad_work_controller
+ *
+ *	Submits command to set pad number on LED display of wireless 360
+ *	controllers, as well as online/offline event. The shared workqueue
+ *      is used for this purpose, so that the interrupt handler is kept short.
+ */
+
+static void xpad_work_controller(struct work_struct *w)
+{
+	struct usb_xpad *xpad = container_of(w, struct usb_xpad, work);
+	if (xpad->controller_present) {
+		xpad360w_identify_controller(xpad);
+		xpad_init_controller(xpad);
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+		xpad_send_led_command(xpad, xpad->controller_number + 1);
+#endif
+		kobject_uevent(&xpad->dev->dev.kobj, KOBJ_ONLINE);
+	} else {
+		kobject_uevent(&xpad->dev->dev.kobj, KOBJ_OFFLINE);
+	}
+}
+
+
 /*
  * xpad360w_process_packet
  *
@@ -386,30 +721,57 @@ static void xpad360_process_packet(struc
  * Byte.Bit
  * 00.1 - Status change: The controller or headset has connected/disconnected
  *                       Bits 01.7 and 01.6 are valid
+ * 01.f - Some kind of unique identifier message (see above)
  * 01.7 - Controller present
  * 01.6 - Headset present
  * 01.1 - Pad state (Bytes 4+) valid
  *
  */
 
-static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
+static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd,
+		unsigned char *data)
 {
+	int padnum = 0;
+
 	/* Presence change */
 	if (data[0] & 0x08) {
+		padnum = xpad->controller_number;
 		if (data[1] & 0x80) {
-			xpad->pad_present = 1;
-			usb_submit_urb(xpad->bulk_out, GFP_ATOMIC);
-		} else
-			xpad->pad_present = 0;
+			/* ignore duplicates */
+			if (!xpad->controller_present) {
+				xpad->controller_present = 1;
+				/*schedule_work(&xpad->work);*/
+				/* Wait for id packet before setting
+				 * controller type and LEDs */
+			}
+		} else {
+			xpad->controller_present = 0;
+			xpad->controller_unique_id[0] = '\0';
+			xpad->controller_type = XCONTROLLER_TYPE_NONE;
+			/* We do NOT flush the shared workqueue here, because
+			 * this function is called from an interrupt handler.
+			 * If the controller has disconnected from the receiver,
+			 * the worst that will happen from the work task running
+			 * is that a packet will be transmitted from the
+			 * receiver to a non-listening controller
+			 */
+		}
 	}
 
-	/* Valid pad data */
-	if (!(data[1] & 0x1))
-		return;
-
-	xpad360_process_packet(xpad, cmd, &data[4]);
+	/* Process packets according to type */
+	if (data[1] == 0x0f) {
+		if (!xpad->controller_unique_id[0]) {
+			if (xpad->id_packet) {
+				memcpy(xpad->id_packet, data, 29);
+				schedule_work(&xpad->work);
+			}
+		}
+	} else if (data[1] & 0x1) {
+		xpad360_process_packet(xpad, cmd, &data[4]);
+	}
 }
 
+
 static void xpad_irq_in(struct urb *urb)
 {
 	struct usb_xpad *xpad = urb->context;
@@ -448,26 +810,16 @@ static void xpad_irq_in(struct urb *urb)
 exit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval)
-		err ("%s - usb_submit_urb failed with result %d",
+		err("%s - usb_submit_urb failed with result %d",
 		     __func__, retval);
 }
 
-static void xpad_bulk_out(struct urb *urb)
-{
-	switch (urb->status) {
-	case 0:
-		/* success */
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __func__, urb->status);
-		break;
-	default:
-		dbg("%s - nonzero urb status received: %d", __func__, urb->status);
-	}
-}
+/* end input section */
+
+/*****************************************************************************/
+/* IRQ output section: present in object code only if the force feedback or
+ * LED interface is enabled.
+ */
 
 #if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
 static void xpad_irq_out(struct urb *urb)
@@ -500,12 +852,13 @@ exit:
 		    __func__, retval);
 }
 
+
 static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
 {
 	struct usb_endpoint_descriptor *ep_irq_out;
 	int error = -ENOMEM;
 
-	if (xpad->xtype != XTYPE_XBOX360)
+	if ((xpad->xtype != XTYPE_XBOX360) && (xpad->xtype != XTYPE_XBOX360W))
 		return 0;
 
 	xpad->odata = usb_buffer_alloc(xpad->udev, XPAD_PKT_LEN,
@@ -521,7 +874,8 @@ static int xpad_init_output(struct usb_i
 
 	ep_irq_out = &intf->cur_altsetting->endpoint[1].desc;
 	usb_fill_int_urb(xpad->irq_out, xpad->udev,
-			 usb_sndintpipe(xpad->udev, ep_irq_out->bEndpointAddress),
+			 usb_sndintpipe(xpad->udev,
+				ep_irq_out->bEndpointAddress),
 			 xpad->odata, XPAD_PKT_LEN,
 			 xpad_irq_out, xpad, ep_irq_out->bInterval);
 	xpad->irq_out->transfer_dma = xpad->odata_dma;
@@ -535,43 +889,79 @@ static int xpad_init_output(struct usb_i
 
 static void xpad_stop_output(struct usb_xpad *xpad)
 {
-	if (xpad->xtype == XTYPE_XBOX360)
+	if ((xpad->xtype == XTYPE_XBOX360) || (xpad->xtype == XTYPE_XBOX360W))
 		usb_kill_urb(xpad->irq_out);
 }
 
 static void xpad_deinit_output(struct usb_xpad *xpad)
 {
-	if (xpad->xtype == XTYPE_XBOX360) {
+	if ((xpad->xtype == XTYPE_XBOX360) || (xpad->xtype == XTYPE_XBOX360W)) {
 		usb_free_urb(xpad->irq_out);
 		usb_buffer_free(xpad->udev, XPAD_PKT_LEN,
 				xpad->odata, xpad->odata_dma);
 	}
 }
 #else
-static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }
+/* Dummy implementations for xpad_probe and xpad_disconnect */
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
+	{ return 0; }
 static void xpad_deinit_output(struct usb_xpad *xpad) {}
 static void xpad_stop_output(struct usb_xpad *xpad) {}
 #endif
 
+/* end output section */
+
+/*****************************************************************************/
+
+/* Force feedback (rumble effect) section, depends on CONFIG_JOYSTICK_XPAD_FF */
+
 #ifdef CONFIG_JOYSTICK_XPAD_FF
+
+/* Rumble support for wireless controllers follows protocol description
+ * from xboxdrv userspace driver:
+ *       http://pingus.seul.org/~grumbel/xboxdrv/
+ */
 static int xpad_play_effect(struct input_dev *dev, void *data,
 			    struct ff_effect *effect)
 {
 	struct usb_xpad *xpad = input_get_drvdata(dev);
 
+	if (!xpad->rumble_enable)
+		return 0;
+
 	if (effect->type == FF_RUMBLE) {
 		__u16 strong = effect->u.rumble.strong_magnitude;
 		__u16 weak = effect->u.rumble.weak_magnitude;
-		xpad->odata[0] = 0x00;
-		xpad->odata[1] = 0x08;
-		xpad->odata[2] = 0x00;
-		xpad->odata[3] = strong / 256;
-		xpad->odata[4] = weak / 256;
-		xpad->odata[5] = 0x00;
-		xpad->odata[6] = 0x00;
-		xpad->odata[7] = 0x00;
-		xpad->irq_out->transfer_buffer_length = 8;
+
+		mutex_lock(&xpad->odata_mutex);
+		if (xpad->xtype == XTYPE_XBOX360W) {
+			xpad->odata[0] = 0x00;
+			xpad->odata[1] = 0x01;
+			xpad->odata[2] = 0x0f;
+			xpad->odata[3] = 0xc0;
+			xpad->odata[4] = 0x00;
+			xpad->odata[5] = strong / 256;
+			xpad->odata[6] = weak / 256;
+			xpad->odata[7] = 0x00;
+			xpad->odata[8] = 0x00;
+			xpad->odata[9] = 0x00;
+			xpad->odata[10] = 0x00;
+			xpad->odata[11] = 0x00;
+			xpad->irq_out->transfer_buffer_length = 12;
+		} else {
+			xpad->odata[0] = 0x00;
+			xpad->odata[1] = 0x08;
+			xpad->odata[2] = 0x00;
+			xpad->odata[3] = strong / 256;
+			xpad->odata[4] = weak / 256;
+			xpad->odata[5] = 0x00;
+			xpad->odata[6] = 0x00;
+			xpad->odata[7] = 0x00;
+			xpad->irq_out->transfer_buffer_length = 8;
+		}
+		/* FIXME: now atomic? */
 		usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
+		mutex_unlock(&xpad->odata_mutex);
 	}
 
 	return 0;
@@ -579,7 +969,7 @@ static int xpad_play_effect(struct input
 
 static int xpad_init_ff(struct usb_xpad *xpad)
 {
-	if (xpad->xtype != XTYPE_XBOX360)
+	if ((xpad->xtype != XTYPE_XBOX360) && (xpad->xtype != XTYPE_XBOX360W))
 		return 0;
 
 	input_set_capability(xpad->dev, EV_FF, FF_RUMBLE);
@@ -588,26 +978,49 @@ static int xpad_init_ff(struct usb_xpad 
 }
 
 #else
+/* dummy implementation for xpad_probe */
 static int xpad_init_ff(struct usb_xpad *xpad) { return 0; }
 #endif
 
-#if defined(CONFIG_JOYSTICK_XPAD_LEDS)
-#include <linux/leds.h>
 
-struct xpad_led {
-	char name[16];
-	struct led_classdev led_cdev;
-	struct usb_xpad *xpad;
-};
+/* end force feedback section */
+
+/*****************************************************************************/
+
+/* LED handling section: provides support for the ring of LEDs on the 360
+ * controllers. */
+
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+
 
+/* XBox 360 wireless controller follows protocol from xboxdrv userspace
+ * driver:
+ *    http://pingus.seul.org/~grumbel/xboxdrv/
+ */
 static void xpad_send_led_command(struct usb_xpad *xpad, int command)
 {
 	if (command >= 0 && command < 14) {
 		mutex_lock(&xpad->odata_mutex);
-		xpad->odata[0] = 0x01;
-		xpad->odata[1] = 0x03;
-		xpad->odata[2] = command;
-		xpad->irq_out->transfer_buffer_length = 3;
+		if (xpad->xtype == XTYPE_XBOX360W) {
+			xpad->odata[0] = 0x00;
+			xpad->odata[1] = 0x00;
+			xpad->odata[2] = 0x08;
+			xpad->odata[3] = 0x40 + (command % 0x0e);
+			xpad->odata[4] = 0x00;
+			xpad->odata[5] = 0x00;
+			xpad->odata[6] = 0x00;
+			xpad->odata[7] = 0x00;
+			xpad->odata[8] = 0x00;
+			xpad->odata[9] = 0x00;
+			xpad->odata[10] = 0x00;
+			xpad->odata[11] = 0x00;
+			xpad->irq_out->transfer_buffer_length = 12;
+		} else {
+			xpad->odata[0] = 0x01;
+			xpad->odata[1] = 0x03;
+			xpad->odata[2] = command;
+			xpad->irq_out->transfer_buffer_length = 3;
+		}
 		usb_submit_urb(xpad->irq_out, GFP_KERNEL);
 		mutex_unlock(&xpad->odata_mutex);
 	}
@@ -622,6 +1035,7 @@ static void xpad_led_set(struct led_clas
 	xpad_send_led_command(xpad_led->xpad, value);
 }
 
+
 static int xpad_led_probe(struct usb_xpad *xpad)
 {
 	static atomic_t led_seq	= ATOMIC_INIT(0);
@@ -630,7 +1044,7 @@ static int xpad_led_probe(struct usb_xpa
 	struct led_classdev *led_cdev;
 	int error;
 
-	if (xpad->xtype != XTYPE_XBOX360)
+	if ((xpad->xtype != XTYPE_XBOX360) && (xpad->xtype != XTYPE_XBOX360W))
 		return 0;
 
 	xpad->led = led = kzalloc(sizeof(struct xpad_led), GFP_KERNEL);
@@ -671,17 +1085,23 @@ static void xpad_led_disconnect(struct u
 	}
 }
 #else
+/* dummies for xpad_probe and xpad_disconnect */
 static int xpad_led_probe(struct usb_xpad *xpad) { return 0; }
 static void xpad_led_disconnect(struct usb_xpad *xpad) { }
 #endif
 
+/* end LED section */
+
+/*****************************************************************************/
+
+/* Module and device functions */
 
 static int xpad_open(struct input_dev *dev)
 {
 	struct usb_xpad *xpad = input_get_drvdata(dev);
 
 	/* URB was submitted in probe */
-	if(xpad->xtype == XTYPE_XBOX360W)
+	if (xpad->xtype == XTYPE_XBOX360W)
 		return 0;
 
 	xpad->irq_in->dev = xpad->udev;
@@ -695,7 +1115,7 @@ static void xpad_close(struct input_dev 
 {
 	struct usb_xpad *xpad = input_get_drvdata(dev);
 
-	if(xpad->xtype != XTYPE_XBOX360W)
+	if (xpad->xtype != XTYPE_XBOX360W)
 		usb_kill_urb(xpad->irq_in);
 	xpad_stop_output(xpad);
 }
@@ -713,7 +1133,10 @@ static void xpad_set_up_abs(struct input
 		break;
 	case ABS_Z:
 	case ABS_RZ:	/* the triggers */
-		input_set_abs_params(input_dev, abs, 0, 255, 0, 0);
+		/* Triggers have a phony -255 to 255 range. Normally, only
+		 * 0 to 255 will be reported (+ axis), unless full_trigger_axis
+		 * is set, in which case -255 to 255 will be reported. */
+		input_set_abs_params(input_dev, abs, -255, 255, 0, 0);
 		break;
 	case ABS_HAT0X:
 	case ABS_HAT0Y:	/* the d-pad (only if MAP_DPAD_TO_AXES) */
@@ -722,18 +1145,22 @@ static void xpad_set_up_abs(struct input
 	}
 }
 
-static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id)
+static int xpad_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_xpad *xpad;
 	struct input_dev *input_dev;
 	struct usb_endpoint_descriptor *ep_irq_in;
+	int controller_type;
 	int i;
 	int error = -ENOMEM;
 
 	for (i = 0; xpad_device[i].idVendor; i++) {
-		if ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&
-		    (le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))
+		if ((le16_to_cpu(udev->descriptor.idVendor) ==
+						xpad_device[i].idVendor) &&
+				(le16_to_cpu(udev->descriptor.idProduct) ==
+						xpad_device[i].idProduct))
 			break;
 	}
 
@@ -754,11 +1181,14 @@ static int xpad_probe(struct usb_interfa
 	xpad->udev = udev;
 	xpad->dpad_mapping = xpad_device[i].dpad_mapping;
 	xpad->xtype = xpad_device[i].xtype;
+	controller_type = xpad_device[i].controller_type;
 	if (xpad->dpad_mapping == MAP_DPAD_UNKNOWN)
 		xpad->dpad_mapping = !dpad_to_buttons;
 	if (xpad->xtype == XTYPE_UNKNOWN) {
-		if (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {
-			if (intf->cur_altsetting->desc.bInterfaceProtocol == 129)
+		if (intf->cur_altsetting->desc.bInterfaceClass ==
+					USB_CLASS_VENDOR_SPEC) {
+			if (intf->cur_altsetting->desc.bInterfaceProtocol ==
+					129)
 				xpad->xtype = XTYPE_XBOX360W;
 			else
 				xpad->xtype = XTYPE_XBOX360;
@@ -790,16 +1220,18 @@ static int xpad_probe(struct usb_interfa
 	else
 		for (i = 0; xpad_btn[i] >= 0; i++)
 			set_bit(xpad_btn[i], input_dev->keybit);
-	if (xpad->dpad_mapping == MAP_DPAD_TO_BUTTONS)
+	if (xpad->dpad_mapping == MAP_DPAD_TO_BUTTONS) {
 		for (i = 0; xpad_btn_pad[i] >= 0; i++)
 			set_bit(xpad_btn_pad[i], input_dev->keybit);
+	}
 
 	/* set up axes */
 	for (i = 0; xpad_abs[i] >= 0; i++)
 		xpad_set_up_abs(input_dev, xpad_abs[i]);
-	if (xpad->dpad_mapping == MAP_DPAD_TO_AXES)
+	if (xpad->dpad_mapping == MAP_DPAD_TO_AXES) {
 		for (i = 0; xpad_abs_pad[i] >= 0; i++)
-		    xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
+			xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
+	}
 
 	error = xpad_init_output(intf, xpad);
 	if (error)
@@ -827,6 +1259,10 @@ static int xpad_probe(struct usb_interfa
 
 	usb_set_intfdata(intf, xpad);
 
+	xpad->controller_type = controller_type;
+	if (controller_type != XCONTROLLER_TYPE_NONE)
+		xpad_init_controller(xpad);
+
 	/*
 	 * Submit the int URB immediatly rather than waiting for open
 	 * because we get status messages from the device whether
@@ -835,48 +1271,43 @@ static int xpad_probe(struct usb_interfa
 	 * we're waiting for.
 	 */
 	if (xpad->xtype == XTYPE_XBOX360W) {
+		xpad->controller_present = 0;
+		xpad->controller_number =
+			(intf->cur_altsetting->desc.bInterfaceNumber / 2) + 1;
 		xpad->irq_in->dev = xpad->udev;
 		error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
 		if (error)
-			goto fail4;
-
-		/*
-		 * Setup the message to set the LEDs on the
-		 * controller when it shows up
-		 */
-		xpad->bulk_out = usb_alloc_urb(0, GFP_KERNEL);
-		if(!xpad->bulk_out)
 			goto fail5;
+		xpad->id_packet = kzalloc(XPAD_PKT_LEN *
+					sizeof(unsigned char), GFP_KERNEL);
+		if (!xpad->id_packet)
+			goto fail5;
+	} else {
+		xpad->controller_present = 1;
+		xpad->controller_number = 0;
+	}
 
-		xpad->bdata = kzalloc(XPAD_PKT_LEN, GFP_KERNEL);
-		if(!xpad->bdata)
-			goto fail6;
-
-		xpad->bdata[2] = 0x08;
-		switch (intf->cur_altsetting->desc.bInterfaceNumber) {
-		case 0:
-			xpad->bdata[3] = 0x42;
-			break;
-		case 2:
-			xpad->bdata[3] = 0x43;
-			break;
-		case 4:
-			xpad->bdata[3] = 0x44;
-			break;
-		case 6:
-			xpad->bdata[3] = 0x45;
-		}
-
-		ep_irq_in = &intf->cur_altsetting->endpoint[1].desc;
-		usb_fill_bulk_urb(xpad->bulk_out, udev,
-				usb_sndbulkpipe(udev, ep_irq_in->bEndpointAddress),
-				xpad->bdata, XPAD_PKT_LEN, xpad_bulk_out, xpad);
+	/* Set up device attributes */
+	xpad->sysfs_ok = 1;
+	xpad->controller_unique_id[0] = '\0';
+	error = sysfs_create_group(&input_dev->dev.kobj,
+						&xpad_default_attr_group);
+	if (error) {
+		/* Driver will work without the sysfs interface, but parameters
+		 * will not be adjustable, so this failure is a warning. */
+		printk(KERN_WARNING
+			"xpad: sysfs_create_group failed with error %d\n",
+			error);
+		xpad->sysfs_ok = 0;
 	}
+
+	INIT_WORK(&xpad->work, &xpad_work_controller);
 
 	return 0;
 
- fail6:	usb_free_urb(xpad->bulk_out);
- fail5:	usb_kill_urb(xpad->irq_in);
+ fail5: usb_set_intfdata(intf, NULL);
+	input_unregister_device(xpad->dev);
+	xpad_led_disconnect(xpad);
  fail4:	usb_free_urb(xpad->irq_in);
  fail3:	xpad_deinit_output(xpad);
  fail2:	usb_buffer_free(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);
@@ -888,31 +1319,32 @@ static int xpad_probe(struct usb_interfa
 
 static void xpad_disconnect(struct usb_interface *intf)
 {
-	struct usb_xpad *xpad = usb_get_intfdata (intf);
+	struct usb_xpad *xpad = usb_get_intfdata(intf);
 
 	usb_set_intfdata(intf, NULL);
 	if (xpad) {
+		/* Ensure we don't have any pending work */
+		flush_scheduled_work();
+
+		if (xpad->sysfs_ok)
+			sysfs_remove_group(&xpad->dev->dev.kobj,
+						&xpad_default_attr_group);
+
 		xpad_led_disconnect(xpad);
 		input_unregister_device(xpad->dev);
 		xpad_deinit_output(xpad);
-		if (xpad->xtype == XTYPE_XBOX360W) {
-			usb_kill_urb(xpad->bulk_out);
-			usb_free_urb(xpad->bulk_out);
+		if (xpad->xtype == XTYPE_XBOX360W)
 			usb_kill_urb(xpad->irq_in);
-		}
 		usb_free_urb(xpad->irq_in);
 		usb_buffer_free(xpad->udev, XPAD_PKT_LEN,
 				xpad->idata, xpad->idata_dma);
+		if (xpad->id_packet)
+			kfree(xpad->id_packet);
 		kfree(xpad);
 	}
 }
 
-static struct usb_driver xpad_driver = {
-	.name		= "xpad",
-	.probe		= xpad_probe,
-	.disconnect	= xpad_disconnect,
-	.id_table	= xpad_table,
-};
+
 
 static int __init usb_xpad_init(void)
 {
@@ -927,6 +1359,7 @@ static void __exit usb_xpad_exit(void)
 	usb_deregister(&xpad_driver);
 }
 
+
 module_init(usb_xpad_init);
 module_exit(usb_xpad_exit);
 
diff -NurpP --minimal linux-2.6.33/drivers/input/joystick/xpad.h linux-2.6.33-xbox0.10/drivers/input/joystick/xpad.h
--- linux-2.6.33/drivers/input/joystick/xpad.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/input/joystick/xpad.h	2010-03-25 02:10:51.000000000 +0100
@@ -0,0 +1,399 @@
+/*
+ * Xbox gamepad driver with Xbox 360 wired/wireless support
+ *
+ * Last Modified:	2 March 2009
+ *			Mike Murphy <mamurph@cs.clemson.edu>
+ *
+ * Copyright (c) 2002 Marko Friedemann <mfr@bmx-chemnitz.de>
+ *               2004 Oliver Schwartz <Oliver.Schwartz@gmx.de>,
+ *                    Steven Toth <steve@toth.demon.co.uk>,
+ *                    Franz Lehner <franz@caos.at>,
+ *                    Ivan Hawkes <blackhawk@ivanhawkes.com>
+ *               2005 Dominic Cerquetti <binary1230@yahoo.com>
+ *               2006 Adam Buchbinder <adam.buchbinder@gmail.com>
+ *               2007 Jan Kratochvil <honza@jikos.cz>
+ *               2009 Clemson University
+ *		      (contact: Mike Murphy <mamurph@cs.clemson.edu>)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ * This driver is based on:
+ *  - information from     http://euc.jp/periphs/xbox-controller.ja.html
+ *  - the iForce driver    drivers/char/joystick/iforce.c
+ *  - the skeleton-driver  drivers/usb/usb-skeleton.c
+ *  - Xbox 360 information http://www.free60.org/wiki/Gamepad
+ *  - xboxdrv docs         http://pingus.seul.org/~grumbel/xboxdrv/
+ *
+ * Thanks to:
+ *  - ITO Takayuki for providing essential xpad information on his website
+ *  - Vojtech Pavlik     - iforce driver / input subsystem
+ *  - Greg Kroah-Hartman - usb-skeleton driver
+ *  - XBOX Linux project - extra USB id's
+ *
+ * TODO:
+ *  - fix "analog" buttons (reported as digital now)
+ *  - need USB IDs for other dance pads
+ *
+ * Driver history is located at the bottom of this file.
+ */
+
+#ifndef _XPAD_H
+#define _XPAD_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/module.h>
+#include <linux/usb/input.h>
+#include <linux/workqueue.h>
+
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/string.h>
+
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+#include <linux/leds.h>
+
+struct xpad_led {
+	char name[16];
+	struct led_classdev led_cdev;
+	struct usb_xpad *xpad;
+};
+#endif
+
+
+#define DRIVER_AUTHOR "Marko Friedemann <mfr@bmx-chemnitz.de>"
+#define DRIVER_DESC "Xbox/360 pad driver"
+
+#define XPAD_PKT_LEN 32
+
+
+/* xbox d-pads should map to buttons, as is required for DDR pads
+   but we map them to axes when possible to simplify things */
+#define MAP_DPAD_TO_BUTTONS    0
+#define MAP_DPAD_TO_AXES       1
+#define MAP_DPAD_UNKNOWN       2
+
+/* Type of controller *interface* (original, wired 360, wireless 360) */
+#define XTYPE_XBOX        0
+#define XTYPE_XBOX360     1
+#define XTYPE_XBOX360W    2
+#define XTYPE_UNKNOWN     3
+
+/* Type of controller (e.g. pad, guitar, other input device) */
+#define XCONTROLLER_TYPE_NONE		0
+#define XCONTROLLER_TYPE_PAD		1
+#define XCONTROLLER_TYPE_GUITAR		2
+#define XCONTROLLER_TYPE_DANCE_PAD	3
+#define XCONTROLLER_TYPE_OTHER		255
+
+
+/* The Xbox 360 controllers have sensitive sticks that often do not center
+ * exactly. A dead zone causes stick events below a certain threshhold to be
+ * reported as zero.
+ *
+ * The default dead zone size is 8192, which was obtained by testing a
+ * wireless 360 controller with jstest(1) and consulting gaming forums for
+ * a recommended dead zone for this controller. The consensus opinion was
+ * 0.25 (on a scale from 0 to 1), which corresponds to 8192 (out of 32767).
+ */
+#define XDEAD_ZONE_DEFAULT   8192
+
+/* Default limit for the sticks is the maximum axis value (32767), which will
+ * cause the sticks to have a radial axis as designed in the hardware. To
+ * enable square axis support, set the stick limits to 23170 or lower at run
+ * time via the sysfs interface. */
+#define XSTICK_LIMIT_DEFAULT 32767
+
+/* Rumble normally enabled */
+#define XRUMBLE_DEFAULT		1
+
+/* Normally, trigger axes report in the range 0 to 32767 (positive axis only) */
+#define XFULL_TRIGGER_AXIS_DEFAULT	0
+
+
+/* Xbox 360 has a vendor-specific class, so we cannot match it with only
+ * USB_INTERFACE_INFO (also specifically refused by USB subsystem), so we
+ * match against vendor id as well. Wired Xbox 360 devices have protocol 1,
+ * wireless controllers have protocol 129. */
+#define XPAD_XBOX360_VENDOR_PROTOCOL(vend,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_VENDOR | \
+			USB_DEVICE_ID_MATCH_INT_INFO, \
+	.idVendor = (vend), \
+	.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \
+	.bInterfaceSubClass = 93, \
+	.bInterfaceProtocol = (pr)
+#define XPAD_XBOX360_VENDOR(vend) \
+	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend, 1) }, \
+	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend, 129) }
+
+
+
+/* Some of the fields in the following structure are for later use with
+ * userspace applications to recognize individual controllers. The dead zones
+ * and axis limits can be changed "on the fly" and are effective immediately.
+ *
+ * The fields labeled "ro" and "rw" are intended to be read-only and
+ * read-write, respectively, when exposed in sysfs. Most of the read-only
+ * fields are to support *wireless* 360 controllers. The controller_number
+ * is used to set the LED, while controller_present tracks whether the
+ * controller is connected to the wireless receiver. Controller type applies
+ * to all models (wired and wireless), and tracks whether the device is a pad,
+ * guitar, etc. for later userspace use. See the comment above regarding
+ * type and unique ID detection on wireless 360 receivers.
+ */
+struct usb_xpad {
+	struct input_dev *dev;		/* input device interface */
+	struct usb_device *udev;	/* usb device */
+
+	struct urb *irq_in;		/* urb for interrupt in report */
+	unsigned char *idata;		/* input data */
+	dma_addr_t idata_dma;
+
+#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)
+	struct urb *irq_out;		/* urb for interrupt out report */
+	unsigned char *odata;		/* output data */
+	dma_addr_t odata_dma;
+	struct mutex odata_mutex;
+#endif
+
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+	struct xpad_led *led;
+#endif
+
+	char phys[64];			/* physical device path */
+
+	int dpad_mapping;		/* map d-pad to buttons or to axes */
+	int xtype;			/* type of xbox device */
+
+	/* Work structure for moving the call to xpad_send_led_command
+	 * outside the interrupt handler for packet processing */
+	struct work_struct work;
+
+	/* id packet for wireless 360 controller */
+	unsigned char *id_packet;
+
+	int controller_number;		/* controller # (1-4) for 360w. ro */
+	int controller_present;         /* 360w controller presence. ro */
+	int controller_type;            /* controller type. ro */
+	char controller_unique_id[17];  /* unique ID of controller (360w). ro */
+	unsigned int left_dead_zone;    /* dead zone for left stick. rw */
+	unsigned int right_dead_zone;   /* dead zone for right stick. rw */
+	unsigned int left_stick_limit;  /* axis limit for left stick. rw */
+	unsigned int right_stick_limit; /* axis limit for right stick. rw */
+	int rumble_enable;              /* enable/disable rumble. rw */
+	int left_trigger_full_axis;     /* full axis - left trigger. rw */
+	int right_trigger_full_axis;    /* full axis - right trigger. rw */
+
+	int sysfs_ok;                   /* sysfs interface OK */
+};
+#define to_xpad(d) input_get_drvdata(to_input_dev(d))
+
+
+/* Function prototypes for non-sysfs interface functions */
+static void set_dead_zone(unsigned int new_size, unsigned int *dz,
+	unsigned int stick_limit);
+static void set_stick_limit(unsigned int new_size, unsigned int *sl,
+	unsigned int dead_zone);
+static void xpad_init_controller(struct usb_xpad *xpad);
+static void xpad_work_controller(struct work_struct *w);
+static void xpad_process_sticks(struct usb_xpad *xpad, __le16 *data);
+static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd,
+	unsigned char *data);
+static void xpad360_process_packet(struct usb_xpad *xpad, u16 cmd,
+	unsigned char *data);
+static void xpad360w_identify_controller(struct usb_xpad *xpad);
+static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd,
+	unsigned char *data);
+static void xpad_irq_in(struct urb *urb);
+static void xpad_irq_out(struct urb *urb);
+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad);
+static void xpad_stop_output(struct usb_xpad *xpad);
+static void xpad_stop_output(struct usb_xpad *xpad);
+static int xpad_play_effect(struct input_dev *dev, void *data,
+			    struct ff_effect *effect);
+static int xpad_init_ff(struct usb_xpad *xpad);
+#ifdef CONFIG_JOYSTICK_XPAD_LEDS
+static void xpad_send_led_command(struct usb_xpad *xpad, int command);
+static void xpad_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value);
+static int xpad_led_probe(struct usb_xpad *xpad);
+static void xpad_led_disconnect(struct usb_xpad *xpad);
+#endif
+static int xpad_open(struct input_dev *dev);
+static void xpad_close(struct input_dev *dev);
+static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs);
+static int xpad_probe(struct usb_interface *intf,
+	const struct usb_device_id *id);
+static void xpad_disconnect(struct usb_interface *intf);
+static int __init usb_xpad_init(void);
+static void __exit usb_xpad_exit(void);
+
+
+/* sysfs interface */
+static ssize_t xpad_show_uint(struct device *dev, struct device_attribute *attr,
+		char *buf);
+static ssize_t xpad_store_uint(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t xpad_store_bool(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t xpad_store_ro(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count);
+static ssize_t xpad_show_int(struct device *dev, struct device_attribute *attr,
+		char *buf);
+static ssize_t xpad_show_id(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+
+
+/* Device attributes */
+static DEVICE_ATTR(left_dead_zone, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(right_dead_zone, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(left_stick_limit, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(right_stick_limit, 0644, xpad_show_uint, xpad_store_uint);
+static DEVICE_ATTR(rumble_enable, 0644, xpad_show_int, xpad_store_bool);
+static DEVICE_ATTR(left_trigger_full_axis, 0644, xpad_show_int,
+			xpad_store_bool);
+static DEVICE_ATTR(right_trigger_full_axis, 0644, xpad_show_int,
+			xpad_store_bool);
+static DEVICE_ATTR(controller_number, 0444, xpad_show_int, xpad_store_ro);
+static DEVICE_ATTR(controller_present, 0444, xpad_show_int, xpad_store_ro);
+static DEVICE_ATTR(controller_type, 0444, xpad_show_int, xpad_store_ro);
+static DEVICE_ATTR(id, 0444, xpad_show_id, xpad_store_ro);
+
+static struct attribute *xpad_default_attrs[] = {
+	&dev_attr_left_dead_zone.attr,
+	&dev_attr_right_dead_zone.attr,
+	&dev_attr_left_stick_limit.attr,
+	&dev_attr_right_stick_limit.attr,
+	&dev_attr_rumble_enable.attr,
+	&dev_attr_left_trigger_full_axis.attr,
+	&dev_attr_right_trigger_full_axis.attr,
+	&dev_attr_controller_number.attr,
+	&dev_attr_controller_present.attr,
+	&dev_attr_controller_type.attr,
+	&dev_attr_id.attr,
+	NULL
+};
+
+static struct attribute_group xpad_default_attr_group = {
+	.attrs = xpad_default_attrs,
+	.name = "game_device",
+};
+
+#endif
+
+/* Driver History:
+ *
+ * 2009-03-02 : Code cleanup
+ *  - used min(), max(), and abs() where appropriate, simplifying code
+ *  - moved code that generates data objects out of xpad.h and into xpad.c
+ *  - changed legacy #if defined(...) to #ifdef
+ *  - removed unnecessary typecasts
+ *  - wireless 360 controller identification now done in workqueue task
+ *  - thanks Andrew Morton, Greg K-H, and Linus Torvalds
+ *
+ * 2009-02-28 : Triggers now half-axes by default
+ *  - triggers will now be positive half-axes only, unless a full axis mapping
+ *    is enabled via the sysfs interface on a per-trigger basis
+ *  - moved INIT_WORK to xpad_probe and removed INIT_WORK/PREPARE_WORK from
+ *    interrupt handler; also removed the work_pending flag from struct
+ *    usb_xpad (always flush shared workqueue on unload)
+ *  - read-write sysfs attributes now have 644 default permissions
+ *
+ * 2009-02-23 : Changes per mailing list (thanks Frederic Weisbecker)
+ *  - no more check for CONFIG_SYSFS: sysfs functions will simply return
+ *    0 if sysfs has not been enabled
+ *  - fixed weird ordering in sscanf return check
+ *  - checked code with scripts/checkpatch.pl and made style adjustments
+ *
+ * 2009-02-21 : Refactored and changed stick handling
+ *  - split code into two pieces (xpad.h and xpad.c)
+ *  - cleaned up sysfs interface
+ *  - changed square axis algorithm to an axis limit algorithm, which allows
+ *    size of inscribed square to be adjusted; available for both sticks
+ *  - dead zones now per-stick
+ *
+ * 2009-02-18 : Changes per mailing list (and some additions)
+ *  - revised sysfs interface (thanks Greg K-H)
+ *  - check return values of sscanf (thanks Oliver Neukum)
+ *  - urb submission while holding mutex now once again GFP_KERNEL
+ *    (thanks Oliver Neukum)
+ *  - work structure fixes (thanks Oliver Neukum)
+ *  - uevents generated for wireless controller online/offline
+ *  - sysfs interface only if CONFIG_SYSFS is set
+ *
+ * 2009-02-15 : Minor adjustments
+ *  - added KOBJ_ONLINE/KOBJ_OFFLINE events when controllers are connected to
+ *    or disconnected from the wireless 360 receiver
+ *  - ignore duplicate connect messages on the same connection
+ *  - added option to enable/disable rumble on a per-controller basis
+ *  - rumble events are not sent to guitar or dance pad devices
+ *
+ * 2009-02-14 : Added sysfs interface
+ *  - dead zones and square axis settings can now be made per-controller
+ *  - removed dead_zone and square_axis module parameters (use sysfs)
+ *  - new square axis algorithm
+ *
+ * 2009-02-13 : Disable square axis for right stick
+ *  - square axis applies to left stick only
+ *
+ * 2009-02-12 : Scaling for dead zone and square axis support
+ *  - axes now scale from 0 to 32767 starting at edge of dead zone
+ *  - increased default dead zone to 8192
+ *  - initial square axis support (reliable only with left stick)
+ *
+ * 2009-02-07 : More wireless 360 controller fixes
+ *  - removed bulk urb completely
+ *  - use xpad_send_led_command to set controller number on LED display
+ *    (wireless 360 controller)
+ *  - dead_zone is now an adjustable module parameter
+ *
+ * 2009-02-06 : Axis handling improvements
+ *  - unified handler for left and right sticks
+ *  - initial support for dead zones
+ *
+ * 2009-02-02 : Wireless 360 controller fixes
+ *  - followed PROTOCOL description from xboxdrv userspace driver
+ *  - LED and rumble support added for wireless 360 controller (protocol
+ *    is different from wired!)
+ *
+ * 2004-10-02 - 0.0.6 : DDR pad support
+ *  - borrowed from the XBOX linux kernel
+ *  - USB id's for commonly used dance pads are present
+ *  - dance pads will map D-PAD to buttons, not axes
+ *  - pass the module paramater 'dpad_to_buttons' to force
+ *    the D-PAD to map to buttons if your pad is not detected
+ *
+ * 2002-07-17 - 0.0.5 : simplified d-pad handling
+ *
+ * 2002-07-16 - 0.0.4 : minor changes, merge with Vojtech's v0.0.3
+ *  - verified the lack of HID and report descriptors
+ *  - verified that ALL buttons WORK
+ *  - fixed d-pad to axes mapping
+ *
+ * 2002-07-14 - 0.0.3 : rework by Vojtech Pavlik
+ *  - indentation fixes
+ *  - usb + input init sequence fixes
+ *
+ * 2002-07-02 - 0.0.2 : basic working version
+ *  - all axes and 9 of the 10 buttons work (german InterAct device)
+ *  - the black button does not work
+ *
+ * 2002-06-27 - 0.0.1 : first version, just said "XBOX HID controller"
+ *
+ */
diff -NurpP --minimal linux-2.6.33/drivers/Makefile linux-2.6.33-xbox0.10/drivers/Makefile
--- linux-2.6.33/drivers/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/Makefile	2010-03-25 06:33:43.000000000 +0100
@@ -7,6 +7,7 @@
 
 obj-y				+= gpio/
 obj-$(CONFIG_PCI)		+= pci/
+obj-$(CONFIG_PPC_XENON)		+= xenon/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
 obj-y				+= video/
diff -NurpP --minimal linux-2.6.33/drivers/net/Kconfig linux-2.6.33-xbox0.10/drivers/net/Kconfig
--- linux-2.6.33/drivers/net/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/net/Kconfig	2010-03-19 22:53:41.000000000 +0100
@@ -1576,6 +1576,9 @@ config 8139CP
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called 8139cp.  This is recommended.
+config XENON_ENET
+	tristate "Xenon Fast Ethernet Adapter support"
+	depends on NET_PCI && PCI
 
 config 8139TOO
 	tristate "RealTek RTL-8129/8130/8139 PCI Fast Ethernet Adapter support"
diff -NurpP --minimal linux-2.6.33/drivers/net/Makefile linux-2.6.33-xbox0.10/drivers/net/Makefile
--- linux-2.6.33/drivers/net/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/net/Makefile	2010-03-20 06:09:24.000000000 +0100
@@ -253,6 +253,8 @@ obj-$(CONFIG_DNET) += dnet.o
 obj-$(CONFIG_MACB) += macb.o
 obj-$(CONFIG_S6GMAC) += s6gmac.o
 
+obj-$(CONFIG_XENON_ENET) += xenon_net.o
+
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
 obj-$(CONFIG_TR) += tokenring/
@@ -280,6 +282,7 @@ obj-$(CONFIG_NETCONSOLE) += netconsole.o
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
 obj-$(CONFIG_NETXEN_NIC) += netxen/
+
 obj-$(CONFIG_NIU) += niu.o
 obj-$(CONFIG_VIRTIO_NET) += virtio_net.o
 obj-$(CONFIG_SFC) += sfc/
diff -NurpP --minimal linux-2.6.33/drivers/net/xenon_net.c linux-2.6.33-xbox0.10/drivers/net/xenon_net.c
--- linux-2.6.33/drivers/net/xenon_net.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/net/xenon_net.c	2010-03-20 03:34:13.000000000 +0100
@@ -0,0 +1,695 @@
+/*
+ * xenon_net.c: Driver for Xenon Southbridge Fast Ethernet
+ *
+ * Copyright 2007 Felix Domke <tmbinc@elitedvb.net>
+ * Minor modification by: wolie <wolie@telia.com>
+ *
+ * Licensed under the GPL v2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/crc32.h>
+#include <asm/io.h>
+
+#define XENONNET_VERSION		"1.0.1"
+#define MODNAME			"xenon_net"
+#define XENONNET_DRIVER_LOAD_MSG	"Xenon Fast Ethernet driver " XENONNET_VERSION " loaded"
+#define PFX			MODNAME ": "
+
+#define RX_RING_SIZE 16
+#define TX_RING_SIZE 16
+
+#define TX_TIMEOUT    (6*HZ)
+
+static char version[] __devinitdata =
+KERN_INFO XENONNET_DRIVER_LOAD_MSG "\n"
+KERN_INFO "\n";
+
+static struct pci_device_id xenon_net_pci_tbl[] = {
+	{PCI_VENDOR_ID_MICROSOFT, 0x580a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE (pci, xenon_net_pci_tbl);
+
+/* Symbolic offsets to registers. */
+enum XENONNET_registers {
+	TX_CONFIG = 0x00,
+	TX_DESCRIPTOR_BASE = 0x04,
+	TX_DESCRIPTOR_STATUS = 0x0C,
+	RX_CONFIG = 0x10,
+	RX_DESCRIPTOR_BASE = 0x14,
+	INTERRUPT_STATUS = 0x20,
+	INTERRUPT_MASK = 0x24,
+	CONFIG_0 = 0x28,
+	POWER = 0x30,
+	PHY_CONFIG = 0x40,
+	PHY_CONTROL = 0x44,
+	CONFIG_1 = 0x50,
+	RETRY_COUNT = 0x54,
+	MULTICAST_FILTER_CONTROL = 0x60,
+	ADDRESS_0 = 0x62,
+	MULTICAST_HASH = 0x68,
+	MAX_PACKET_SIZE = 0x78,
+	ADDRESS_1 = 0x7A
+};
+
+struct xenon_net_private {
+	void *mmio_addr;
+
+	struct net_device *dev2;
+	struct napi_struct napi;
+
+	struct pci_dev *pdev;
+	struct net_device_stats stats;
+
+	/* we maintain a list of rx and tx descriptors */
+	void *tx_descriptor_base;
+	void *rx_descriptor_base;
+	dma_addr_t tx_descriptor_base_dma;
+	dma_addr_t rx_descriptor_base_dma;
+
+	struct sk_buff *rx_skbuff[RX_RING_SIZE];
+	dma_addr_t rx_skbuff_dma[RX_RING_SIZE];
+
+	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+	dma_addr_t tx_skbuff_dma[TX_RING_SIZE];
+
+	atomic_t tx_next_free, tx_next_done;
+
+	int rx_buf_sz, rx_next;
+
+	spinlock_t lock;
+};
+
+
+static void xenon_set_tx_descriptor (struct xenon_net_private *tp, int index, u32 len, dma_addr_t addr, int valid)
+{
+	volatile u32 *descr = tp->tx_descriptor_base + index * 0x10;
+	descr[0] = cpu_to_le32(len);
+	descr[2] = cpu_to_le32(addr);
+	descr[3] = cpu_to_le32(len | ((index == TX_RING_SIZE - 1) ? 0x80000000 : 0));
+	wmb();
+	if (valid)
+		descr[1] = cpu_to_le32(0xc0230000);
+	else
+		descr[1] = 0;
+}
+
+static void xenon_set_rx_descriptor (struct xenon_net_private *tp, int index, u32 len, dma_addr_t addr, int valid)
+{
+	volatile u32 *descr = tp->rx_descriptor_base + index * 0x10;
+	descr[0] = cpu_to_le32(0);
+	descr[2] = cpu_to_le32(addr);
+	descr[3] = cpu_to_le32(len | ((index == RX_RING_SIZE - 1) ? 0x80000000 : 0));
+	wmb();
+	if (valid)
+		descr[1] = cpu_to_le32(0xc0000000);
+	else
+		descr[1] = 0;
+}
+
+
+static void xenon_net_tx_interrupt (struct net_device *dev,
+				  struct xenon_net_private *tp,
+				  void *ioaddr)
+{
+	BUG_ON (dev == NULL);
+	BUG_ON (tp == NULL);
+	BUG_ON (ioaddr == NULL);
+
+	while (atomic_read(&tp->tx_next_free) != atomic_read(&tp->tx_next_done))
+	{
+		int e = atomic_read(&tp->tx_next_done) % TX_RING_SIZE;
+
+		volatile u32 *descr = tp->tx_descriptor_base + e * 0x10;
+		if (le32_to_cpu(descr[1]) & 0x80000000)
+			break;
+
+		if (!tp->tx_skbuff[e])
+		{
+			printk(KERN_WARNING "spurious TX complete?!\n");
+			break;
+		}
+
+		pci_unmap_single(tp->pdev, tp->tx_skbuff_dma[e], tp->tx_skbuff[e]->len, PCI_DMA_TODEVICE);
+		dev_kfree_skb_irq(tp->tx_skbuff[e]);
+
+		tp->tx_skbuff[e] = 0;
+		tp->tx_skbuff_dma[e] = 0;
+
+		atomic_inc(&tp->tx_next_done);
+	}
+
+	if ((atomic_read(&tp->tx_next_free) - atomic_read(&tp->tx_next_done)) < TX_RING_SIZE)
+		netif_start_queue (dev);
+}
+
+static int xenon_net_rx_interrupt (struct net_device *dev,
+				  struct xenon_net_private *tp, void *ioaddr)
+{
+	int received; //count and send to work_done
+
+	BUG_ON (dev == NULL);
+	BUG_ON (tp == NULL);
+	BUG_ON (ioaddr == NULL);
+
+	received = 0;
+
+	while (1)
+	{
+		int index = tp->rx_next;
+		volatile u32 *descr = tp->rx_descriptor_base + index * 0x10;
+		dma_addr_t mapping;
+		u32 size;
+		struct sk_buff *skb = tp->rx_skbuff[index], *new_skb;
+
+		if (le32_to_cpu(descr[1]) & 0x80000000)
+			break;
+		size = le32_to_cpu(descr[0]) & 0xFFFF;
+
+		mapping = tp->rx_skbuff_dma[index];
+
+		new_skb = dev_alloc_skb(tp->rx_buf_sz);
+		new_skb->dev = dev;
+
+		pci_unmap_single(tp->pdev, mapping, tp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+		skb->ip_summed = CHECKSUM_NONE;
+		skb_put(skb, size);
+		skb->protocol = eth_type_trans (skb, dev);
+		netif_receive_skb(skb);
+
+		received++;
+
+		dev->last_rx = jiffies;
+
+		mapping = tp->rx_skbuff_dma[index] = pci_map_single(tp->pdev,
+				new_skb->data, tp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+		tp->rx_skbuff[index] = new_skb;
+
+		xenon_set_rx_descriptor(tp, index, tp->rx_buf_sz, tp->rx_skbuff_dma[index], 1);
+
+		tp->rx_next = (tp->rx_next + 1) % RX_RING_SIZE;
+	}
+	writel(0x00101c11, ioaddr + RX_CONFIG);
+
+	return received;
+}
+
+static int xenon_net_poll(struct napi_struct *napi, int budget)
+{
+	int work_done;
+	struct xenon_net_private *tp = container_of(napi, struct xenon_net_private, napi);
+	struct net_device *dev = tp->dev2;
+
+	work_done = 0;
+
+	work_done += xenon_net_rx_interrupt(dev, tp, tp->mmio_addr);
+
+	if (work_done < budget) {
+		__napi_complete(napi);
+	}
+
+	return work_done;
+}
+
+
+
+static irqreturn_t xenon_net_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+	u32 status;
+
+	spin_lock (&tp->lock);
+
+	status = readl(ioaddr + INTERRUPT_STATUS);
+
+	if (status & 0x40)
+	{
+		if (napi_schedule_prep(&tp->napi)) {
+			status &= ~0x40;
+			__napi_schedule(&tp->napi);
+		}
+	}
+
+	if (status & 4)
+	{
+		xenon_net_tx_interrupt(dev, tp, ioaddr);
+		status &= ~0x4;
+	}
+
+//	if (status)
+//		printk(KERN_WARN "other interrupt: %08x\n", status);
+
+	spin_unlock (&tp->lock);
+
+	return IRQ_HANDLED;
+}
+
+
+
+/* Initialize the Rx and Tx rings, along with various 'dev' bits. */
+static void xenon_net_init_ring (struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	int i;
+
+	tp->rx_next = 0;
+	atomic_set (&tp->tx_next_done, 0);
+	atomic_set (&tp->tx_next_free, 0);
+
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		tp->tx_skbuff[i] = NULL;
+		tp->tx_skbuff_dma[i] = 0;
+	}
+
+			/* allocate descriptor memory */
+	tp->tx_descriptor_base = pci_alloc_consistent(tp->pdev,
+			TX_RING_SIZE * 0x10 + RX_RING_SIZE * 0x10,
+			&tp->tx_descriptor_base_dma);
+
+			/* rx is right after tx */
+	tp->rx_descriptor_base = tp->tx_descriptor_base + TX_RING_SIZE * 0x10;
+	tp->rx_descriptor_base_dma = tp->tx_descriptor_base_dma + TX_RING_SIZE * 0x10;
+
+	for (i = 0; i < TX_RING_SIZE; ++i)
+		xenon_set_tx_descriptor(tp, i, 0, 0, 0);
+
+	tp->rx_buf_sz = dev->mtu + 32;
+
+	for (i = 0; i < RX_RING_SIZE; ++i)
+	{
+		struct sk_buff *skb = dev_alloc_skb(tp->rx_buf_sz);
+		tp->rx_skbuff[i] = skb;
+		if (skb == NULL)
+			break;
+		skb->dev = dev;	/* Mark as being used by this device. */
+		tp->rx_skbuff_dma[i] = pci_map_single(tp->pdev, skb->data, tp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+
+		xenon_set_rx_descriptor(tp, i, tp->rx_buf_sz, tp->rx_skbuff_dma[i], 1);
+	}
+}
+
+/* Start the hardware at open or resume. */
+static void xenon_net_hw_start (struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+
+	/* Soft reset the chip. */
+	writel(0, ioaddr + INTERRUPT_MASK);
+	writel(0x08558001, ioaddr + CONFIG_0);
+	udelay (100);
+	writel(0x08550001, ioaddr + CONFIG_0);
+
+	writel(4, ioaddr + PHY_CONTROL);
+	udelay (100);
+	writel(0, ioaddr + PHY_CONTROL);
+
+	writew(1522, ioaddr + MAX_PACKET_SIZE);
+
+	writel(0x2360, ioaddr + CONFIG_1);
+
+	writew(0x0e38, ioaddr + MULTICAST_FILTER_CONTROL);
+
+	/* Restore our idea of the MAC address. */
+	writew(cpu_to_le16 (*(u16 *) (dev->dev_addr + 0)), ioaddr + ADDRESS_0);
+	writel(cpu_to_le32 (*(u32 *) (dev->dev_addr + 2)), ioaddr + ADDRESS_0 + 2);
+
+	writew(cpu_to_le16 (*(u16 *) (dev->dev_addr + 0)), ioaddr + ADDRESS_1);
+	writel(cpu_to_le32 (*(u32 *) (dev->dev_addr + 2)), ioaddr + ADDRESS_1 + 2);
+
+	writel(0, ioaddr + MULTICAST_HASH);
+	writel(0, ioaddr + MULTICAST_HASH + 4);
+
+	writel(0x00001c00, ioaddr + TX_CONFIG);
+	writel(0x00101c00, ioaddr + RX_CONFIG);
+
+	writel(0x04001901, ioaddr + PHY_CONFIG);
+
+	tp->rx_next = 0;
+
+		/* write base 0 */
+	writel(0x00001c00, ioaddr + TX_CONFIG);
+	writel(tp->tx_descriptor_base_dma, ioaddr + TX_DESCRIPTOR_BASE);
+
+		/* write base 1 */
+	writel(0x00011c00, ioaddr + TX_CONFIG);
+	writel(tp->tx_descriptor_base_dma, ioaddr + TX_DESCRIPTOR_BASE);
+	writel(0x00001c00, ioaddr + TX_CONFIG);
+
+	writel(tp->rx_descriptor_base_dma, ioaddr + RX_DESCRIPTOR_BASE);
+	writel(0x04001001, ioaddr + PHY_CONFIG);
+	writel(0, ioaddr + CONFIG_1);
+
+	writel(0x08550001, ioaddr + CONFIG_0);
+
+	writel(0x00001c01, ioaddr + TX_CONFIG); /* enable tx */
+	writel(0x00101c11, ioaddr + RX_CONFIG); /* enable rx */
+
+	writel(0x00010054, ioaddr + INTERRUPT_MASK);
+	writel(0x00010054, ioaddr + INTERRUPT_STATUS);
+
+	netif_start_queue (dev);
+}
+
+
+static int xenon_net_open (struct net_device *dev)
+{
+	int retval;
+
+	struct xenon_net_private *tp = netdev_priv(dev);
+	napi_enable(&tp->napi);
+
+	retval = request_irq (dev->irq, xenon_net_interrupt, IRQF_SHARED, dev->name, dev);
+	if (retval)
+		return retval;
+
+	xenon_net_init_ring (dev); /* allocates ringbuffer, clears them */
+	xenon_net_hw_start (dev);  /* start HW */
+
+	return 0;
+}
+
+static int xenon_net_start_xmit (struct sk_buff *skb, struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+	int entry;
+	dma_addr_t mapping;
+	u32 len;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->lock, flags);
+
+	/* Calculate the next Tx descriptor entry. */
+	entry = atomic_read (&tp->tx_next_free) % TX_RING_SIZE;
+
+	BUG_ON (tp->tx_skbuff[entry] != NULL);
+	BUG_ON (tp->tx_skbuff_dma[entry] != 0);
+	BUG_ON (skb_shinfo(skb)->nr_frags != 0);
+
+	tp->tx_skbuff[entry] = skb;
+
+	len = skb->len;
+
+	mapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);
+	tp->tx_skbuff_dma[entry] = mapping;
+
+	xenon_set_tx_descriptor(tp, entry, skb->len, mapping, 1);
+
+	dev->trans_start = jiffies;
+	atomic_inc (&tp->tx_next_free);
+	if ((atomic_read (&tp->tx_next_free) - atomic_read (&tp->tx_next_done)) >= TX_RING_SIZE)
+		netif_stop_queue (dev);
+
+	writel(0x00101c11, ioaddr + TX_CONFIG); /* enable TX */
+
+	spin_unlock_irqrestore(&tp->lock, flags);
+
+	return 0;
+}
+
+static void xenon_net_tx_clear (struct xenon_net_private *tp)
+{
+	int i;
+
+	atomic_set (&tp->tx_next_free, 0);
+	atomic_set (&tp->tx_next_done, 0);
+
+	/* Dump the unsent Tx packets. */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		if (tp->tx_skbuff_dma[i] != 0) {
+			pci_unmap_single (tp->pdev, tp->tx_skbuff_dma[i],
+					  tp->tx_skbuff[i]->len, PCI_DMA_TODEVICE);
+		}
+		if (tp->tx_skbuff[i])
+		{
+			dev_kfree_skb (tp->tx_skbuff[i]);
+			tp->tx_skbuff[i] = NULL;
+			tp->stats.tx_dropped++;
+		}
+	}
+}
+
+static void xenon_net_tx_timeout (struct net_device *dev)
+{
+	/* Error handling was taken from eexpress.c */
+	struct xenon_net_private *tp = netdev_priv(dev);
+	void *ioaddr = tp->mmio_addr;
+	unsigned long flags;
+
+	writel(0, ioaddr + INTERRUPT_MASK);
+
+	disable_irq(dev->irq);
+
+	printk(KERN_INFO "%s: transmit timed out, reseting.\n", dev->name);
+
+	/* Stop a shared interrupt from scavenging while we are. */
+	spin_lock_irqsave(&tp->lock, flags);
+	xenon_net_tx_clear(tp);
+	xenon_net_hw_start(dev);
+	spin_unlock_irqrestore(&tp->lock, flags);
+	enable_irq(dev->irq);
+
+	dev->trans_start = jiffies;
+	tp->stats.tx_errors++;
+	netif_wake_queue(dev);
+}
+
+static int xenon_net_close (struct net_device *dev)
+{
+	struct xenon_net_private *tp = netdev_priv(dev);
+	netif_stop_queue (dev);
+	napi_disable(&tp->napi);
+	free_irq (dev->irq, dev);
+	xenon_net_tx_clear (tp);
+	pci_free_consistent(tp->pdev, TX_RING_SIZE * 0x10 + RX_RING_SIZE * 0x10,
+			    tp->tx_descriptor_base, tp->tx_descriptor_base_dma);
+	tp->tx_descriptor_base = NULL;
+	tp->rx_descriptor_base = NULL;
+
+	return 0;
+}
+
+
+static struct net_device_ops xenon_netdev_ops = {
+	.ndo_open 		= xenon_net_open,
+	.ndo_stop 		= xenon_net_close,
+	.ndo_start_xmit 	= xenon_net_start_xmit,
+//	.ndo_set_multicast_list = xenon_net_set_multicast_list,
+	.ndo_tx_timeout 	= xenon_net_tx_timeout,
+//	.ndo_set_mac_address	= xenon_net_set_mac,
+//	.ndo_change_mtu 	= xenon_net_change_mtu,
+	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+static int __devinit xenon_net_init_board (struct pci_dev *pdev,
+					 struct net_device **dev_out,
+					 void **ioaddr_out)
+{
+	void *ioaddr = NULL;
+	struct net_device *dev;
+	struct xenon_net_private *tp;
+	int rc, i;
+	unsigned long mmio_start, mmio_end, mmio_flags, mmio_len;
+
+	BUG_ON (pdev == NULL);
+	BUG_ON (ioaddr_out == NULL);
+
+	*ioaddr_out = NULL;
+	*dev_out = NULL;
+
+	/* dev zeroed in alloc_etherdev */
+	dev = alloc_etherdev (sizeof (*tp));
+	if (dev == NULL) {
+		dev_err(&pdev->dev, "unable to alloc new ethernet\n");
+		return -ENOMEM;
+	}
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	tp = netdev_priv(dev);
+
+	/* enable device (incl. PCI PM wakeup), and bus-mastering */
+	rc = pci_enable_device (pdev);
+	if (rc)
+		goto err_out;
+
+	mmio_start = pci_resource_start (pdev, 0);
+	mmio_end = pci_resource_end (pdev, 0);
+	mmio_flags = pci_resource_flags (pdev, 0);
+	mmio_len = pci_resource_len (pdev, 0);
+
+	/* make sure PCI base addr 0 is MMIO */
+	if (!(mmio_flags & IORESOURCE_MEM)) {
+		dev_err(&pdev->dev, "region #0 not an MMIO resource, aborting\n");
+		rc = -ENODEV;
+		goto err_out;
+	}
+
+	rc = pci_request_regions (pdev, MODNAME);
+	if (rc)
+		goto err_out;
+
+	pci_set_master (pdev);
+
+	/* ioremap MMIO region */
+	ioaddr = ioremap (mmio_start, mmio_len);
+	if (ioaddr == NULL) {
+		dev_err(&pdev->dev, "cannot remap MMIO, aborting\n");
+		rc = -EIO;
+		goto err_out_free_res;
+	}
+
+	dev->netdev_ops = &xenon_netdev_ops;
+	i = register_netdev(dev);
+	if (i)
+		goto err_out_unmap;
+
+	*ioaddr_out = ioaddr;
+	*dev_out = dev;
+	return 0;
+
+err_out_unmap:
+#ifndef USE_IO_OPS
+	iounmap(ioaddr);
+err_out_free_res:
+#endif
+	pci_release_regions (pdev);
+err_out:
+	free_netdev (dev);
+	return rc;
+}
+static int __devinit xenon_net_init_one (struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct net_device *dev = NULL;
+	struct xenon_net_private *tp;
+	int i;
+	void *ioaddr = NULL;
+
+/* when built into the kernel, we only print version if device is found */
+#ifndef MODULE
+	static int printed_version;
+	if (!printed_version++)
+		printk(version);
+#endif
+
+	BUG_ON (pdev == NULL);
+	BUG_ON (ent == NULL);
+
+
+	i = xenon_net_init_board (pdev, &dev, &ioaddr);
+	if (i < 0)
+		return i;
+
+	tp = netdev_priv(dev);
+
+	BUG_ON (ioaddr == NULL);
+	BUG_ON (dev == NULL);
+	BUG_ON (tp == NULL);
+
+//	random_ether_addr(dev->dev_addr);
+//	memcpy(dev->dev_addr, "\x00\x78\x65\x6E\6F\6E", 6);
+	memcpy(dev->dev_addr, "\x00\x01\x30\x44\x55\x66", 6);   /* same as xell */
+
+	tp->dev2 = dev;
+//	dev->ethtool_ops = &xenon_net_ethtool_ops;
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	netif_napi_add(dev, &tp->napi, xenon_net_poll, 64);
+
+	dev->irq = pdev->irq;
+	dev->base_addr = (unsigned long) ioaddr;
+
+	/* priv/tp zeroed and aligned in alloc_etherdev */
+	tp = netdev_priv(dev);
+
+	tp->pdev = pdev;
+	tp->mmio_addr = ioaddr;
+	spin_lock_init(&tp->lock);
+
+	pci_set_drvdata(pdev, dev);
+
+	printk (KERN_INFO "%s: at 0x%lx, "
+		"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+		"IRQ %d\n",
+		dev->name,
+		dev->base_addr,
+		dev->dev_addr[0], dev->dev_addr[1],
+		dev->dev_addr[2], dev->dev_addr[3],
+		dev->dev_addr[4], dev->dev_addr[5],
+		dev->irq);
+
+	return 0;
+}
+
+
+static void __devexit xenon_net_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata (pdev);
+	struct xenon_net_private *np;
+
+	BUG_ON (dev == NULL);
+
+	np = netdev_priv(dev);
+	BUG_ON (np == NULL);
+
+	unregister_netdev (dev);
+
+#ifndef USE_IO_OPS
+	iounmap (np->mmio_addr);
+#endif /* !USE_IO_OPS */
+
+	pci_release_regions (pdev);
+
+	free_netdev (dev);
+
+	pci_set_drvdata (pdev, NULL);
+
+	pci_disable_device (pdev);
+}
+
+
+
+static struct pci_driver xenon_net_pci_driver = {
+	.name		= MODNAME,
+	.id_table	= xenon_net_pci_tbl,
+	.probe		= xenon_net_init_one,
+	.remove		= __devexit_p(xenon_net_remove_one),
+};
+
+static int __init xenon_net_init_module (void)
+{
+/* when a module, this is printed whether or not devices are found in probe */
+#ifdef MODULE
+	printk(version);
+#endif
+	return pci_register_driver(&xenon_net_pci_driver);
+}
+
+
+static void __exit xenon_net_cleanup_module (void)
+{
+	pci_unregister_driver (&xenon_net_pci_driver);
+}
+
+
+module_init(xenon_net_init_module);
+module_exit(xenon_net_cleanup_module);
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Felix Domke <tmbinc@elitedvb.net>")
+MODULE_DESCRIPTION("Xenon Southbridge Fast Ethernet Driver")
+
diff -NurpP --minimal linux-2.6.33/drivers/pci/probe.c linux-2.6.33-xbox0.10/drivers/pci/probe.c
--- linux-2.6.33/drivers/pci/probe.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/pci/probe.c	2010-03-30 02:33:04.000000000 +0200
@@ -737,6 +737,8 @@ int pci_setup_device(struct pci_dev *dev
 	struct pci_slot *slot;
 	int pos = 0;
 
+	printk("pci_setup_device() [%p,%u,%04x:%04x]\n",
+		dev->bus, dev->devfn, dev->vendor, dev->device);
 	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))
 		return -EIO;
 
@@ -964,6 +966,7 @@ static struct pci_dev *pci_scan_device(s
 	u32 l;
 	int delay = 1;
 
+	printk("pci_scan_device(%p,%u) bus->ops=%p\n", bus, devfn, bus ? bus->ops : 0);
 	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l))
 		return NULL;
 
diff -NurpP --minimal linux-2.6.33/drivers/rtc/Kconfig linux-2.6.33-xbox0.10/drivers/rtc/Kconfig
--- linux-2.6.33/drivers/rtc/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/rtc/Kconfig	2010-03-28 03:34:33.000000000 +0200
@@ -833,6 +833,16 @@ config RTC_DRV_PS3
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ps3.
 
+config RTC_DRV_XENON
+	tristate "Xenon RTC"
+	depends on PPC_XENON
+	help
+	  If you say yes here you will get support for the RTC on the
+	  Xbox 360.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-xenon.
+
 config RTC_DRV_COH901331
 	tristate "ST-Ericsson COH 901 331 RTC"
 	depends on ARCH_U300
diff -NurpP --minimal linux-2.6.33/drivers/rtc/Makefile linux-2.6.33-xbox0.10/drivers/rtc/Makefile
--- linux-2.6.33/drivers/rtc/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/rtc/Makefile	2010-03-28 03:32:53.000000000 +0200
@@ -90,3 +90,4 @@ obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_XENON)	+= rtc-xenon.o
diff -NurpP --minimal linux-2.6.33/drivers/rtc/rtc-xenon.c linux-2.6.33-xbox0.10/drivers/rtc/rtc-xenon.c
--- linux-2.6.33/drivers/rtc/rtc-xenon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/rtc/rtc-xenon.c	2010-03-28 04:23:48.000000000 +0200
@@ -0,0 +1,134 @@
+/*
+ *  Xenon RTC via SMC driver.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+
+
+#define DRV_NAME	"rtc-xenon"
+#define DRV_VERSION	"0.1"
+
+	/* for whatever reason, 15.Nov.2001 00:00 GMT */
+#define	RTC_BASE	1005782400UL
+
+
+int xenon_smc_message_wait(void *msg);
+
+static unsigned long xenon_get_rtc(void)
+{
+	unsigned char msg[16] = { 0x04 };
+	unsigned long msec;
+
+	xenon_smc_message_wait(msg);
+	msec = msg[1] | (msg[2] << 8) | (msg[3] << 16) |
+		(msg[4] << 24) | ((unsigned long)msg[5] << 32);
+	return RTC_BASE + msec/1000;
+}
+
+void xenon_smc_message(void *msg);
+
+static int xenon_set_rtc(unsigned long secs)
+{
+	unsigned long msec = (secs - RTC_BASE) * 1000;
+	unsigned char msg[16] = {
+		0x85, msec & 0xFF, (msec >> 8) & 0xFF,
+		(msec >> 16) & 0xFF, (msec >> 24) & 0xFF,
+		(msec >> 32) & 0xFF };
+
+	xenon_smc_message(msg);
+	return 0;
+}
+
+static int xenon_read_time(struct device *dev, struct rtc_time *tm)
+{
+	rtc_time_to_tm(xenon_get_rtc(), tm);
+	return 0;
+}
+
+
+static int xenon_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long msec;
+	int err;
+
+	err = rtc_tm_to_time(tm, &msec);
+	if (err)
+		return err;
+
+	return xenon_set_rtc(msec);
+}
+
+static const struct rtc_class_ops xenon_rtc_ops = {
+	.read_time	= xenon_read_time,
+	.set_time	= xenon_set_time,
+};
+
+static int __init xenon_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = rtc_device_register(DRV_NAME, &pdev->dev,
+				     &xenon_rtc_ops, THIS_MODULE);
+
+	printk("xenon_rtc_probe(%p) = %p\n", pdev, rtc);
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	platform_set_drvdata(pdev, rtc);
+	return 0;
+}
+
+static int __exit xenon_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(rtc);
+	return 0;
+}
+
+static struct platform_driver xenon_rtc_driver = {
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(xenon_rtc_remove),
+};
+
+static int __init xenon_rtc_init(void)
+{
+	int ret = platform_driver_probe(&xenon_rtc_driver, xenon_rtc_probe);
+
+	printk("xenon_rtc_init() = %d\n", ret);
+	return ret;
+	// return platform_driver_probe(&xenon_rtc_driver, xenon_rtc_probe);
+}
+
+static void __exit xenon_rtc_exit(void)
+{
+	platform_driver_unregister(&xenon_rtc_driver);
+}
+
+module_init(xenon_rtc_init);
+module_exit(xenon_rtc_exit);
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Xenon RTC driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+MODULE_ALIAS("platform:rtc-xenon");
diff -NurpP --minimal linux-2.6.33/drivers/scsi/scsi_scan.c linux-2.6.33-xbox0.10/drivers/scsi/scsi_scan.c
--- linux-2.6.33/drivers/scsi/scsi_scan.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/scsi/scsi_scan.c	2010-03-19 22:53:41.000000000 +0100
@@ -582,6 +582,7 @@ static int scsi_probe_lun(struct scsi_de
 		memset(scsi_cmd, 0, 6);
 		scsi_cmd[0] = INQUIRY;
 		scsi_cmd[4] = (unsigned char) try_inquiry_len;
+		scsi_cmd[5] = 0xc0; /* HACK */
 
 		memset(inq_result, 0, try_inquiry_len);
 
diff -NurpP --minimal linux-2.6.33/drivers/serial/Kconfig linux-2.6.33-xbox0.10/drivers/serial/Kconfig
--- linux-2.6.33/drivers/serial/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/serial/Kconfig	2010-03-21 04:04:28.000000000 +0100
@@ -1490,4 +1490,22 @@ config SERIAL_GRLIB_GAISLER_APBUART_CONS
 	help
 	Support for running a console on the GRLIB APBUART
 
+config SERIAL_XENON
+	tristate "Xenon XBOX 360 serial port support"
+	select SERIAL_CORE
+	help
+	  If you have an XBOX 360, you can enable its onboard
+	  serial port by enabling this options.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called xenon_uart.
+
+config SERIAL_XENON_CONSOLE
+	bool "Console on XBOX 360 serial port"
+	depends on SERIAL_XENON=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you have enabled the serial port on the XBOX 360
+	  you can make it the console by answering Y to this option.
+
 endmenu
diff -NurpP --minimal linux-2.6.33/drivers/serial/Makefile linux-2.6.33-xbox0.10/drivers/serial/Makefile
--- linux-2.6.33/drivers/serial/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/serial/Makefile	2010-03-21 04:02:23.000000000 +0100
@@ -82,3 +82,4 @@ obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgd
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
+obj-$(CONFIG_SERIAL_XENON) += xenon_uart.o
diff -NurpP --minimal linux-2.6.33/drivers/serial/serial_core.c linux-2.6.33-xbox0.10/drivers/serial/serial_core.c
--- linux-2.6.33/drivers/serial/serial_core.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/serial/serial_core.c	2010-03-21 04:31:43.000000000 +0100
@@ -2337,10 +2337,12 @@ int uart_register_driver(struct uart_dri
 	 * we have a large number of ports to handle.
 	 */
 	drv->state = kzalloc(sizeof(struct uart_state) * drv->nr, GFP_KERNEL);
+	printk(KERN_INFO "kzalloc() = %p\n", drv->state);
 	if (!drv->state)
 		goto out;
 
 	normal = alloc_tty_driver(drv->nr);
+	printk(KERN_INFO "alloc_tty_driver(%d) = %p\n", drv->nr, normal);
 	if (!normal)
 		goto out_kfree;
 
@@ -2375,6 +2377,7 @@ int uart_register_driver(struct uart_dri
 	}
 
 	retval = tty_register_driver(normal);
+	printk(KERN_INFO "tty_register_driver(%p) = %d\n", normal, retval);
 	if (retval >= 0)
 		return retval;
 
@@ -2382,6 +2385,7 @@ int uart_register_driver(struct uart_dri
 out_kfree:
 	kfree(drv->state);
 out:
+	printk(KERN_INFO "out nomem\n");
 	return -ENOMEM;
 }
 
diff -NurpP --minimal linux-2.6.33/drivers/serial/xenon_uart.c linux-2.6.33-xbox0.10/drivers/serial/xenon_uart.c
--- linux-2.6.33/drivers/serial/xenon_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/serial/xenon_uart.c	2010-03-22 00:20:13.000000000 +0100
@@ -0,0 +1,418 @@
+/* linux/drivers/serial/xenon.c
+ *
+ * Driver for Xenon XBOX 360 Serial
+ *
+ * Copyright (C) 2010 Herbert Poetzl
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/io.h>
+
+#if 0
+#define	dprintk(f, x...) do {				\
+		printk(KERN_DEBUG f "\n" , ##x);	\
+	} while (0)
+#else
+#define dprintk(f, x...) do { } while (0)
+#endif
+
+
+static int xenon_status(unsigned char __iomem *membase)
+{
+	// return ((*(volatile uint32_t*)0x80000200ea001018) & 0x02000000);
+	return (*(volatile uint32_t*)(membase + 0x08));
+}
+
+static void xenon_putch(unsigned char __iomem *membase, int ch)
+{
+	/* wait for tx fifo ready */
+	while (!(xenon_status(membase) & 0x02000000));
+
+	/* put character into fifo */
+	// *(volatile uint32_t*)0x80000200ea001014 = (ch << 24) & 0xFF000000;
+	*(volatile uint32_t*)(membase + 0x04) = (ch << 24) & 0xFF000000;
+}
+
+static int xenon_getch(unsigned char __iomem *membase)
+{
+	uint32_t status;
+
+	/* wait for data ready */
+	while ((status = xenon_status(membase)) & ~0x03000000);
+
+	if (status & 0x01000000)
+		return *(volatile uint32_t*)(membase + 0x00) >> 24;
+	return -1;
+}
+
+
+
+static void xenon_stop_rx(struct uart_port *port)
+{
+	dprintk("Xenon xenon_stop_rx()");
+}
+
+static void xenon_enable_ms(struct uart_port *port)
+{
+	dprintk("Xenon xenon_enable_ms()");
+}
+
+static void xenon_stop_tx(struct uart_port *port)
+{
+	dprintk("Xenon xenon_stop_tx()");
+}
+
+static void xenon_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	// int count;
+
+	if (port->x_char) {
+		xenon_putch(port->membase, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		xenon_stop_tx(port);
+		return;
+	}
+
+#if 0
+	count = port->fifosize >> 1;
+	do {
+		xenon_putch(port->membase, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+#else
+	while (!uart_circ_empty(xmit)) {
+		xenon_putch(port->membase, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+#endif
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		xenon_stop_tx(port);
+}
+
+static void xenon_start_tx(struct uart_port *port)
+{
+	dprintk("Xenon xenon_start_tx()");
+	xenon_tx_chars(port);
+}
+
+
+#if 0
+static void xenon_send_xchar(struct uart_port *port, char ch)
+{
+	dprintk("Xenon xenon_send_xchar(%d)", ch);
+	xenon_putch(port->membase, ch);
+}
+#endif
+
+static unsigned int xenon_tx_empty(struct uart_port *port)
+{
+	dprintk("Xenon xenon_tx_empty()");
+	return 0;
+}
+
+static unsigned int xenon_get_mctrl(struct uart_port *port)
+{
+	dprintk("Xenon xenon_get_mctrl()");
+	return 0;
+}
+
+static void xenon_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	dprintk("Xenon xenon_set_mctrl()");
+}
+
+static void xenon_break_ctl(struct uart_port *port, int break_state)
+{
+	dprintk("Xenon xenon_break_ctl()");
+}
+
+static void xenon_set_termios(struct uart_port *port,
+			     struct ktermios *new, struct ktermios *old)
+{
+	int baud, quot, cflag = new->c_cflag;
+
+	dprintk("Xenon xenon_set_termios()");
+	/* get the byte size */
+	switch (cflag & CSIZE) {
+	case CS5:
+		dprintk(" - data bits = 5");
+		break;
+	case CS6:
+		dprintk(" - data bits = 6");
+		break;
+	case CS7:
+		dprintk(" - data bits = 7");
+		break;
+	default: // CS8
+		dprintk(" - data bits = 8");
+		break;
+	}
+
+	/* determine the parity */
+	if (cflag & PARENB)
+		if (cflag & PARODD)
+			pr_debug(" - parity = odd\n");
+		else
+			pr_debug(" - parity = even\n");
+	else
+		pr_debug(" - parity = none\n");
+
+	/* figure out the stop bits requested */
+	if (cflag & CSTOPB)
+		pr_debug(" - stop bits = 2\n");
+	else
+		pr_debug(" - stop bits = 1\n");
+
+	/* figure out the flow control settings */
+	if (cflag & CRTSCTS)
+		pr_debug(" - RTS/CTS is enabled\n");
+	else
+		pr_debug(" - RTS/CTS is disabled\n");
+
+	/* Set baud rate */
+	baud = uart_get_baud_rate(port, new, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+}
+
+static int xenon_startup(struct uart_port *port)
+{
+	dprintk("Xenon xenon_startup()");
+	/* this is the first time this port is opened */
+	/* do any hardware initialization needed here */
+	return 0;
+}
+
+static void xenon_shutdown(struct uart_port *port)
+{
+	dprintk("Xenon xenon_shutdown()");
+	/* The port is being closed by the last user. */
+	/* Do any hardware specific stuff here */
+}
+
+static const char *xenon_type(struct uart_port *port)
+{
+	return "Xenon SMC";
+}
+
+static void xenon_release_port(struct uart_port *port)
+{
+	dprintk("Xenon xenon_release_port()");
+}
+
+static int xenon_request_port(struct uart_port *port)
+{
+	dprintk("Xenon xenon_request_port()");
+	return 0;
+}
+
+static void xenon_config_port(struct uart_port *port, int flags)
+{
+	dprintk("Xenon xenon_config_port()");
+
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_XENON;
+	}
+}
+
+static int xenon_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	dprintk("Xenon xenon_verify_port()");
+	return 0;
+}
+
+
+#ifdef CONFIG_CONSOLE_POLL
+
+static int xenon_poll_get_char(struct uart_port *port)
+{
+	return xenon_getch(port->membase);
+}
+
+static void xenon_poll_put_char(struct uart_port *port, unsigned char c)
+{
+	xenon_putch(port->membase, c);
+}
+
+#endif
+
+
+static struct uart_ops xenon_ops = {
+	.tx_empty	= xenon_tx_empty,
+	.set_mctrl	= xenon_set_mctrl,
+	.get_mctrl	= xenon_get_mctrl,
+	.stop_tx	= xenon_stop_tx,
+	.start_tx	= xenon_start_tx,
+//	.send_xchar	= xenon_send_xchar,
+	.stop_rx	= xenon_stop_rx,
+	.enable_ms	= xenon_enable_ms,
+	.break_ctl	= xenon_break_ctl,
+	.startup	= xenon_startup,
+	.shutdown	= xenon_shutdown,
+//	.flush_buffer	= xenon_flush_buffer,
+	.set_termios	= xenon_set_termios,
+//	.set_ldisc	= xenon_set_ldisc,
+//	.pm		= xenon_pm,
+//	.set_wake	= xenon_set_wake,
+	.type		= xenon_type,
+	.release_port	= xenon_release_port,
+	.request_port	= xenon_request_port,
+	.config_port	= xenon_config_port,
+	.verify_port	= xenon_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char	= xenon_poll_put_char,
+	.poll_get_char	= xenon_poll_get_char,
+#endif
+};
+
+static struct uart_port xenon_port = {
+	.type		= PORT_XENON,
+	.ops		= &xenon_ops,
+	.flags		= UPF_FIXED_TYPE | UPF_IOREMAP,
+	.mapbase	= 0x200ea001010ULL,
+	.iotype         = UPIO_MEM,
+	.uartclk	= 1843200,
+};
+
+static struct console xenon_console;
+
+static struct uart_driver xenon_reg = {
+	.owner  	= THIS_MODULE,
+	.driver_name	= "xenon_uart",
+	.dev_name	= "ttyS",
+	.major  	= TTY_MAJOR,
+	.minor  	= 64,
+	.nr		= 1,
+#ifdef	CONFIG_SERIAL_XENON_CONSOLE
+	.cons		= &xenon_console,
+#endif
+};
+
+
+static int __init xenon_init(void)
+{
+	int result;
+
+	printk(KERN_INFO "Xenon XBOX 360 serial driver\n");
+
+	result = uart_register_driver(&xenon_reg);
+	dprintk("Xenon uart_register_driver() = %d", result);
+	if (result)
+		return result;
+
+	xenon_port.membase = ioremap_nocache(xenon_port.mapbase, 0x10);
+
+	result = uart_add_one_port(&xenon_reg, &xenon_port);
+	dprintk("Xenon uart_add_one_port() = %d", result);
+	if (result)
+		uart_unregister_driver(&xenon_reg);
+
+	return result;
+}
+
+static void __exit xenon_exit(void)
+{
+	printk(KERN_INFO "Xenon XBOX 360 serial driver exit\n");
+	uart_remove_one_port(&xenon_reg, &xenon_port);
+	uart_unregister_driver(&xenon_reg);
+}
+
+module_init(xenon_init);
+module_exit(xenon_exit);
+
+
+#ifdef CONFIG_SERIAL_XENON_CONSOLE
+
+static void xenon_console_putchar(struct uart_port *port, int ch)
+{
+	xenon_putch(port->membase, ch);
+}
+
+/*
+ * Print a string to the serial port trying not to disturb
+ * any possible real use of the port...
+ */
+static void xenon_console_write(struct console *cons,
+	const char *s, unsigned int count)
+{
+	uart_console_write(&xenon_port, s, count, xenon_console_putchar);
+}
+
+/*
+ * Setup serial console baud/bits/parity.  We do two things here:
+ * - construct a cflag setting for the first uart_open()
+ * - initialise the serial port
+ * Return non-zero if we didn't find a serial port.
+ */
+static int __init xenon_console_setup(struct console *cons, char *options)
+{
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+#if 0
+	ret = xenon_map_port(uport);
+	if (ret)
+		return ret;
+
+	xenon_reset(port);
+	xenon_pm(port, 0, -1);
+#endif
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	return uart_set_options(&xenon_port, cons, baud, parity, bits, flow);
+}
+
+static struct console xenon_console = {
+	.name	= "ttyS",
+	.write	= xenon_console_write,
+	.device	= uart_console_device,
+	.setup	= xenon_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &xenon_reg,
+};
+
+static int __init xenon_serial_console_init(void)
+{
+	xenon_port.membase = ioremap_nocache(xenon_port.mapbase, 0x10);
+
+	register_console(&xenon_console);
+	return 0;
+}
+
+console_initcall(xenon_serial_console_init);
+
+#endif /* CONFIG_SERIAL_XENON_CONSOLE */
+
+
+MODULE_AUTHOR("Herbert Poetzl <herbert@13thfloor.at>");
+MODULE_DESCRIPTION("Xenon XBOX 360 Serial port driver");
+MODULE_LICENSE("GPL v2");
+// MODULE_ALIAS("platform:xenon-uart");
diff -NurpP --minimal linux-2.6.33/drivers/video/cfbimgblt.c linux-2.6.33-xbox0.10/drivers/video/cfbimgblt.c
--- linux-2.6.33/drivers/video/cfbimgblt.c	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/video/cfbimgblt.c	2010-03-20 00:08:41.000000000 +0100
@@ -69,9 +69,17 @@ static const u32 cfb_tab32[] = {
 	0x00000000, 0xffffffff
 };
 
+#if 0
 #define FB_WRITEL fb_writel
 #define FB_READL  fb_readl
 
+#define FB_WRITEL(p,b,addr) fb_writel(b,addr)
+#define FB_READL(p,addr)  fb_readl(addr)
+#else
+#define FB_READL(p,addr)  fb_readl(xenon_convert(p, addr))
+#define FB_WRITEL(p,b,addr) fb_writel(b, xenon_convert(p, addr))
+#endif
+
 static inline void color_imageblit(const struct fb_image *image, 
 				   struct fb_info *p, u8 __iomem *dst1, 
 				   u32 start_index,
@@ -96,7 +104,7 @@ static inline void color_imageblit(const
 		if (start_index) {
 			u32 start_mask = ~fb_shifted_pixels_mask_u32(p,
 						start_index, bswapmask);
-			val = FB_READL(dst) & start_mask;
+			val = FB_READL(p, dst) & start_mask;
 			shift = start_index;
 		}
 		while (n--) {
@@ -108,7 +116,7 @@ static inline void color_imageblit(const
 			color <<= FB_LEFT_POS(p, bpp);
 			val |= FB_SHIFT_HIGH(p, color, shift ^ bswapmask);
 			if (shift >= null_bits) {
-				FB_WRITEL(val, dst++);
+				FB_WRITEL(p, val, dst++);
 	
 				val = (shift == null_bits) ? 0 : 
 					FB_SHIFT_LOW(p, color, 32 - shift);
@@ -121,7 +129,7 @@ static inline void color_imageblit(const
 			u32 end_mask = fb_shifted_pixels_mask_u32(p, shift,
 						bswapmask);
 
-			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
+			FB_WRITEL(p, (FB_READL(p, dst) & end_mask) | val, dst);
 		}
 		dst1 += p->fix.line_length;
 		if (pitch_index) {
@@ -164,7 +172,7 @@ static inline void slow_imageblit(const 
 		if (start_index) {
 			u32 start_mask = ~fb_shifted_pixels_mask_u32(p,
 						start_index, bswapmask);
-			val = FB_READL(dst) & start_mask;
+			val = FB_READL(p, dst) & start_mask;
 			shift = start_index;
 		}
 
@@ -175,7 +183,7 @@ static inline void slow_imageblit(const 
 			
 			/* Did the bitshift spill bits to the next long? */
 			if (shift >= null_bits) {
-				FB_WRITEL(val, dst++);
+				FB_WRITEL(p, val, dst++);
 				val = (shift == null_bits) ? 0 :
 					FB_SHIFT_LOW(p, color, 32 - shift);
 			}
@@ -189,7 +197,7 @@ static inline void slow_imageblit(const 
 			u32 end_mask = fb_shifted_pixels_mask_u32(p, shift,
 						bswapmask);
 
-			FB_WRITEL((FB_READL(dst) & end_mask) | val, dst);
+			FB_WRITEL(p, (FB_READL(p, dst) & end_mask) | val, dst);
 		}
 		
 		dst1 += pitch;
@@ -254,7 +262,7 @@ static inline void fast_imageblit(const 
 		for (j = k; j--; ) {
 			shift -= ppw;
 			end_mask = tab[(*src >> shift) & bit_mask];
-			FB_WRITEL((end_mask & eorx)^bgx, dst++);
+			FB_WRITEL(p, (end_mask & eorx)^bgx, dst++);
 			if (!shift) { shift = 8; src++; }		
 		}
 		dst1 += p->fix.line_length;
diff -NurpP --minimal linux-2.6.33/drivers/video/Kconfig linux-2.6.33-xbox0.10/drivers/video/Kconfig
--- linux-2.6.33/drivers/video/Kconfig	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/video/Kconfig	2010-03-19 22:53:41.000000000 +0100
@@ -742,6 +742,15 @@ config FB_N411
          This enables support for the Apollo display controller in its
          Hecuba form using the n411 devkit.
 
+config FB_XENON
+	bool "Xbox 360 Framebuffer Support"
+	depends on (FB = y) && PPC
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the Microsoft Xbox 360.
+
 config FB_HGA
 	tristate "Hercules mono graphics support"
 	depends on FB && X86
diff -NurpP --minimal linux-2.6.33/drivers/video/Makefile linux-2.6.33-xbox0.10/drivers/video/Makefile
--- linux-2.6.33/drivers/video/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/video/Makefile	2010-03-19 22:53:41.000000000 +0100
@@ -134,6 +134,7 @@ obj-$(CONFIG_FB_MSM)              += msm
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
 obj-$(CONFIG_FB_VESA)             += vesafb.o
 obj-$(CONFIG_FB_EFI)              += efifb.o
+obj-$(CONFIG_FB_XENON)            += xenonfb.o
 obj-$(CONFIG_FB_VGA16)            += vga16fb.o
 obj-$(CONFIG_FB_OF)               += offb.o
 obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-lq043fb.o
diff -NurpP --minimal linux-2.6.33/drivers/video/xenonfb.c linux-2.6.33-xbox0.10/drivers/video/xenonfb.c
--- linux-2.6.33/drivers/video/xenonfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/video/xenonfb.c	2010-03-20 01:38:01.000000000 +0100
@@ -0,0 +1,379 @@
+/*
+ * framebuffer driver for Microsoft Xbox 360
+ *
+ * (c) 2006 ...
+ * Original vesafb driver written by Gerd Knorr <kraxel@goldbach.in-berlin.de>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/screen_info.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/dmi.h>
+
+#include <asm/io.h>
+
+#include <video/vga.h>
+
+/* --------------------------------------------------------------------- */
+
+static struct fb_var_screeninfo xenonfb_defined __initdata = {
+	.activate		= FB_ACTIVATE_NOW,
+	.height			= -1,
+	.width			= -1,
+	.right_margin		= 32,
+	.upper_margin		= 16,
+	.lower_margin		= 4,
+	.vsync_len		= 4,
+	.vmode			= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo xenonfb_fix __initdata = {
+	.id			= "XENON FB",
+	.type			= FB_TYPE_PACKED_PIXELS,
+	.accel			= FB_ACCEL_NONE,
+	.visual			= FB_VISUAL_TRUECOLOR,
+};
+
+typedef struct {
+	uint32_t unknown1[4];
+	uint32_t base;
+	uint32_t unknown2[8];
+	uint32_t width;
+	uint32_t height;
+} ati_info;
+
+#define	DEFAULT_FB_MEM	1024*1024*16
+
+/* --------------------------------------------------------------------- */
+
+static int xenonfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			    unsigned blue, unsigned transp,
+			    struct fb_info *info)
+{
+	/*
+	 *  Set a single color register. The values supplied are
+	 *  already rounded down to the hardware's capabilities
+	 *  (according to the entries in the `var' structure). Return
+	 *  != 0 for invalid regno.
+	 */
+
+	if (regno >= info->cmap.len)
+		return 1;
+
+	if (regno < 16) {
+		red   >>= 8;
+		green >>= 8;
+		blue  >>= 8;
+		((u32 *)(info->pseudo_palette))[regno] =
+			(red   << info->var.red.offset)   |
+			(green << info->var.green.offset) |
+			(blue  << info->var.blue.offset);
+	}
+	return 0;
+}
+
+#define XENON_XY_TO_STD_PTR(x,y) ((int*)(((char*)p->screen_base)+y*p->fix.line_length+x*(p->var.bits_per_pixel/8)))
+#define XENON_XY_TO_XENON_PTR(x,y) xenon_convert(p, XENON_XY_TO_STD_PTR(x,y))
+
+inline void xenon_pset(struct fb_info *p, int x, int y, int color)
+{
+	fb_writel(color, XENON_XY_TO_XENON_PTR(x,y));
+}
+
+inline int xenon_pget(struct fb_info *p, int x, int y)
+{
+	return fb_readl(XENON_XY_TO_XENON_PTR(x,y));
+}
+
+void xenon_fillrect(struct fb_info *p, const struct fb_fillrect *rect)
+{
+
+	__u32 x, y;
+	for (y=0; y<rect->height; y++) {
+		for (x=0; x<rect->width; x++) {
+			xenon_pset(p, rect->dx+x, rect->dy+y, rect->color);
+
+		}
+	}
+}
+
+void xenon_copyarea(struct fb_info *p, const struct fb_copyarea *area)
+{
+
+	/* if the beginning of the target area might overlap with the end of
+	the source area, be have to copy the area reverse. */
+	if ((area->dy == area->sy && area->dx > area->sx) || (area->dy > area->sy)) {
+		__s32 x, y;
+		for (y=area->height-1; y>0; y--) {
+			for (x=area->width-1; x>0; x--) {
+				xenon_pset(p, area->dx+x, area->dy+y, xenon_pget(p, area->sx+x, area->sy+y));
+			}
+		}
+	} else {
+		__u32 x, y;
+		for (y=0; y<area->height; y++) {
+			for (x=0; x<area->width; x++) {
+				xenon_pset(p, area->dx+x, area->dy+y, xenon_pget(p, area->sx+x, area->sy+y));
+			}
+		}
+	}
+}
+
+static struct fb_ops xenonfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= xenonfb_setcolreg,
+	.fb_fillrect	= xenon_fillrect,
+	.fb_copyarea	= xenon_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+static int __init xenonfb_probe(struct platform_device *dev)
+{
+	struct fb_info *info;
+	int err;
+	unsigned int size_vmode;
+	unsigned int size_remap;
+	unsigned int size_total;
+
+	volatile int *gfx = ioremap(0x200ec806000ULL, 0x1000);
+
+	volatile ati_info *ai = ((void*)gfx) + 0x100;
+
+			/* setup native resolution, i.e. disable scaling */
+	int vxres = gfx[0x134/4];
+	int vyres = gfx[0x138/4];
+
+	int black_top = gfx[0x44/4];
+	int offset = gfx[0x580/4];
+	int offset_x = (offset >> 16) & 0xFFFF;
+	int offset_y = offset & 0xFFFF;
+
+	int nxres, nyres;
+	int scl_h = gfx[0x5b4/4], scl_v = gfx[0x5c4/4];
+
+	if (gfx[0x590/4] == 0)
+		scl_h = scl_v = 0x01000000;
+
+	nxres = (vxres - offset_x * 2) * 0x1000 / (scl_h/0x1000);
+	nyres = (vyres - offset_y * 2) * 0x1000 / (scl_v/0x1000) + black_top * 2;
+
+
+	printk("virtual resolution: %d x %d\n", vxres, vyres);
+	printk("offset: x=%d, y=%d\n", offset_x, offset_y);
+	printk("black: %d %d, %d %d\n",
+		gfx[0x44/4], gfx[0x48/4], gfx[0x4c/4], gfx[0x50/4]);
+
+	printk("native resolution: %d x %d\n", nxres, nyres);
+
+	screen_info.lfb_depth = 32;
+	screen_info.lfb_size = DEFAULT_FB_MEM / 0x10000;
+	screen_info.pages=1;
+	screen_info.blue_size = 8;
+	screen_info.blue_pos = 24;
+	screen_info.green_size = 8;
+	screen_info.green_pos = 16;
+	screen_info.red_size = 8;
+	screen_info.red_pos = 8;
+	screen_info.rsvd_size = 8;
+	screen_info.rsvd_pos = 0;
+
+	gfx[0x44/4] = 0; // disable black bar
+	gfx[0x48/4] = 0;
+	gfx[0x4c/4] = 0;
+	gfx[0x50/4] = 0;
+
+	gfx[0x590/4] = 0; // disable scaling
+	gfx[0x584/4] = (nxres << 16) | nyres;
+	gfx[0x580/4] = 0; // disable offset
+	gfx[0x5e8/4] = (nxres * 4) / 0x10 - 1; // fix pitch
+	gfx[0x134/4] = nxres;
+	gfx[0x138/4] = nyres;
+
+	ai->base &= ~0xFFFF; // page-align.
+
+	screen_info.lfb_base = ai->base;
+	screen_info.lfb_width = ai->width;
+	screen_info.lfb_height = ai->height;
+	screen_info.lfb_linelength = screen_info.lfb_width * screen_info.lfb_depth/4;
+
+	gfx[0x120/4] = screen_info.lfb_linelength / 8; /* fixup pitch, in case we switched resolution */
+
+	printk(KERN_INFO "xenonfb: detected %dx%d framebuffer @ 0x%08x\n", screen_info.lfb_width, screen_info.lfb_height, screen_info.lfb_base);
+
+	iounmap(gfx);
+
+	xenonfb_fix.smem_start = screen_info.lfb_base;
+	xenonfb_defined.bits_per_pixel = screen_info.lfb_depth;
+	xenonfb_defined.xres = screen_info.lfb_width;
+	xenonfb_defined.yres = screen_info.lfb_height;
+	xenonfb_defined.xoffset = 0;
+	xenonfb_defined.yoffset = 0;
+	xenonfb_fix.line_length = screen_info.lfb_linelength;
+
+	/*   size_vmode -- that is the amount of memory needed for the
+	 *                 used video mode, i.e. the minimum amount of
+	 *                 memory we need. */
+	size_vmode = xenonfb_defined.yres * xenonfb_fix.line_length;
+
+	/*   size_total -- all video memory we have. Used for
+	 *                 entries, ressource allocation and bounds
+	 *                 checking. */
+	size_total = screen_info.lfb_size * 65536;
+	if (size_total < size_vmode)
+		size_total = size_vmode;
+
+	/*   size_remap -- the amount of video memory we are going to
+	 *                 use for xenonfb.  With modern cards it is no
+	 *                 option to simply use size_total as that
+	 *                 wastes plenty of kernel address space. */
+	size_remap  = size_vmode * 2;
+	if (size_remap < size_vmode)
+		size_remap = size_vmode;
+	if (size_remap > size_total)
+		size_remap = size_total;
+	xenonfb_fix.smem_len = size_remap;
+
+	if (!request_mem_region(xenonfb_fix.smem_start, size_total, "xenonfb")) {
+		printk(KERN_WARNING
+		       "xenonfb: cannot reserve video memory at 0x%lx\n",
+			xenonfb_fix.smem_start);
+		/* We cannot make this fatal. Sometimes this comes from magic
+		   spaces our resource handlers simply don't know about */
+	}
+
+	info = framebuffer_alloc(sizeof(u32) * 16, &dev->dev);
+	if (!info) {
+		err = -ENOMEM;
+		goto err_release_mem;
+	}
+	info->pseudo_palette = info->par;
+	info->par = NULL;
+
+	info->screen_base = ioremap(xenonfb_fix.smem_start, xenonfb_fix.smem_len);
+	if (!info->screen_base) {
+		printk(KERN_ERR "xenonfb: abort, cannot ioremap video memory "
+				"0x%x @ 0x%lx\n",
+			xenonfb_fix.smem_len, xenonfb_fix.smem_start);
+		err = -EIO;
+		goto err_unmap;
+	}
+
+	printk(KERN_INFO "xenonfb: framebuffer at 0x%lx, mapped to 0x%p, "
+	       "using %dk, total %dk\n",
+	       xenonfb_fix.smem_start, info->screen_base,
+	       size_remap/1024, size_total/1024);
+	printk(KERN_INFO "xenonfb: mode is %dx%dx%d, linelength=%d, pages=%d\n",
+	       xenonfb_defined.xres, xenonfb_defined.yres,
+	       xenonfb_defined.bits_per_pixel, xenonfb_fix.line_length,
+	       screen_info.pages);
+
+	xenonfb_defined.xres_virtual = xenonfb_defined.xres;
+	xenonfb_defined.yres_virtual = xenonfb_fix.smem_len /
+					xenonfb_fix.line_length;
+	printk(KERN_INFO "xenonfb: scrolling: redraw\n");
+	xenonfb_defined.yres_virtual = xenonfb_defined.yres;
+
+	/* some dummy values for timing to make fbset happy */
+	xenonfb_defined.pixclock     = 10000000 / xenonfb_defined.xres *
+					1000 / xenonfb_defined.yres;
+	xenonfb_defined.left_margin  = (xenonfb_defined.xres / 8) & 0xf8;
+	xenonfb_defined.hsync_len    = (xenonfb_defined.xres / 8) & 0xf8;
+
+	printk(KERN_INFO "xenonfb: pixclk=%lld left=%02x hsync=%02x\n",
+		xenonfb_defined.pixclock,
+		xenonfb_defined.left_margin,
+		xenonfb_defined.hsync_len);
+
+	xenonfb_defined.red.offset    = screen_info.red_pos;
+	xenonfb_defined.red.length    = screen_info.red_size;
+	xenonfb_defined.green.offset  = screen_info.green_pos;
+	xenonfb_defined.green.length  = screen_info.green_size;
+	xenonfb_defined.blue.offset   = screen_info.blue_pos;
+	xenonfb_defined.blue.length   = screen_info.blue_size;
+	xenonfb_defined.transp.offset = screen_info.rsvd_pos;
+	xenonfb_defined.transp.length = screen_info.rsvd_size;
+
+	printk(KERN_INFO "xenonfb: %s: "
+	       "size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",
+	       "Truecolor",
+	       screen_info.rsvd_size,
+	       screen_info.red_size,
+	       screen_info.green_size,
+	       screen_info.blue_size,
+	       screen_info.rsvd_pos,
+	       screen_info.red_pos,
+	       screen_info.green_pos,
+	       screen_info.blue_pos);
+
+	xenonfb_fix.ypanstep  = 0;
+	xenonfb_fix.ywrapstep = 0;
+
+	/* request failure does not faze us, as vgacon probably has this
+	 * region already (FIXME) */
+	request_region(0x3c0, 32, "xenonfb");
+
+	info->fbops = &xenonfb_ops;
+	info->var = xenonfb_defined;
+	info->fix = xenonfb_fix;
+	info->flags = FBINFO_FLAG_DEFAULT;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		err = -ENOMEM;
+		goto err_unmap;
+	}
+	if (register_framebuffer(info)<0) {
+		err = -EINVAL;
+		goto err_fb_dealoc;
+	}
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+	       info->node, info->fix.id);
+	return 0;
+
+err_fb_dealoc:
+	fb_dealloc_cmap(&info->cmap);
+err_unmap:
+	iounmap(info->screen_base);
+	framebuffer_release(info);
+err_release_mem:
+	release_mem_region(xenonfb_fix.smem_start, size_total);
+	return err;
+}
+
+static struct platform_driver xenonfb_driver = {
+	.probe	= xenonfb_probe,
+	.driver	= {
+		.name	= "xenonfb",
+	},
+};
+
+static struct platform_device xenonfb_device = {
+	.name	= "xenonfb",
+};
+
+static int __init xenonfb_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&xenonfb_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&xenonfb_device);
+		if (ret)
+			platform_driver_unregister(&xenonfb_driver);
+	}
+	return ret;
+}
+module_init(xenonfb_init);
+
+MODULE_LICENSE("GPL");
+
diff -NurpP --minimal linux-2.6.33/drivers/xenon/Makefile linux-2.6.33-xbox0.10/drivers/xenon/Makefile
--- linux-2.6.33/drivers/xenon/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/xenon/Makefile	2010-03-25 06:31:31.000000000 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_PPC_XENON) += smc-core.o
diff -NurpP --minimal linux-2.6.33/drivers/xenon/smc-core.c linux-2.6.33-xbox0.10/drivers/xenon/smc-core.c
--- linux-2.6.33/drivers/xenon/smc-core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/drivers/xenon/smc-core.c	2010-03-30 00:17:31.000000000 +0200
@@ -0,0 +1,330 @@
+/*
+ *  Xenon SMC core.
+ *
+ *  Copyright (C) 2010 Herbert Poetzl
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+
+#define DRV_NAME	"xenon_smc_core"
+#define DRV_VERSION	"0.1"
+
+struct xenon_smc
+{
+	void __iomem *base;
+	wait_queue_head_t wait_q;
+	spinlock_t fifo_lock;
+
+	void (*send)(void *msg);
+	void (*wait)(void *msg);
+	int (*reply)(void *msg);
+	int (*cached)(void *msg);
+
+	unsigned char cmd;
+};
+
+static struct xenon_smc smc;
+
+static unsigned char smc_reply[][16] = {
+	{ 0x01 },	/* power on type */
+	{ 0x04 },	/* rtc */
+	{ 0x07 },	/* temp */
+	{ 0x0a },	/* tray state */
+	{ 0x0f },	/* av pack */
+	{ 0x11 },	/* (h)ana */
+	{ 0x12 },	/* smc version */
+	{ 0x13 },	/* echo back */
+	{ 0x16 },	/* IR address */
+	{ 0x17 },	/* tilt state */
+	{ 0x1e },	/* 12b @83h */
+	{ 0x20 },	/* 12b @8fh */
+	{ 0x83 },	/* smc event */
+};
+
+
+static void _xenon_smc_send(void *msg)
+{
+	unsigned long flags;
+
+	print_hex_dump(KERN_DEBUG, "_xenon_smc_send: ",
+		DUMP_PREFIX_NONE, 16, 2, msg, 16, 0);
+
+	spin_lock_irqsave(&smc.fifo_lock, flags);
+	while (!(readl(smc.base + 0x84) & 4))
+		cpu_relax();
+
+	writel(4, smc.base + 0x84);
+	writesl(smc.base + 0x80, msg, 4);
+	writel(0, smc.base + 0x84);
+	spin_unlock_irqrestore(&smc.fifo_lock, flags);
+}
+
+static void _xenon_smc_wait(void *msg)
+{
+	/* do we expect a reply? */
+	if (*(unsigned char *)msg & 0x80)
+		return;
+
+#if 0
+	/* wait for reply, maybe a timeout? */
+	while (!(readl(smc.base + 0x94) & 4))
+		cpu_relax();
+#else
+	wait_event_interruptible(smc.wait_q,
+		smc.cmd == *(unsigned char *)msg);
+#endif
+}
+
+
+static int _xenon_smc_reply(void *msg)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&smc.fifo_lock, flags);
+	if (readl(smc.base + 0x94) & 4) {
+		writel(4, smc.base + 0x94);
+		readsl(smc.base + 0x90, msg, 4);
+		writel(0, smc.base + 0x94);
+		ret = 1;
+	} else {
+		memset(msg, 0, 16);
+	}
+	spin_unlock_irqrestore(&smc.fifo_lock, flags);
+	return ret;
+}
+
+static unsigned char * _xenon_smc_cache_lookup(unsigned char *msg) {
+	unsigned char *ptr = smc_reply[0];
+
+	while (ptr[0]) {
+		if (msg[0] == ptr[0])
+			return ptr;
+		ptr += 16;
+	}
+	return NULL;
+}
+
+static int _xenon_smc_cached_reply(void *msg)
+{
+	unsigned char *ptr = _xenon_smc_cache_lookup(msg);
+
+	if (ptr)
+		memcpy(msg + 1, ptr + 1, 15);
+	return (ptr != NULL);
+}
+
+
+static int _xenon_smc_cache(unsigned char *msg) {
+	unsigned char *ptr = _xenon_smc_cache_lookup(msg);
+
+	if (ptr)
+		memcpy(ptr + 1, msg + 1, 15);
+	else
+		printk("unknown smc reply %02x", msg[0]);
+
+	print_hex_dump(KERN_DEBUG, "_xenon_smc_cache: ",
+		DUMP_PREFIX_NONE, 16, 2, msg, 16, 0);
+	smc.cmd = msg[0];
+}
+
+
+int	xenon_smc_message(void *msg)
+{
+	int ret = 0;
+
+	if (smc.send)
+		smc.send(msg);
+
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(xenon_smc_message);
+
+int	xenon_smc_message_wait(void *msg)
+{
+	int ret = 0;
+
+	smc.cmd = 0;
+	if (smc.send)
+		smc.send(msg);
+	if (smc.wait)
+		smc.wait(msg);
+#if 0
+	if (smc.reply)
+		ret = smc.reply(msg);
+#else
+	if (smc.cached)
+		ret = smc.cached(msg);
+#endif
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(xenon_smc_message_wait);
+
+
+static void show_logo(void)
+{
+	unsigned char msg[16] = {0x99, 0x01, 0x63, 0};
+
+	xenon_smc_message(msg);
+}
+
+void xenon_smc_restart(char *cmd)
+{
+	unsigned char msg[16] = {0x82, 0x04, 0x30, 0};
+
+	xenon_smc_message(msg);
+}
+
+void xenon_smc_power_off(void)
+{
+	unsigned char msg[16] = {0x82, 0x01, 0x00, 0};
+
+	xenon_smc_message(msg);
+}
+
+void xenon_smc_halt(void)
+{
+	return;
+}
+
+static const struct pci_device_id xenon_smc_pci_tbl[] = {
+	{ PCI_VDEVICE(MICROSOFT, 0x580d), 0 },
+	{ }	/* terminate list */
+};
+
+static irqreturn_t xenon_smc_irq(int irq, void *dev_id)
+{
+	static unsigned char msg[16];
+	// struct pci_dev *pdev = dev_id;
+
+	unsigned int irqs = readl(smc.base + 0x50);
+
+	printk(KERN_DEBUG "xenon_smc_irq() = %08x,%08x\n",
+		irqs, readl(smc.base + 0x94));
+
+	if (irqs & 0x10000000) {
+		if (_xenon_smc_reply(msg)) {
+			_xenon_smc_cache(msg);
+			wake_up(&smc.wait_q);
+		}
+	}
+
+	writel(irqs, smc.base + 0x58);	// ack irq
+	return IRQ_HANDLED;
+}
+
+static int xenon_smc_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	// static int printed_version;
+	int rc;
+	int pci_dev_busy = 0;
+	unsigned long mmio_start;
+
+	dev_printk(KERN_INFO, &pdev->dev, "version " DRV_VERSION "\n");
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc) {
+		pci_dev_busy = 1;
+		goto err_out;
+	}
+
+	pci_intx(pdev, 1);
+
+	printk(KERN_INFO "attached to xenon SMC\n");
+
+	mmio_start = pci_resource_start(pdev, 0);
+	smc.base = ioremap(mmio_start, 0x100);
+	if (!smc.base)
+		goto err_out_regions;
+
+	init_waitqueue_head(&smc.wait_q);
+	spin_lock_init(&smc.fifo_lock);
+
+	if (request_irq(pdev->irq, xenon_smc_irq, IRQF_SHARED,
+		"xenon-smc", pdev)) {
+		printk(KERN_ERR "xenon-smc: request_irq failed\n");
+		goto err_out_ioremap;
+	}
+
+	smc.send = _xenon_smc_send;
+	smc.wait = _xenon_smc_wait;
+	smc.reply = _xenon_smc_reply;
+	smc.cached = _xenon_smc_cached_reply;
+
+	show_logo();
+	return 0;
+
+err_out_ioremap:
+	iounmap(smc.base);
+
+err_out_regions:
+	pci_release_regions(pdev);
+
+err_out:
+	if (!pci_dev_busy)
+		pci_disable_device(pdev);
+	return rc;
+}
+
+static void __devexit xenon_smc_remove(struct pci_dev *pdev)
+{
+	smc.send = NULL;
+	smc.reply = NULL;
+
+	iounmap(smc.base);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver xenon_smc_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= xenon_smc_pci_tbl,
+	.probe			= xenon_smc_init_one,
+	.remove     = __devexit_p(xenon_smc_remove)
+};
+
+
+static int __init xenon_smc_init(void)
+{
+	return pci_register_driver(&xenon_smc_pci_driver);
+}
+
+static void __exit xenon_smc_exit(void)
+{
+	pci_unregister_driver(&xenon_smc_pci_driver);
+}
+
+module_init(xenon_smc_init);
+module_exit(xenon_smc_exit);
+
+
+MODULE_DESCRIPTION("Driver for Xenon Southbridge SMC");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+MODULE_DEVICE_TABLE(pci, xenon_smc_pci_tbl);
+
diff -NurpP --minimal linux-2.6.33/fs/nfs/nfsroot.c linux-2.6.33-xbox0.10/fs/nfs/nfsroot.c
--- linux-2.6.33/fs/nfs/nfsroot.c	2010-03-21 15:30:39.000000000 +0100
+++ linux-2.6.33-xbox0.10/fs/nfs/nfsroot.c	2010-03-20 00:00:30.000000000 +0100
@@ -132,7 +132,7 @@ enum {
 	Opt_err
 };
 
-static const match_table_t tokens __initconst = {
+static const match_table_t tokens = {
 	{Opt_port, "port=%u"},
 	{Opt_rsize, "rsize=%u"},
 	{Opt_wsize, "wsize=%u"},
diff -NurpP --minimal linux-2.6.33/include/linux/fb.h linux-2.6.33-xbox0.10/include/linux/fb.h
--- linux-2.6.33/include/linux/fb.h	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/include/linux/fb.h	2010-03-19 22:53:42.000000000 +0100
@@ -1022,6 +1022,18 @@ static inline bool fb_be_math(struct fb_
 #endif /* CONFIG_FB_FOREIGN_ENDIAN */
 }
 
+static inline int *xenon_convert(struct fb_info *p, int *addr)
+{
+	int index = ((char*)addr) - ((char*)p->screen_base);
+	int y = index / (p->fix.line_length);
+	int x = index % (p->fix.line_length)/4;
+	unsigned int base = ((((y & ~31)*p->var.xres) + (x & ~31)*32 ) +
+	 (((x&3) + ((y&1)<<2) + ((x&28)<<1) + ((y&30)<<5)) ^ ((y&8)<<2))) * 4;
+
+	return (int*)(((char*)p->screen_base)+base);
+}
+
+
 /* drivers/video/fbsysfs.c */
 extern struct fb_info *framebuffer_alloc(size_t size, struct device *dev);
 extern void framebuffer_release(struct fb_info *info);
diff -NurpP --minimal linux-2.6.33/include/linux/irq.h linux-2.6.33-xbox0.10/include/linux/irq.h
--- linux-2.6.33/include/linux/irq.h	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/include/linux/irq.h	2010-03-29 18:41:23.000000000 +0200
@@ -307,6 +307,15 @@ extern unsigned int __do_IRQ(unsigned in
  */
 static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
 {
+	if (!desc) {
+		printk("generic_handle_irq_desc(%u,%p) ...\n", irq, desc);
+		return;
+	}
+#if 0
+	if (irq != 16 && irq != 76)
+		printk("generic_handle_irq_desc(%u,%p) -> %p\n",
+			irq, desc, desc ? desc->handle_irq : 0);
+#endif
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
 #else
diff -NurpP --minimal linux-2.6.33/include/linux/pci_ids.h linux-2.6.33-xbox0.10/include/linux/pci_ids.h
--- linux-2.6.33/include/linux/pci_ids.h	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/include/linux/pci_ids.h	2010-03-19 22:53:42.000000000 +0100
@@ -2175,6 +2175,8 @@
 #define PCI_DEVICE_ID_ADDIDATA_APCIe7500       0x7012
 #define PCI_DEVICE_ID_ADDIDATA_APCIe7800       0x7013
 
+#define PCI_VENDOR_ID_MICROSOFT		0x1414
+
 #define PCI_VENDOR_ID_PDC		0x15e9
 
 #define PCI_VENDOR_ID_FARSITE           0x1619
diff -NurpP --minimal linux-2.6.33/include/linux/serial_core.h linux-2.6.33-xbox0.10/include/linux/serial_core.h
--- linux-2.6.33/include/linux/serial_core.h	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/include/linux/serial_core.h	2010-03-21 16:45:57.000000000 +0100
@@ -182,6 +182,9 @@
 /* Aeroflex Gaisler GRLIB APBUART */
 #define PORT_APBUART    90
 
+/* Xenon XBOX 360 Southbridge */
+#define PORT_XENON	91
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
@@ -224,7 +227,7 @@ struct uart_ops {
 	/*
 	 * Return a string describing the type of the port
 	 */
-	const char *(*type)(struct uart_port *);
+	const char *	(*type)(struct uart_port *);
 
 	/*
 	 * Release IO and memory resources used by the port.
@@ -241,7 +244,7 @@ struct uart_ops {
 	int		(*verify_port)(struct uart_port *, struct serial_struct *);
 	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
 #ifdef CONFIG_CONSOLE_POLL
-	void	(*poll_put_char)(struct uart_port *, unsigned char);
+	void		(*poll_put_char)(struct uart_port *, unsigned char);
 	int		(*poll_get_char)(struct uart_port *);
 #endif
 };
diff -NurpP --minimal linux-2.6.33/kernel/printk.c linux-2.6.33-xbox0.10/kernel/printk.c
--- linux-2.6.33/kernel/printk.c	2010-03-21 15:30:39.000000000 +0100
+++ linux-2.6.33-xbox0.10/kernel/printk.c	2010-03-20 05:46:41.000000000 +0100
@@ -212,9 +212,9 @@ static unsigned long long loops_per_msec
 
 static int __init boot_delay_setup(char *str)
 {
-	unsigned long lpj;
+	unsigned long lpj = loops_per_jiffy;
 
-	lpj = preset_lpj ? preset_lpj : 1000000;	/* some guess */
+//	lpj = preset_lpj ? preset_lpj : 1000000;	/* some guess */
 	loops_per_msec = (unsigned long long)lpj / 1000 * HZ;
 
 	get_option(&str, &boot_delay);
diff -NurpP --minimal linux-2.6.33/lib/Kconfig.debug linux-2.6.33-xbox0.10/lib/Kconfig.debug
--- linux-2.6.33/lib/Kconfig.debug	2010-03-21 15:30:39.000000000 +0100
+++ linux-2.6.33-xbox0.10/lib/Kconfig.debug	2010-03-20 05:40:43.000000000 +0100
@@ -709,7 +709,7 @@ config FRAME_POINTER
 
 config BOOT_PRINTK_DELAY
 	bool "Delay each boot printk message by N milliseconds"
-	depends on DEBUG_KERNEL && PRINTK && GENERIC_CALIBRATE_DELAY
+	depends on DEBUG_KERNEL && PRINTK
 	help
 	  This build option allows you to read kernel boot messages
 	  by inserting a short delay after each one.  The delay is
diff -NurpP --minimal linux-2.6.33/Makefile linux-2.6.33-xbox0.10/Makefile
--- linux-2.6.33/Makefile	2010-02-24 19:52:17.000000000 +0100
+++ linux-2.6.33-xbox0.10/Makefile	2010-03-30 17:35:03.000000000 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 33
-EXTRAVERSION =
+EXTRAVERSION = linux-2.6.33-xbox0.10
 NAME = Man-Eating Seals of Antiquity
 
 # *DOCUMENTATION*
Files linux-2.6.33/scripts/binoffset and linux-2.6.33-xbox0.10/scripts/binoffset differ
diff -NurpP --minimal linux-2.6.33/sound/pci/Kconfig linux-2.6.33-xbox0.10/sound/pci/Kconfig
--- linux-2.6.33/sound/pci/Kconfig	2010-03-21 15:30:39.000000000 +0100
+++ linux-2.6.33-xbox0.10/sound/pci/Kconfig	2010-03-20 04:04:36.000000000 +0100
@@ -815,4 +815,13 @@ config SND_YMFPCI
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-ymfpci.
 
+config SND_XENON
+	tristate "Xenon XBOX 360 Sound"
+	select SND_PCM
+	help
+	  Say Y here to include support for the Xenon XBOX 360 soundcard.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-xenon.
+
 endif	# SND_PCI
diff -NurpP --minimal linux-2.6.33/sound/pci/Makefile linux-2.6.33-xbox0.10/sound/pci/Makefile
--- linux-2.6.33/sound/pci/Makefile	2010-03-21 15:30:39.000000000 +0100
+++ linux-2.6.33-xbox0.10/sound/pci/Makefile	2010-03-20 04:03:09.000000000 +0100
@@ -53,6 +53,7 @@ obj-$(CONFIG_SND_SIS7019) += snd-sis7019
 obj-$(CONFIG_SND_SONICVIBES) += snd-sonicvibes.o
 obj-$(CONFIG_SND_VIA82XX) += snd-via82xx.o
 obj-$(CONFIG_SND_VIA82XX_MODEM) += snd-via82xx-modem.o
+obj-$(CONFIG_SND_XENON) += snd-xenon.o
 
 obj-$(CONFIG_SND) += \
 	ac97/ \
diff -NurpP --minimal linux-2.6.33/sound/pci/snd-xenon.c linux-2.6.33-xbox0.10/sound/pci/snd-xenon.c
--- linux-2.6.33/sound/pci/snd-xenon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.33-xbox0.10/sound/pci/snd-xenon.c	2010-03-20 04:01:13.000000000 +0100
@@ -0,0 +1,686 @@
+/*
+ *  xenon_snd.c - driver for XBOX 360 soundcard.
+ *  Copyright (C) 2009 by jc4360@gmail.com
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+// #include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include <asm/io.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm-indirect.h>
+#include <sound/asoundef.h>
+
+#define DESCRIPTOR_BUFFER_SIZE (32 * sizeof(u32) * 2)
+#define CACHELINE_SIZE 128
+
+#define IRQ_DISABLE             0
+#define IRQ_ENABLE              1
+
+static struct pci_device_id snd_xenon_ids[] = {
+	{ 0x1414, 0x580c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_xenon_ids);
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+
+struct playback_device {
+	struct snd_pcm_substream *playback_substream;
+
+	int state;
+	void *dma_base_virt;
+	dma_addr_t descr_base_phys;
+	u32 *descr_base_virt;
+
+	int buffer_bytes;
+	int period_bytes;
+	int descr_bytes;
+	int gap;
+	int wptr;
+};
+
+struct snd_xenon {
+	unsigned long iobase_phys;
+	void *iobase_virt;
+
+	spinlock_t lock;
+	struct snd_card *card;
+	struct pci_dev *pci;
+
+	int irq;
+
+	dma_addr_t descr_base_phys;
+	void *descr_base_virt;
+
+	struct snd_pcm *pcm[2];
+	struct playback_device devices[2];
+
+	unsigned int dig_status;
+	unsigned int dig_pcm_status;
+
+	struct timer_list timer;
+	int timer_in_use;
+};
+
+static void cache_flush(void *addr, int size)
+{
+    void *p = addr;
+    while (size) {
+	__asm__ __volatile__ ("dcbst 0,%0" :: "r" (p));
+	p += 128;
+	size -= 128;
+    }
+    __asm__ __volatile__ ("sync" ::: "memory");
+}
+
+static inline u32 bswap32(u32 t)
+{
+	return ((t & 0xFF) << 24) | ((t & 0xFF00) << 8) | ((t & 0xFF0000) >> 8) | ((t & 0xFF000000) >> 24);
+}
+
+void xenon_smc_send_message(unsigned char *msg)
+{
+
+	void *base = ioremap_nocache(0x200ea001000, 0x1000);
+
+	while (!(readl(base + 0x84) & 4));
+	writel(4, base + 0x84);
+	writel(bswap32(*(u32 *)(msg + 0)), base + 0x80);
+	writel(bswap32(*(u32 *)(msg + 4)), base + 0x80);
+	writel(bswap32(*(u32 *)(msg + 8)), base + 0x80);
+	writel(bswap32(*(u32 *)(msg + 12)), base + 0x80);
+	writel(0, base + 0x84);
+	iounmap(base);
+}
+
+static inline void snd_xenon_set_irq_flag(struct snd_xenon *chip, int cmd)
+{
+	// enable/disable irq
+	return;
+}
+
+static irqreturn_t snd_xenon_interrupt(int irq, void *dev_id)
+{
+	printk("xenon_snd: give me an interrupt, please!\n");
+	return IRQ_HANDLED;
+}
+
+static void snd_xenon_timer_fn(unsigned long data)
+{
+	struct snd_xenon *chip = (struct snd_xenon *)data;
+	u32 reg;
+	int rptr_descr, wptr_descr, cur_len, size;
+
+	struct playback_device *device = NULL;
+	int dev_id = 0;
+
+	for (dev_id = 0; dev_id < 2; dev_id++) {
+
+		device = &chip->devices[dev_id];
+
+		spin_lock(&chip->lock);
+
+		if (device->state != 3) {
+			spin_unlock(&chip->lock);
+			continue;
+		}
+
+		reg = readl(chip->iobase_virt + 0x04 + dev_id * 0x10);
+		rptr_descr = reg & 0x1f;
+		wptr_descr = (reg & 0x1f00) >> 8;
+		cur_len = (reg >> 16) & 0xFFFF;
+
+		size = wptr_descr - rptr_descr;
+		if (size < 0) size += 32;
+		size *= device->descr_bytes;
+		size += cur_len;
+		if (wptr_descr < rptr_descr) size -= device->gap;
+		size = device->buffer_bytes - size;
+
+		if (size >= device->period_bytes) {
+			spin_unlock(&chip->lock);
+			snd_pcm_period_elapsed(device->playback_substream);
+		} else
+			spin_unlock(&chip->lock);
+	}
+
+	if (chip->timer_in_use) {
+		mod_timer(&chip->timer, jiffies + usecs_to_jiffies(200));
+	}
+
+}
+
+static struct snd_pcm_hardware snd_xenon_ana_playback_hw =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =              SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =                SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	64 * 1024,
+	.period_bytes_min =	64,
+	.period_bytes_max =	64 * 1024,
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =            0,
+};
+
+static struct snd_pcm_hardware snd_xenon_spdif_playback_hw =
+{
+	.info =                 (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =              SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =                SNDRV_PCM_RATE_48000,
+	.rate_min =             48000,
+	.rate_max =             48000,
+	.channels_min =         2,
+	.channels_max =         2,
+	.buffer_bytes_max =     64 * 1024,
+	.period_bytes_min =     64,
+	.period_bytes_max =     64 * 1024,
+	.periods_min =          1,
+	.periods_max =          1024,
+	.fifo_size =            0,
+};
+
+static int snd_xenon_playback_open(struct snd_pcm_substream *substream, int dev_id, struct snd_pcm_hardware *playback_hw)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct playback_device *device = &chip->devices[dev_id];
+
+	runtime->hw = *playback_hw;
+
+	spin_lock_irq(&chip->lock);
+
+	memset(device, 0, sizeof(struct playback_device));
+	device->playback_substream = substream;
+
+	writel(0x2000000, chip->iobase_virt + 0x08 + dev_id * 0x10);
+	device->descr_base_phys =
+		chip->descr_base_phys +  dev_id * 0x100;
+	device->descr_base_virt =
+		(u32 *)(chip->descr_base_virt + dev_id * 0x100);
+	device->state = 1;
+
+	spin_unlock_irq(&chip->lock);
+
+	return 0;
+}
+
+static int snd_xenon_ana_playback_open(struct snd_pcm_substream *substream)
+{
+	return snd_xenon_playback_open(substream, 0, &snd_xenon_ana_playback_hw);
+}
+
+static int snd_xenon_spdif_playback_open(struct snd_pcm_substream *substream)
+{
+	return snd_xenon_playback_open(substream, 1, &snd_xenon_spdif_playback_hw);
+}
+static int snd_xenon_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct playback_device *device = &chip->devices[0];
+
+	if (device->playback_substream != substream)
+		device = &chip->devices[1];
+
+	spin_lock_irq(&chip->lock);
+	device->state = 0;
+	spin_unlock_irq(&chip->lock);
+
+	if (device->dma_base_virt != NULL)
+	   iounmap(device->dma_base_virt);
+
+	device->playback_substream = NULL;
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_xenon_pcm_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *hw_params)
+{
+	int bytes = params_buffer_bytes(hw_params);
+	return snd_pcm_lib_malloc_pages(substream, bytes);
+}
+
+static int snd_xenon_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_xenon_playback_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct playback_device *device = &chip->devices[0];
+	int i , dev_id = 0;
+
+	if (device->playback_substream != substream) {
+		dev_id = 1;
+		device = &chip->devices[1];
+	}
+
+	spin_lock_irq(&chip->lock);
+
+	device->dma_base_virt =
+		ioremap_nocache(runtime->dma_addr, runtime->dma_bytes);
+
+	memset(device->dma_base_virt, 0, runtime->dma_bytes);
+	cache_flush(device->dma_base_virt, runtime->dma_bytes);
+
+	device->state = 2;
+	device->period_bytes = snd_pcm_lib_period_bytes(substream);
+	device->buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	device->descr_bytes = (device->buffer_bytes + 31 ) / 32;
+	device->gap = (device->descr_bytes << 5) -
+			    device->buffer_bytes;
+	device->wptr = -1;
+
+
+	for (i=0; i < 32; i++) {
+		device->descr_base_virt[i*2] =
+			bswap32(runtime->dma_addr + device->descr_bytes * i);
+		device->descr_base_virt[i*2 + 1] =
+			bswap32(0x80000000 | (device->descr_bytes - 1));
+	}
+	device->descr_base_virt[31*2 + 1] =
+		bswap32(0x80000000 | (device->descr_bytes - 1 - device->gap));
+	cache_flush(device->descr_base_virt, DESCRIPTOR_BUFFER_SIZE);
+
+	writel(device->descr_base_phys, chip->iobase_virt + 0x00 + dev_id * 0x10);
+	writel(0x1c08001c, chip->iobase_virt + 0x08 + dev_id * 0x10);
+	writel((dev_id==0)?0x1c:0x02009902, chip->iobase_virt + 0x0c + dev_id * 0x10);
+
+	spin_unlock_irq(&chip->lock);
+	return 0;
+}
+
+static int snd_xenon_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct playback_device *device = &chip->devices[0];
+	int dev_id = 0, ret = 0;
+	u32 reg;
+
+	if (device->playback_substream != substream) {
+		dev_id = 1;
+		device = &chip->devices[1];
+	}
+
+	spin_lock(&chip->lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		device->state = 3;
+
+		reg = readl(chip->iobase_virt + 0x08 + dev_id * 0x10);
+		writel(reg | 0x1000000, chip->iobase_virt + 0x08 + dev_id * 0x10);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		device->state = 4;
+		reg = readl(chip->iobase_virt + 0x08 + dev_id * 0x10);
+		writel(reg & ~0x1000000, chip->iobase_virt + 0x08 + dev_id * 0x10);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+	spin_unlock(&chip->lock);
+
+	return ret;
+}
+
+static snd_pcm_uframes_t snd_xenon_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_xenon *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct playback_device *device = &chip->devices[0];
+
+	int dev_id = 0;
+	int app_ptr, app_descr, bytes;
+	u32 reg;
+
+	if (device->playback_substream != substream) {
+		dev_id = 1;
+		device = &chip->devices[1];
+	}
+
+	spin_lock(&chip->lock);
+
+	app_ptr = frames_to_bytes(runtime, runtime->control->appl_ptr) %
+		      device->buffer_bytes;
+
+	if (app_ptr != device->wptr)
+		cache_flush(device->dma_base_virt, runtime->dma_bytes);
+
+	app_descr = app_ptr / device->descr_bytes;
+	reg = readl(chip->iobase_virt + 0x04 + dev_id * 0x10);
+	if (app_descr == (( reg & 0x1f00) >> 8))
+	    app_descr -= 1;
+	if (app_descr < 0) app_descr += 32;
+
+	device->wptr = app_ptr;
+
+	writel(app_descr << 8, chip->iobase_virt + 0x04 + dev_id * 0x10);
+
+	spin_unlock(&chip->lock);
+
+	bytes = (reg & 0x1f) * (device->descr_bytes);
+	return bytes_to_frames(substream->runtime, bytes);
+}
+
+static struct snd_pcm_ops snd_xenon_ana_playback_ops = {
+	.open =		snd_xenon_ana_playback_open,
+	.close =	snd_xenon_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_xenon_pcm_hw_params,
+	.hw_free =	snd_xenon_pcm_hw_free,
+	.prepare =	snd_xenon_playback_prepare,
+	.trigger =	snd_xenon_trigger,
+	.pointer =	snd_xenon_pointer,
+};
+
+static struct snd_pcm_ops snd_xenon_spdif_playback_ops = {
+	.open =         snd_xenon_spdif_playback_open,
+	.close =        snd_xenon_playback_close,
+	.ioctl =        snd_pcm_lib_ioctl,
+	.hw_params =    snd_xenon_pcm_hw_params,
+	.hw_free =      snd_xenon_pcm_hw_free,
+	.prepare =      snd_xenon_playback_prepare,
+	.trigger =      snd_xenon_trigger,
+	.pointer =      snd_xenon_pointer,
+};
+
+static int __devinit snd_xenon_new_pcm(struct snd_xenon *chip)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(chip->card, "Xenon Audio", 0, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = chip;
+	strcpy(pcm->name, "Analog");
+	chip->pcm[0] = pcm;
+
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_xenon_ana_playback_ops);
+
+	/* pre-allocation of buffers */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
+
+	err = snd_pcm_new(chip->card, "Xenon Audio", 1, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = chip;
+	strcpy(pcm->name, "Digital");
+	chip->pcm[1] = pcm;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_xenon_spdif_playback_ops);
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
+
+	return 0;
+}
+
+static void snd_xenon_init(struct snd_xenon *chip)
+{
+	unsigned long flags;
+	static unsigned char smc_snd[32] = {0x8d, 1, 1};
+	xenon_smc_send_message(smc_snd);
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	chip->descr_base_virt = pci_alloc_consistent(chip->pci,
+			 DESCRIPTOR_BUFFER_SIZE * 2, &chip->descr_base_phys);
+	chip->descr_base_phys &= 0x1fffffff;
+	printk("snd_xenon: descr_base_virt=0x%llx, descr_base_phys=0x%llx\n",
+		(unsigned long long)chip->descr_base_virt,
+		(unsigned long long)chip->descr_base_phys);
+
+	writel(0, chip->iobase_virt + 0x08);
+	writel(0x2000000, chip->iobase_virt + 0x08);
+	writel(chip->descr_base_phys, chip->iobase_virt + 0x00);
+
+	writel(0, chip->iobase_virt + 0x18);
+	writel(0x2000000, chip->iobase_virt + 0x18);
+	writel(chip->descr_base_phys + DESCRIPTOR_BUFFER_SIZE,
+		chip->iobase_virt + 0x10);
+
+	/* Enable IRQ output */
+	snd_xenon_set_irq_flag(chip, IRQ_ENABLE);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int snd_xenon_dev_free(struct snd_device *device);
+static int snd_xenon_free(struct snd_xenon *chip);
+
+static int __devinit snd_xenon_create(struct snd_card *card,
+				       struct pci_dev *pci,
+				       struct snd_xenon **rchip)
+{
+	struct snd_xenon *chip;
+	int err;
+
+	static struct snd_device_ops ops = {
+		.dev_free = snd_xenon_dev_free,
+	};
+	*rchip = NULL;
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	pci_set_master(pci);
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	chip->dig_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
+	chip->dig_pcm_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
+	spin_lock_init(&chip->lock);
+
+	if (!( pci_resource_flags (pci, 0) & IORESOURCE_MEM)) {
+		dev_err(&pci->dev,
+			"region #0 not an MMIO resource, aborting\n");
+		return -ENODEV;
+	}
+
+	if ((err = pci_request_regions(pci, "Xenon AudioPCI")) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+
+	chip->iobase_phys = pci_resource_start(pci, 0);
+	chip->iobase_virt = ioremap_nocache(chip->iobase_phys,
+				      pci_resource_len(pci, 0));
+
+	printk("snd_xenon: iobase_phys=0x%lx iobase_virt=0x%llx\n", chip->iobase_phys, (unsigned long long)chip->iobase_virt);
+
+	if (request_irq(pci->irq, snd_xenon_interrupt, IRQF_SHARED,
+			card->shortname, chip)) {
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		snd_xenon_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+	pci_intx(pci, IRQ_ENABLE);
+	printk("snd_xenon: irq=%x\n", chip->irq);
+
+	snd_xenon_init(chip);
+
+	if ((err = snd_xenon_new_pcm(chip)) < 0) {
+		snd_printk(KERN_WARNING "Could not to create PCM\n");
+		snd_xenon_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+						chip, &ops)) < 0) {
+		snd_xenon_free(chip);
+		return err;
+	}
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rchip = chip;
+
+	init_timer(&chip->timer);
+	chip->timer.function = snd_xenon_timer_fn;
+	chip->timer.data = (unsigned long)chip;
+	chip->timer_in_use = 1;
+	add_timer(&chip->timer);
+
+	printk("snd_xenon: driver initialized\n");
+
+	return 0;
+}
+
+static int snd_xenon_dev_free(struct snd_device *device)
+{
+	struct snd_xenon *chip = device->device_data;
+	return snd_xenon_free(chip);
+}
+
+static int snd_xenon_free(struct snd_xenon *chip)
+{
+	snd_xenon_set_irq_flag(chip, IRQ_DISABLE);
+
+	spin_lock_irq(&chip->lock);
+	chip->timer_in_use = 0;
+	spin_unlock_irq(&chip->lock);
+	del_timer_sync(&chip->timer);
+
+	if (chip->irq >= 0)
+		free_irq(chip->irq, chip);
+	if (chip->descr_base_virt)
+		pci_free_consistent(chip->pci, DESCRIPTOR_BUFFER_SIZE * 2, chip->descr_base_virt, chip->descr_base_phys);
+	if (chip->iobase_virt)
+		  iounmap(chip->iobase_virt);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	return 0;
+}
+
+static int __devinit snd_xenon_probe(struct pci_dev *pci,
+			     const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct snd_card *card;
+	struct snd_xenon *chip;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return -ENOMEM;
+
+	if ((err = snd_xenon_create(card, pci, &chip)) < 0) {
+		snd_card_free(card);
+		snd_xenon_free(chip);
+		return err;
+	}
+	card->private_data = chip;
+
+	strcpy(card->driver, "snd-xenon");
+	sprintf(card->shortname, "Xenon AudioPCI");
+	sprintf(card->longname, "%s at 0x%lx irq %i",
+				card->shortname, chip->iobase_phys, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		snd_xenon_free(chip);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+
+	return 0;
+}
+
+static void __devexit snd_xenon_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "snd-xenon",
+	.id_table = snd_xenon_ids,
+	.probe = snd_xenon_probe,
+	.remove = __devexit_p(snd_xenon_remove),
+};
+
+static int __init alsa_card_xenon_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit alsa_card_xenon_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_xenon_init)
+module_exit(alsa_card_xenon_exit)
+
+MODULE_AUTHOR("jc4360@gmail.com");
+MODULE_DESCRIPTION("Xenon Audio Driver");
+MODULE_LICENSE("GPL");
